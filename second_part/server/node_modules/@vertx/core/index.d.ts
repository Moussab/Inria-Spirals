export interface AsyncResult<T> {
  succeeded() : boolean;
  failed() : boolean;
  cause() : Error | null;
  result() : T | null;
}


export class AsyncFile {
  /**
   *  Same as {@link #end()} but writes some data to the stream before ending.
   * 
   */
  end(t: Buffer) : void;

  /**
   *  This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  handler(handler: (result: Buffer) => void | null | undefined) : AsyncFile;

  pause() : AsyncFile;

  resume() : AsyncFile;

  endHandler(endHandler: (result: void) => void | null | undefined) : AsyncFile;

  write(data: Buffer) : AsyncFile;

  setWriteQueueMaxSize(maxSize: number) : AsyncFile;

  drainHandler(handler: (result: void) => void | null | undefined) : AsyncFile;

  exceptionHandler(handler: (result: Error) => void | null | undefined) : AsyncFile;

  /**
   *  Close the file, see {@link #close()}.
   * 
   */
  end() : void;

  /**
   *  Close the file. The actual close happens asynchronously.
   * 
   */
  close() : void;

  /**
   *  Close the file. The actual close happens asynchronously.
   *  The handler will be called when the close is complete, or an error occurs.
   * @param handler  the handler
   * 
   */
  close(handler: (result: AsyncResult<void>) => void) : void;

  /**
   *  Write a {@link io.vertx.core.buffer.Buffer} to the file at position {@code position} in the file, asynchronously.
   *  <p>
   *  If {@code position} lies outside of the current size
   *  of the file, the file will be enlarged to encompass it.
   *  <p>
   *  When multiple writes are invoked on the same file
   *  there are no guarantees as to order in which those writes actually occur
   *  <p>
   *  The handler will be called when the write is complete, or if an error occurs.
   * @param buffer  the buffer to write
   * @param position  the position in the file to write it at
   * @param handler  the handler to call when the write is complete
   * @return a reference to this, so the API can be used fluently
   * 
   */
  write(buffer: Buffer, position: number, handler: (result: AsyncResult<void>) => void) : AsyncFile;

  /**
   *  Reads {@code length} bytes of data from the file at position {@code position} in the file, asynchronously.
   *  <p>
   *  The read data will be written into the specified {@code Buffer buffer} at position {@code offset}.
   *  <p>
   *  If data is read past the end of the file then zero bytes will be read.<p>
   *  When multiple reads are invoked on the same file there are no guarantees as to order in which those reads actually occur.
   *  <p>
   *  The handler will be called when the close is complete, or if an error occurs.
   * @param buffer  the buffer to read into
   * @param offset  the offset into the buffer where the data will be read
   * @param position  the position in the file where to start reading
   * @param length  the number of bytes to read
   * @param handler  the handler to call when the write is complete
   * @return a reference to this, so the API can be used fluently
   * 
   */
  read(buffer: Buffer, offset: number, position: number, length: number, handler: (result: AsyncResult<Buffer>) => void) : AsyncFile;

  /**
   *  Flush any writes made to this file to underlying persistent storage.
   *  <p>
   *  If the file was opened with {@code flush} set to {@code true} then calling this method will have no effect.
   *  <p>
   *  The actual flush will happen asynchronously.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  flush() : AsyncFile;

  /**
   *  Same as {@link #flush} but the handler will be called when the flush is complete or if an error occurs
   * 
   */
  flush(handler: (result: AsyncResult<void>) => void) : AsyncFile;

  /**
   *  Sets the position from which data will be read from when using the file as a {@link io.vertx.core.streams.ReadStream}.
   * @param readPos  the position in the file
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReadPos(readPos: number) : AsyncFile;

  /**
   *  Sets the position from which data will be written when using the file as a {@link io.vertx.core.streams.WriteStream}.
   * @param writePos  the position in the file
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWritePos(writePos: number) : AsyncFile;

  /**
   *  Sets the buffer size that will be used to read the data from the file. Changing this value will impact how much
   *  the data will be read at a time from the file system.
   * @param readBufferSize the buffer size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setReadBufferSize(readBufferSize: number) : AsyncFile;

}


export class AsyncMap {
  /**
   *  Get a value from the map, asynchronously.
   * @param k  the key
   * @param resultHandler - this will be called some time later with the async result.
   * 
   */
  get(k: any, resultHandler: (result: AsyncResult<any>) => void) : void;

  /**
   *  Put a value in the map, asynchronously.
   * @param k  the key
   * @param v  the value
   * @param completionHandler - this will be called some time later to signify the value has been put
   * 
   */
  put(k: any, v: any, completionHandler: (result: AsyncResult<void>) => void) : void;

  /**
   *  Like {@link #put} but specifying a time to live for the entry. Entry will expire and get evicted after the
   *  ttl.
   * @param k  the key
   * @param v  the value
   * @param ttl  The time to live (in ms) for the entry
   * @param completionHandler  the handler
   * 
   */
  put(k: any, v: any, ttl: number, completionHandler: (result: AsyncResult<void>) => void) : void;

  /**
   *  Put the entry only if there is no entry with the key already present. If key already present then the existing
   *  value will be returned to the handler, otherwise null.
   * @param k  the key
   * @param v  the value
   * @param completionHandler  the handler
   * 
   */
  putIfAbsent(k: any, v: any, completionHandler: (result: AsyncResult<any>) => void) : void;

  /**
   *  Link {@link #putIfAbsent} but specifying a time to live for the entry. Entry will expire and get evicted
   *  after the ttl.
   * @param k  the key
   * @param v  the value
   * @param ttl  The time to live (in ms) for the entry
   * @param completionHandler  the handler
   * 
   */
  putIfAbsent(k: any, v: any, ttl: number, completionHandler: (result: AsyncResult<any>) => void) : void;

  /**
   *  Remove a value from the map, asynchronously.
   * @param k  the key
   * @param resultHandler - this will be called some time later to signify the value has been removed
   * 
   */
  remove(k: any, resultHandler: (result: AsyncResult<any>) => void) : void;

  /**
   *  Remove a value from the map, only if entry already exists with same value.
   * @param k  the key
   * @param v  the value
   * @param resultHandler - this will be called some time later to signify the value has been removed
   * 
   */
  removeIfPresent(k: any, v: any, resultHandler: (result: AsyncResult<boolean>) => void) : void;

  /**
   *  Replace the entry only if it is currently mapped to some value
   * @param k  the key
   * @param v  the new value
   * @param resultHandler  the result handler will be passed the previous value
   * 
   */
  replace(k: any, v: any, resultHandler: (result: AsyncResult<any>) => void) : void;

  /**
   *  Replace the entry only if it is currently mapped to a specific value
   * @param k  the key
   * @param oldValue  the existing value
   * @param newValue  the new value
   * @param resultHandler the result handler
   * 
   */
  replaceIfPresent(k: any, oldValue: any, newValue: any, resultHandler: (result: AsyncResult<boolean>) => void) : void;

  /**
   *  Clear all entries in the map
   * @param resultHandler  called on completion
   * 
   */
  clear(resultHandler: (result: AsyncResult<void>) => void) : void;

  /**
   *  Provide the number of entries in the map
   * @param resultHandler  handler which will receive the number of entries
   * 
   */
  size(resultHandler: (result: AsyncResult<number>) => void) : void;

}


export class Buffer {
  /**
   *  Create a new, empty buffer.
   * @return the buffer
   * 
   */
  static buffer() : Buffer;

  /**
   *  Create a new buffer given the initial size hint.
   *  <p>
   *  If you know the buffer will require a certain size, providing the hint can prevent unnecessary re-allocations
   *  as the buffer is written to and resized.
   * @param initialSizeHint the hint, in bytes
   * @return the buffer
   * 
   */
  static buffer(initialSizeHint: number) : Buffer;

  /**
   *  Create a new buffer from a string. The string will be UTF-8 encoded into the buffer.
   * @param string the string
   * @return the buffer
   * 
   */
  static buffer(string: string) : Buffer;

  /**
   *  Create a new buffer from a string and using the specified encoding.
   *  The string will be encoded into the buffer using the specified encoding.
   * @param string the string
   * @return the buffer
   * 
   */
  static buffer(string: string, enc: string) : Buffer;

  /**
   *  Returns a {@code String} representation of the Buffer with the {@code UTF-8 }encoding
   * 
   */
  toString() : string;

  /**
   *  Returns a {@code String} representation of the Buffer with the encoding specified by {@code enc}
   * 
   */
  toString(enc: string) : string;

  /**
   *  Returns a Json object representation of the Buffer
   * 
   */
  toJsonObject() : object;

  /**
   *  Returns a Json array representation of the Buffer
   * 
   */
  toJsonArray() : any[];

  /**
   *  Returns the {@code byte} at position {@code pos} in the Buffer.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 1} is greater than the length of the Buffer.
   * 
   */
  getByte(pos: number) : number;

  /**
   *  Returns the unsigned {@code byte} at position {@code pos} in the Buffer, as a {@code short}.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 1} is greater than the length of the Buffer.
   * 
   */
  getUnsignedByte(pos: number) : number;

  /**
   *  Returns the {@code int} at position {@code pos} in the Buffer.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 4} is greater than the length of the Buffer.
   * 
   */
  getInt(pos: number) : number;

  /**
   *  Gets a 32-bit integer at the specified absolute {@code index} in this buffer with Little Endian Byte Order.
   * @throws IndexOutOfBoundsException if the specified {@code index} is less than {@code 0} or {@code index + 4} is greater than {@code this.capacity}
   * 
   */
  getIntLE(pos: number) : number;

  /**
   *  Returns the unsigned {@code int} at position {@code pos} in the Buffer, as a {@code long}.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 4} is greater than the length of the Buffer.
   * 
   */
  getUnsignedInt(pos: number) : number;

  /**
   *  Returns the unsigned {@code int} at position {@code pos} in the Buffer, as a {@code long} in Little Endian Byte Order.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 4} is greater than the length of the Buffer.
   * 
   */
  getUnsignedIntLE(pos: number) : number;

  /**
   *  Returns the {@code long} at position {@code pos} in the Buffer.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 8} is greater than the length of the Buffer.
   * 
   */
  getLong(pos: number) : number;

  /**
   *  Gets a 64-bit long integer at the specified absolute {@code index} in this buffer in Little Endian Byte Order.
   * @throws IndexOutOfBoundsException if the specified {@code index} is less than {@code 0} or {@code index + 8} is greater than the length of the Buffer.
   * 
   */
  getLongLE(pos: number) : number;

  /**
   *  Returns the {@code double} at position {@code pos} in the Buffer.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 8} is greater than the length of the Buffer.
   * 
   */
  getDouble(pos: number) : number;

  /**
   *  Returns the {@code float} at position {@code pos} in the Buffer.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 4} is greater than the length of the Buffer.
   * 
   */
  getFloat(pos: number) : number;

  /**
   *  Returns the {@code short} at position {@code pos} in the Buffer.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 2} is greater than the length of the Buffer.
   * 
   */
  getShort(pos: number) : number;

  /**
   *  Gets a 16-bit short integer at the specified absolute {@code index} in this buffer in Little Endian Byte Order.
   * @throws IndexOutOfBoundsException if the specified {@code index} is less than {@code 0} or {@code index + 2} is greater than the length of the Buffer.
   * 
   */
  getShortLE(pos: number) : number;

  /**
   *  Returns the unsigned {@code short} at position {@code pos} in the Buffer, as an {@code int}.
   * @throws IndexOutOfBoundsException if the specified {@code pos} is less than {@code 0} or {@code pos + 2} is greater than the length of the Buffer.
   * 
   */
  getUnsignedShort(pos: number) : number;

  /**
   *  Gets an unsigned 16-bit short integer at the specified absolute {@code index} in this buffer in Little Endian Byte Order.
   * @throws IndexOutOfBoundsException if the specified {@code index} is less than {@code 0} or {@code index + 2} is greater than the length of the Buffer.
   * 
   */
  getUnsignedShortLE(pos: number) : number;

  /**
   *  Gets a 24-bit medium integer at the specified absolute {@code index} in this buffer.
   * @throws IndexOutOfBoundsException if the specified {@code index} is less than {@code 0} or {@code index + 3} is greater than the length of the Buffer.
   * 
   */
  getMedium(pos: number) : number;

  /**
   *  Gets a 24-bit medium integer at the specified absolute {@code index} in this buffer in the Little Endian Byte Order.
   * @throws IndexOutOfBoundsException if the specified {@code index} is less than {@code 0} or {@code index + 3} is greater than the length of the Buffer.
   * 
   */
  getMediumLE(pos: number) : number;

  /**
   *  Gets an unsigned 24-bit medium integer at the specified absolute {@code index} in this buffer.
   * @throws IndexOutOfBoundsException if the specified {@code index} is less than {@code 0} or {@code index + 3} is greater than the length of the Buffer.
   * 
   */
  getUnsignedMedium(pos: number) : number;

  /**
   *  Gets an unsigned 24-bit medium integer at the specified absolute {@code index} in this buffer in Little Endian Byte Order.
   * @throws IndexOutOfBoundsException if the specified {@code index} is less than {@code 0} or {@code index + 3} is greater than the length of the Buffer.
   * 
   */
  getUnsignedMediumLE(pos: number) : number;

  /**
   *  Returns a copy of a sub-sequence the Buffer as a {@link io.vertx.core.buffer.Buffer} starting at position {@code start}
   *  and ending at position {@code end - 1}
   * 
   */
  getBuffer(start: number, end: number) : Buffer;

  /**
   *  Returns a copy of a sub-sequence the Buffer as a {@code String} starting at position {@code start}
   *  and ending at position {@code end - 1} interpreted as a String in the specified encoding
   * 
   */
  getString(start: number, end: number, enc: string) : string;

  /**
   *  Returns a copy of a sub-sequence the Buffer as a {@code String} starting at position {@code start}
   *  and ending at position {@code end - 1} interpreted as a String in UTF-8 encoding
   * 
   */
  getString(start: number, end: number) : string;

  /**
   *  Appends the specified {@code Buffer} to the end of this Buffer. The buffer will expand as necessary to accommodate
   *  any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendBuffer(buff: Buffer) : Buffer;

  /**
   *  Appends the specified {@code Buffer} starting at the {@code offset} using {@code len} to the end of this Buffer. The buffer will expand as necessary to accommodate
   *  any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendBuffer(buff: Buffer, offset: number, len: number) : Buffer;

  /**
   *  Appends the specified {@code byte} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendByte(b: number) : Buffer;

  /**
   *  Appends the specified unsigned {@code byte} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendUnsignedByte(b: number) : Buffer;

  /**
   *  Appends the specified {@code int} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendInt(i: number) : Buffer;

  /**
   *  Appends the specified {@code int} to the end of the Buffer in the Little Endian Byte Order. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendIntLE(i: number) : Buffer;

  /**
   *  Appends the specified unsigned {@code int} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendUnsignedInt(i: number) : Buffer;

  /**
   *  Appends the specified unsigned {@code int} to the end of the Buffer in the Little Endian Byte Order. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendUnsignedIntLE(i: number) : Buffer;

  /**
   *  Appends the specified 24bit {@code int} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendMedium(i: number) : Buffer;

  /**
   *  Appends the specified 24bit {@code int} to the end of the Buffer in the Little Endian Byte Order. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendMediumLE(i: number) : Buffer;

  /**
   *  Appends the specified {@code long} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendLong(l: number) : Buffer;

  /**
   *  Appends the specified {@code long} to the end of the Buffer in the Little Endian Byte Order. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendLongLE(l: number) : Buffer;

  /**
   *  Appends the specified {@code short} to the end of the Buffer.The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendShort(s: number) : Buffer;

  /**
   *  Appends the specified {@code short} to the end of the Buffer in the Little Endian Byte Order.The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendShortLE(s: number) : Buffer;

  /**
   *  Appends the specified unsigned {@code short} to the end of the Buffer.The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendUnsignedShort(s: number) : Buffer;

  /**
   *  Appends the specified unsigned {@code short} to the end of the Buffer in the Little Endian Byte Order.The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendUnsignedShortLE(s: number) : Buffer;

  /**
   *  Appends the specified {@code float} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendFloat(f: number) : Buffer;

  /**
   *  Appends the specified {@code double} to the end of the Buffer. The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.
   * 
   */
  appendDouble(d: number) : Buffer;

  /**
   *  Appends the specified {@code String} to the end of the Buffer with the encoding as specified by {@code enc}.<p>
   *  The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together.<p>
   * 
   */
  appendString(str: string, enc: string) : Buffer;

  /**
   *  Appends the specified {@code String str} to the end of the Buffer with UTF-8 encoding.<p>
   *  The buffer will expand as necessary to accommodate any bytes written.<p>
   *  Returns a reference to {@code this} so multiple operations can be appended together<p>
   * 
   */
  appendString(str: string) : Buffer;

  /**
   *  Sets the {@code byte} at position {@code pos} in the Buffer to the value {@code b}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setByte(pos: number, b: number) : Buffer;

  /**
   *  Sets the unsigned {@code byte} at position {@code pos} in the Buffer to the value {@code b}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setUnsignedByte(pos: number, b: number) : Buffer;

  /**
   *  Sets the {@code int} at position {@code pos} in the Buffer to the value {@code i}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setInt(pos: number, i: number) : Buffer;

  /**
   *  Sets the {@code int} at position {@code pos} in the Buffer to the value {@code i} in the Little Endian Byte Order.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setIntLE(pos: number, i: number) : Buffer;

  /**
   *  Sets the unsigned {@code int} at position {@code pos} in the Buffer to the value {@code i}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setUnsignedInt(pos: number, i: number) : Buffer;

  /**
   *  Sets the unsigned {@code int} at position {@code pos} in the Buffer to the value {@code i} in the Little Endian Byte Order.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setUnsignedIntLE(pos: number, i: number) : Buffer;

  /**
   *  Sets the 24bit {@code int} at position {@code pos} in the Buffer to the value {@code i}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setMedium(pos: number, i: number) : Buffer;

  /**
   *  Sets the 24bit {@code int} at position {@code pos} in the Buffer to the value {@code i}. in the Little Endian Byte Order<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setMediumLE(pos: number, i: number) : Buffer;

  /**
   *  Sets the {@code long} at position {@code pos} in the Buffer to the value {@code l}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setLong(pos: number, l: number) : Buffer;

  /**
   *  Sets the {@code long} at position {@code pos} in the Buffer to the value {@code l} in the Little Endian Byte Order.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setLongLE(pos: number, l: number) : Buffer;

  /**
   *  Sets the {@code double} at position {@code pos} in the Buffer to the value {@code d}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setDouble(pos: number, d: number) : Buffer;

  /**
   *  Sets the {@code float} at position {@code pos} in the Buffer to the value {@code f}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setFloat(pos: number, f: number) : Buffer;

  /**
   *  Sets the {@code short} at position {@code pos} in the Buffer to the value {@code s}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setShort(pos: number, s: number) : Buffer;

  /**
   *  Sets the {@code short} at position {@code pos} in the Buffer to the value {@code s} in the Little Endian Byte Order.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setShortLE(pos: number, s: number) : Buffer;

  /**
   *  Sets the unsigned {@code short} at position {@code pos} in the Buffer to the value {@code s}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setUnsignedShort(pos: number, s: number) : Buffer;

  /**
   *  Sets the unsigned {@code short} at position {@code pos} in the Buffer to the value {@code s} in the Little Endian Byte Order.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setUnsignedShortLE(pos: number, s: number) : Buffer;

  /**
   *  Sets the bytes at position {@code pos} in the Buffer to the bytes represented by the {@code Buffer b}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setBuffer(pos: number, b: Buffer) : Buffer;

  /**
   *  Sets the bytes at position {@code pos} in the Buffer to the bytes represented by the {@code Buffer b} on the given {@code offset} and {@code len}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setBuffer(pos: number, b: Buffer, offset: number, len: number) : Buffer;

  /**
   *  Sets the bytes at position {@code pos} in the Buffer to the value of {@code str} encoded in UTF-8.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setString(pos: number, str: string) : Buffer;

  /**
   *  Sets the bytes at position {@code pos} in the Buffer to the value of {@code str} encoded in encoding {@code enc}.<p>
   *  The buffer will expand as necessary to accommodate any value written.
   * 
   */
  setString(pos: number, str: string, enc: string) : Buffer;

  /**
   *  Returns the length of the buffer, measured in bytes.
   *  All positions are indexed from zero.
   * 
   */
  length() : number;

  /**
   *  Returns a copy of the entire Buffer.
   * 
   */
  copy() : Buffer;

  /**
   *  Returns a slice of this buffer. Modifying the content
   *  of the returned buffer or this buffer affects each other's content
   *  while they maintain separate indexes and marks.
   * 
   */
  slice() : Buffer;

  /**
   *  Returns a slice of this buffer. Modifying the content
   *  of the returned buffer or this buffer affects each other's content
   *  while they maintain separate indexes and marks.
   * 
   */
  slice(start: number, end: number) : Buffer;

}

import { Option } from './options';
import { Argument } from './options';

export class CLI {
  /**
   *  Creates an instance of {@link CLI} using the default implementation.
   * @param name the name of the CLI (must not be {@code null})
   * @return the created instance of {@link CLI}
   * 
   */
  static create(name: string) : CLI;

  /**
   *  Parses the user command line interface and create a new {@link CommandLine} containing extracting values.
   * @param arguments the arguments
   * @return the creates command line
   * 
   */
  parse(arguments: string[]) : CommandLine;

  /**
   *  Parses the user command line interface and create a new {@link CommandLine} containing extracting values.
   * @param arguments the arguments
   * @param validate  enable / disable parsing validation
   * @return the creates command line
   * 
   */
  parse(arguments: string[], validate: boolean) : CommandLine;

  /**
   * 
   * @return the CLI name.
   * 
   */
  getName() : string;

  /**
   *  Sets the name of the CLI.
   * @param name the name
   * @return the current {@link CLI} instance
   * 
   */
  setName(name: string) : CLI;

  /**
   * 
   * @return the CLI description.
   * 
   */
  getDescription() : string | null;

  setDescription(desc: string) : CLI;

  /**
   * 
   * @return the CLI summary.
   * 
   */
  getSummary() : string | null;

  /**
   *  Sets the summary of the CLI.
   * @param summary the summary
   * @return the current {@link CLI} instance
   * 
   */
  setSummary(summary: string) : CLI;

  /**
   *  Checks whether or not the current {@link CLI} instance is hidden.
   * @return {@code true} if the current {@link CLI} is hidden, {@link false} otherwise
   * 
   */
  isHidden() : boolean;

  /**
   *  Sets whether or not the current instance of {@link CLI} must be hidden. Hidden CLI are not listed when
   *  displaying usages / help messages. In other words, hidden commands are for power user.
   * @param hidden enables or disables the hidden aspect of the CI
   * @return the current {@link CLI} instance
   * 
   */
  setHidden(hidden: boolean) : CLI;

  /**
   *  Gets the list of options.
   * @return the list of options, empty if none.
   * 
   */
  getOptions() : Option[];

  /**
   *  Adds an option.
   * @param option the option, must not be {@code null}.
   * @return the current {@link CLI} instance
   * 
   */
  addOption(option: Option) : CLI;

  /**
   *  Adds a set of options. Unlike {@link #setOptions(List)}}, this method does not remove the existing options.
   *  The given list is appended to the existing list.
   * @param options the options, must not be {@code null}
   * @return the current {@link CLI} instance
   * 
   */
  addOptions(options: Option[]) : CLI;

  /**
   *  Sets the list of arguments.
   * @param options the list of options, must not be {@code null}
   * @return the current {@link CLI} instance
   * 
   */
  setOptions(options: Option[]) : CLI;

  /**
   *  Gets the list of defined arguments.
   * @return the list of argument, empty if none.
   * 
   */
  getArguments() : Argument[];

  /**
   *  Adds an argument.
   * @param arg the argument, must not be {@code null}
   * @return the current {@link CLI} instance
   * 
   */
  addArgument(arg: Argument) : CLI;

  /**
   *  Adds a set of arguments. Unlike {@link #setArguments(List)}, this method does not remove the existing arguments.
   *  The given list is appended to the existing list.
   * @param args the arguments, must not be {@code null}
   * @return the current {@link CLI} instance
   * 
   */
  addArguments(args: Argument[]) : CLI;

  /**
   *  Sets the list of arguments.
   * @param args the list of arguments, must not be {@code null}
   * @return the current {@link CLI} instance
   * 
   */
  setArguments(args: Argument[]) : CLI;

  /**
   *  Gets an {@link Option} based on its name (short name, long name or argument name).
   * @param name the name, must not be {@code null}
   * @return the {@link Option}, {@code null} if not found
   * 
   */
  getOption(name: string) : Option | null;

  /**
   *  Gets an {@link Argument} based on its name (argument name).
   * @param name the name of the argument, must not be {@code null}
   * @return the {@link Argument}, {@code null} if not found.
   * 
   */
  getArgument(name: string) : Argument | null;

  /**
   *  Gets an {@link Argument} based on its index.
   * @param index the index, must be positive or zero.
   * @return the {@link Argument}, {@code null} if not found.
   * 
   */
  getArgument(index: number) : Argument | null;

  /**
   *  Removes an option identified by its name. This method does nothing if the option cannot be found.
   * @param name the option name
   * @return the current {@link CLI} instance
   * 
   */
  removeOption(name: string) : CLI;

  /**
   *  Removes an argument identified by its index. This method does nothing if the argument cannot be found.
   * @param index the argument index
   * @return the current {@link CLI} instance
   * 
   */
  removeArgument(index: number) : CLI;

}


export class CommandLine {
  /**
   *  Creates a command line object from the {@link CLI}. This object is intended to be used by
   *  the parser to set the argument and option values.
   * @param cli the CLI definition
   * @return the command line object
   * 
   */
  static create(cli: CLI) : CommandLine;

  /**
   * 
   * @return the model of this command line object.
   * 
   */
  cli() : CLI;

  /**
   * 
   * @return the ordered list of arguments. Arguments are command line arguments not matching an option.
   * 
   */
  allArguments() : string[];

  /**
   *  Gets the value of an option with the matching name (can be the long name, short name or arg name).
   * @param name the name
   * @param <T>  the expected type
   * @return the value, {@code null} if not set
   * 
   */
  getOptionValue(name: string) : Object | null;

  /**
   *  Gets the value of an argument with the matching name (arg name).
   * @param name the name
   * @param <T>  the expected type
   * @return the value, {@code null} if not set
   * 
   */
  getArgumentValue(name: string) : Object | null;

  /**
   *  Gets the value of an argument with the given index.
   * @param index the index
   * @param <T>   the expected type
   * @return the value, {@code null} if not set
   * 
   */
  getArgumentValue(index: number) : Object | null;

  /**
   *  Gets the value of an option marked as a flag.
   *  <p/>
   *  Calling this method an a non-flag option throws an {@link IllegalStateException}.
   * @param name the option name
   * @return {@code true} if the flag has been set in the command line, {@code false} otherwise.
   * 
   */
  isFlagEnabled(name: string) : boolean;

  /**
   *  Checks whether or not the given option has been assigned in the command line.
   * @param option the option
   * @return {@code true} if the option has received a value, {@link false} otherwise.
   * 
   */
  isOptionAssigned(option: Option) : boolean;

  /**
   *  Gets the raw values of the given option. Raw values are simple "String", not converted to the option type.
   * @param option the option
   * @return the list of values, empty if none
   * @deprecated use {@link #getRawValuesForOption(Option)}
   * 
   */
  getRawValues(option: Option) : string[];

  /**
   *  Gets the raw values of the given option. Raw values are simple "String", not converted to the option type.
   * @param option the option
   * @return the list of values, empty if none
   * 
   */
  getRawValuesForOption(option: Option) : string[];

  /**
   *  Gets the raw values of the given argument. Raw values are simple "String", not converted to the argument type.
   * @param argument the argument
   * @return the list of values, empty if none
   * 
   */
  getRawValuesForArgument(argument: Argument) : string[];

  /**
   *  Gets the raw value of the given option. Raw values are the values as given in the user command line.
   * @param option the option
   * @return the value, {@code null} if none.
   * 
   */
  getRawValueForOption(option: Option) : string | null;

  /**
   *  Checks whether or not the given option accept more values.
   * @param option the option
   * @return {@link true} if the option accepts more values, {@link false} otherwise.
   * 
   */
  acceptMoreValues(option: Option) : boolean;

  /**
   *  Gets the raw value of the given argument. Raw values are the values as given in the user command line.
   * @param arg the argument
   * @return the value, {@code null} if none.
   * 
   */
  getRawValueForArgument(arg: Argument) : string | null;

  /**
   *  Checks whether or not the given argument has been assigned in the command line.
   * @param arg the argument
   * @return {@code true} if the argument has received a value, {@link false} otherwise.
   * 
   */
  isArgumentAssigned(arg: Argument) : boolean;

  /**
   *  Checks whether or not the given option has been seen in the user command line.
   * @param option the option
   * @return {@code true} if the user command line has used the option
   * 
   */
  isSeenInCommandLine(option: Option) : boolean;

  /**
   *  Checks whether or not the command line is valid, i.e. all constraints from arguments and options have been
   *  satisfied. This method is used when the parser validation is disabled.
   * @return {@code true} if the current {@link CommandLine} object is valid. {@link false} otherwise.
   * 
   */
  isValid() : boolean;

  /**
   *  Checks whether or not the user has passed a "help" option and is asking for help.
   * @return {@code true} if the user command line has enabled a "Help" option, {@link false} otherwise.
   * 
   */
  isAskingForHelp() : boolean;

}


export class CompositeFuture {
  /**
   *  Set the result. Any handler will be called, if there is one, and the future will be marked as completed.
   * @param result  the result
   * 
   */
  complete(result: CompositeFuture) : void;

  /**
   *  Set the failure. Any handler will be called, if there is one, and the future will be marked as completed.
   * @param result  the result
   * @return false when the future is already completed
   * 
   */
  tryComplete(result: CompositeFuture) : boolean;

  /**
   *  The result of the operation. This will be null if the operation failed.
   * @return the result or null if the operation failed.
   * 
   */
  result() : CompositeFuture;

  /**
   *  Compose this future with a provided {@code next} future.<p>
   * 
   *  When this (the one on which {@code compose} is called) future succeeds, the {@code handler} will be called with
   *  the completed value, this handler should complete the next future.<p>
   * 
   *  If the {@code handler} throws an exception, the returned future will be failed with this exception.<p>
   * 
   *  When this future fails, the failure will be propagated to the {@code next} future and the {@code handler}
   *  will not be called.
   * @param handler the handler
   * @param next the next future
   * @return the next future, used for chaining
   * 
   */
  compose(handler: (result: CompositeFuture) => void, next: Future) : Future;

  /**
   *  Compose this future with a {@code mapper} function.<p>
   * 
   *  When this future (the one on which {@code compose} is called) succeeds, the {@code mapper} will be called with
   *  the completed value and this mapper returns another future object. This returned future completion will complete
   *  the future returned by this method call.<p>
   * 
   *  If the {@code mapper} throws an exception, the returned future will be failed with this exception.<p>
   * 
   *  When this future fails, the failure will be propagated to the returned future and the {@code mapper}
   *  will not be called.
   * @param mapper the mapper function
   * @return the composed future
   * 
   */
  compose(mapper: (t: CompositeFuture) => Future) : Future;

  /**
   *  Apply a {@code mapper} function on this future.<p>
   * 
   *  When this future succeeds, the {@code mapper} will be called with the completed value and this mapper
   *  returns a value. This value will complete the future returned by this method call.<p>
   * 
   *  If the {@code mapper} throws an exception, the returned future will be failed with this exception.<p>
   * 
   *  When this future fails, the failure will be propagated to the returned future and the {@code mapper}
   *  will not be called.
   * @param mapper the mapper function
   * @return the mapped future
   * 
   */
  map(mapper: (t: CompositeFuture) => any) : Future;

  /**
   * 
   * @return an handler completing this future
   * 
   */
  completer() : (result: AsyncResult) => void;

  /**
   *  Handles a failure of this Future by returning the result of another Future.
   *  If the mapper fails, then the returned future will be failed with this failure.
   * @param mapper A function which takes the exception of a failure and returns a new future.
   * @return A recovered future
   * 
   */
  recover(mapper: (t: Error) => Future) : Future;

  /**
   *  Apply a {@code mapper} function on this future.<p>
   * 
   *  When this future fails, the {@code mapper} will be called with the completed value and this mapper
   *  returns a value. This value will complete the future returned by this method call.<p>
   * 
   *  If the {@code mapper} throws an exception, the returned future will be failed with this exception.<p>
   * 
   *  When this future succeeds, the result will be propagated to the returned future and the {@code mapper}
   *  will not be called.
   * @param mapper the mapper function
   * @return the mapped future
   * 
   */
  otherwise(mapper: (t: Error) => CompositeFuture) : Future;

  /**
   *  Map the failure of a future to a specific {@code value}.<p>
   * 
   *  When this future fails, this {@code value} will complete the future returned by this method call.<p>
   * 
   *  When this future succeeds, the result will be propagated to the returned future.
   * @param value the value that eventually completes the mapped future
   * @return the mapped future
   * 
   */
  otherwise(value: CompositeFuture) : Future;

  /**
   *  Map the failure of a future to {@code null}.<p>
   * 
   *  This is a convenience for {@code future.otherwise((T) null)}.<p>
   * 
   *  When this future fails, the {@code null} value will complete the future returned by this method call.<p>
   * 
   *  When this future succeeds, the result will be propagated to the returned future.
   * @return the mapped future
   * 
   */
  otherwiseEmpty() : Future;

  /**
   *  Return a composite future, succeeded when all futures are succeeded, failed when any future is failed.
   *  <p/>
   *  The returned future fails as soon as one of {@code f1} or {@code f2} fails.
   * @param f1 future
   * @param f2 future
   * @return the composite future
   * 
   */
  static all(f1: Future, f2: Future) : CompositeFuture;

  /**
   *  Like {@link #all(Future, Future)} but with 3 futures.
   * 
   */
  static all(f1: Future, f2: Future, f3: Future) : CompositeFuture;

  /**
   *  Like {@link #all(Future, Future)} but with 4 futures.
   * 
   */
  static all(f1: Future, f2: Future, f3: Future, f4: Future) : CompositeFuture;

  /**
   *  Like {@link #all(Future, Future)} but with 5 futures.
   * 
   */
  static all(f1: Future, f2: Future, f3: Future, f4: Future, f5: Future) : CompositeFuture;

  /**
   *  Like {@link #all(Future, Future)} but with 6 futures.
   * 
   */
  static all(f1: Future, f2: Future, f3: Future, f4: Future, f5: Future, f6: Future) : CompositeFuture;

  /**
   *  Like {@link #all(Future, Future)} but with a list of futures.<p>
   * 
   *  When the list is empty, the returned future will be already completed.
   * 
   */
  static all(futures: Future[]) : CompositeFuture;

  /**
   *  Return a composite future, succeeded when any futures is succeeded, failed when all futures are failed.
   *  <p/>
   *  The returned future succeeds as soon as one of {@code f1} or {@code f2} succeeds.
   * @param f1 future
   * @param f2 future
   * @return the composite future
   * 
   */
  static any(f1: Future, f2: Future) : CompositeFuture;

  /**
   *  Like {@link #any(Future, Future)} but with 3 futures.
   * 
   */
  static any(f1: Future, f2: Future, f3: Future) : CompositeFuture;

  /**
   *  Like {@link #any(Future, Future)} but with 4 futures.
   * 
   */
  static any(f1: Future, f2: Future, f3: Future, f4: Future) : CompositeFuture;

  /**
   *  Like {@link #any(Future, Future)} but with 5 futures.
   * 
   */
  static any(f1: Future, f2: Future, f3: Future, f4: Future, f5: Future) : CompositeFuture;

  /**
   *  Like {@link #any(Future, Future)} but with 6 futures.
   * 
   */
  static any(f1: Future, f2: Future, f3: Future, f4: Future, f5: Future, f6: Future) : CompositeFuture;

  /**
   *  Like {@link #any(Future, Future)} but with a list of futures.<p>
   * 
   *  When the list is empty, the returned future will be already completed.
   * 
   */
  static any(futures: Future[]) : CompositeFuture;

  /**
   *  Return a composite future, succeeded when all futures are succeeded, failed when any future is failed.
   *  <p/>
   *  It always wait until all its futures are completed and will not fail as soon as one of {@code f1} or {@code f2} fails.
   * @param f1 future
   * @param f2 future
   * @return the composite future
   * 
   */
  static join(f1: Future, f2: Future) : CompositeFuture;

  /**
   *  Like {@link #join(Future, Future)} but with 3 futures.
   * 
   */
  static join(f1: Future, f2: Future, f3: Future) : CompositeFuture;

  /**
   *  Like {@link #join(Future, Future)} but with 4 futures.
   * 
   */
  static join(f1: Future, f2: Future, f3: Future, f4: Future) : CompositeFuture;

  /**
   *  Like {@link #join(Future, Future)} but with 5 futures.
   * 
   */
  static join(f1: Future, f2: Future, f3: Future, f4: Future, f5: Future) : CompositeFuture;

  /**
   *  Like {@link #join(Future, Future)} but with 6 futures.
   * 
   */
  static join(f1: Future, f2: Future, f3: Future, f4: Future, f5: Future, f6: Future) : CompositeFuture;

  /**
   *  Like {@link #join(Future, Future)} but with a list of futures.<p>
   * 
   *  When the list is empty, the returned future will be already completed.
   * 
   */
  static join(futures: Future[]) : CompositeFuture;

  setHandler(handler: (result: AsyncResult<CompositeFuture>) => void) : CompositeFuture;

  /**
   *  Set this instance as result. Any handler will be called, if there is one, and the future will be marked as completed.
   * 
   */
  complete() : void;

  /**
   *  Try to set this instance as result. When it happens, any handler will be called, if there is one, and the future will be marked as completed.
   * @return false when the future is already completed
   * 
   */
  tryComplete() : boolean;

  /**
   *  Returns a cause of a wrapped future
   * @param index the wrapped future index
   * 
   */
  cause(index: number) : Error;

  /**
   *  Returns true if a wrapped future is succeeded
   * @param index the wrapped future index
   * 
   */
  succeeded(index: number) : boolean;

  /**
   *  Returns true if a wrapped future is failed
   * @param index the wrapped future index
   * 
   */
  failed(index: number) : boolean;

  /**
   *  Returns true if a wrapped future is completed
   * @param index the wrapped future index
   * 
   */
  isComplete(index: number) : boolean;

  /**
   *  Returns the result of a wrapped future
   * @param index the wrapped future index
   * 
   */
  resultAt(index: number) : Object;

  /**
   * 
   * @return the number of wrapped future
   * 
   */
  size() : number;

}


export class Context {
  /**
   *  Is the current thread a worker thread?
   *  <p>
   *  NOTE! This is not always the same as calling {@link Context#isWorkerContext}. If you are running blocking code
   *  from an event loop context, then this will return true but {@link Context#isWorkerContext} will return false.
   * @return true if current thread is a worker thread, false otherwise
   * 
   */
  static isOnWorkerThread() : boolean;

  /**
   *  Is the current thread an event thread?
   *  <p>
   *  NOTE! This is not always the same as calling {@link Context#isEventLoopContext}. If you are running blocking code
   *  from an event loop context, then this will return false but {@link Context#isEventLoopContext} will return true.
   * @return true if current thread is a worker thread, false otherwise
   * 
   */
  static isOnEventLoopThread() : boolean;

  /**
   *  Is the current thread a Vert.x thread? That's either a worker thread or an event loop thread
   * @return true if current thread is a Vert.x thread, false otherwise
   * 
   */
  static isOnVertxThread() : boolean;

  /**
   *  Run the specified action asynchronously on the same context, some time after the current execution has completed.
   * @param action  the action to run
   * 
   */
  runOnContext(action: (result: void) => void) : void;

  /**
   *  Safely execute some blocking code.
   *  <p>
   *  Executes the blocking code in the handler {@code blockingCodeHandler} using a thread from the worker pool.
   *  <p>
   *  When the code is complete the handler {@code resultHandler} will be called with the result on the original context
   *  (e.g. on the original event loop of the caller).
   *  <p>
   *  A {@code Future} instance is passed into {@code blockingCodeHandler}. When the blocking code successfully completes,
   *  the handler should call the {@link Future#complete} or {@link Future#complete(Object)} method, or the {@link Future#fail}
   *  method if it failed.
   * @param blockingCodeHandler  handler representing the blocking code to run
   * @param resultHandler  handler that will be called when the blocking code is complete
   * @param ordered  if true then if executeBlocking is called several times on the same context, the executions
   *                  for that context will be executed serially, not in parallel. if false then they will be no ordering
   *                  guarantees
   * @param <T> the type of the result
   * 
   */
  executeBlocking(blockingCodeHandler: (result: Future) => void, ordered: boolean, resultHandler: (result: AsyncResult<any>) => void) : void;

  /**
   *  Invoke {@link #executeBlocking(Handler, boolean, Handler)} with order = true.
   * @param blockingCodeHandler  handler representing the blocking code to run
   * @param resultHandler  handler that will be called when the blocking code is complete
   * @param <T> the type of the result
   * 
   */
  executeBlocking(blockingCodeHandler: (result: Future) => void, resultHandler: (result: AsyncResult<any>) => void) : void;

  /**
   *  If the context is associated with a Verticle deployment, this returns the deployment ID of that deployment.
   * @return the deployment ID of the deployment or null if not a Verticle deployment
   * 
   */
  deploymentID() : string;

  /**
   *  If the context is associated with a Verticle deployment, this returns the configuration that was specified when
   *  the verticle was deployed.
   * @return the configuration of the deployment or null if not a Verticle deployment
   * 
   */
  config() : object | null;

  /**
   *  The process args
   * 
   */
  processArgs() : string[];

  /**
   *  Is the current context an event loop context?
   *  <p>
   *  NOTE! when running blocking code using {@link io.vertx.core.Vertx#executeBlocking(Handler, Handler)} from a
   *  standard (not worker) verticle, the context will still an event loop context and this {@link this#isEventLoopContext()}
   *  will return true.
   * @return true if  false otherwise
   * 
   */
  isEventLoopContext() : boolean;

  /**
   *  Is the current context a worker context?
   *  <p>
   *  NOTE! when running blocking code using {@link io.vertx.core.Vertx#executeBlocking(Handler, Handler)} from a
   *  standard (not worker) verticle, the context will still an event loop context and this {@link this#isWorkerContext()}
   *  will return false.
   * @return true if the current context is a worker context, false otherwise
   * 
   */
  isWorkerContext() : boolean;

  /**
   *  Is the current context a multi-threaded worker context?
   * @return true if the current context is a multi-threaded worker context, false otherwise
   * 
   */
  isMultiThreadedWorkerContext() : boolean;

  /**
   *  Get some data from the context.
   * @param key  the key of the data
   * @param <T>  the type of the data
   * @return the data
   * 
   */
  get(key: string) : Object;

  /**
   *  Put some data in the context.
   *  <p>
   *  This can be used to share data between different handlers that share a context
   * @param key  the key of the data
   * @param value  the data
   * 
   */
  put(key: string, value: any) : void;

  /**
   *  Remove some data from the context.
   * @param key  the key to remove
   * @return true if removed successfully, false otherwise
   * 
   */
  remove(key: string) : boolean;

  /**
   * 
   * @return The Vertx instance that created the context
   * 
   */
  owner() : Vertx;

  /**
   * 
   * @return  the number of instances of the verticle that were deployed in the deployment (if any) related
   *  to this context
   * 
   */
  getInstanceCount() : number;

  /**
   *  Set an exception handler called when the context runs an action throwing an uncaught throwable.<p/>
   * 
   *  When this handler is called, {@link Vertx#currentContext()} will return this context.
   * @param handler the exception handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(handler: (result: Error) => void | null | undefined) : Context;

}


export class Counter {
  /**
   *  Get the current value of the counter
   * @param resultHandler handler which will be passed the value
   * 
   */
  get(resultHandler: (result: AsyncResult<number>) => void) : void;

  /**
   *  Increment the counter atomically and return the new count
   * @param resultHandler handler which will be passed the value
   * 
   */
  incrementAndGet(resultHandler: (result: AsyncResult<number>) => void) : void;

  /**
   *  Increment the counter atomically and return the value before the increment.
   * @param resultHandler handler which will be passed the value
   * 
   */
  getAndIncrement(resultHandler: (result: AsyncResult<number>) => void) : void;

  /**
   *  Decrement the counter atomically and return the new count
   * @param resultHandler handler which will be passed the value
   * 
   */
  decrementAndGet(resultHandler: (result: AsyncResult<number>) => void) : void;

  /**
   *  Add the value to the counter atomically and return the new count
   * @param value  the value to add
   * @param resultHandler handler which will be passed the value
   * 
   */
  addAndGet(value: number, resultHandler: (result: AsyncResult<number>) => void) : void;

  /**
   *  Add the value to the counter atomically and return the value before the add
   * @param value  the value to add
   * @param resultHandler handler which will be passed the value
   * 
   */
  getAndAdd(value: number, resultHandler: (result: AsyncResult<number>) => void) : void;

  /**
   *  Set the counter to the specified value only if the current value is the expectec value. This happens
   *  atomically.
   * @param expected  the expected value
   * @param value  the new value
   * @param resultHandler  the handler will be passed true on success
   * 
   */
  compareAndSet(expected: number, value: number, resultHandler: (result: AsyncResult<boolean>) => void) : void;

}


export class DatagramPacket {
  /**
   *  Returns the {@link io.vertx.core.net.SocketAddress} of the sender that sent
   *  this {@link io.vertx.core.datagram.DatagramPacket}.
   * @return the address of the sender
   * 
   */
  sender() : SocketAddress;

  /**
   *  Returns the data of the {@link io.vertx.core.datagram.DatagramPacket}
   * @return the data
   * 
   */
  data() : Buffer;

}


export class DatagramSocket {
  /**
   *  Whether the metrics are enabled for this measured object
   * @return true if the metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

  /**
   *  Write the given {@link io.vertx.core.buffer.Buffer} to the {@link io.vertx.core.net.SocketAddress}.
   *  The {@link io.vertx.core.Handler} will be notified once the write completes.
   * @param packet  the {@link io.vertx.core.buffer.Buffer} to write
   * @param port  the host port of the remote peer
   * @param host  the host address of the remote peer
   * @param handler  the {@link io.vertx.core.Handler} to notify once the write completes.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  send(packet: Buffer, port: number, host: string, handler: (result: AsyncResult<DatagramSocket>) => void) : DatagramSocket;

  /**
   *  Returns a {@code WriteStream<Buffer>} able to send {@link Buffer} to the
   *  {@link io.vertx.core.net.SocketAddress}.
   * @param port the port of the remote peer
   * @param host the host address of the remote peer
   * @return the write stream for sending packets
   * 
   */
  sender(port: number, host: string) : WriteStream;

  /**
   *  Write the given {@link String} to the {@link io.vertx.core.net.SocketAddress} using UTF8 encoding.
   *  The {@link Handler} will be notified once the write completes.
   * @param str   the {@link String} to write
   * @param port  the host port of the remote peer
   * @param host  the host address of the remote peer
   * @param handler  the {@link io.vertx.core.Handler} to notify once the write completes.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  send(str: string, port: number, host: string, handler: (result: AsyncResult<DatagramSocket>) => void) : DatagramSocket;

  /**
   *  Write the given {@link String} to the {@link io.vertx.core.net.SocketAddress} using the given encoding.
   *  The {@link Handler} will be notified once the write completes.
   * @param str  the {@link String} to write
   * @param enc  the charset used for encoding
   * @param port  the host port of the remote peer
   * @param host  the host address of the remote peer
   * @param handler  the {@link io.vertx.core.Handler} to notify once the write completes.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  send(str: string, enc: string, port: number, host: string, handler: (result: AsyncResult<DatagramSocket>) => void) : DatagramSocket;

  /**
   *  Closes the {@link io.vertx.core.datagram.DatagramSocket} implementation asynchronous
   *  and notifies the handler once done.
   * @param handler  the handler to notify once complete
   * 
   */
  close(handler: (result: AsyncResult<void>) => void) : void;

  /**
   *  Closes the {@link io.vertx.core.datagram.DatagramSocket}. The close itself is asynchronous.
   * 
   */
  close() : void;

  /**
   *  Return the {@link io.vertx.core.net.SocketAddress} to which
   *  this {@link io.vertx.core.datagram.DatagramSocket} is bound.
   * @return the socket address
   * 
   */
  localAddress() : SocketAddress;

  /**
   *  Joins a multicast group and listens for packets send to it.
   *  The {@link Handler} is notified once the operation completes.
   * @param multicastAddress  the address of the multicast group to join
   * @param  handler  then handler to notify once the operation completes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listenMulticastGroup(multicastAddress: string, handler: (result: AsyncResult<DatagramSocket>) => void) : DatagramSocket;

  /**
   *  Joins a multicast group and listens for packets send to it on the given network interface.
   *  The {@link Handler} is notified once the operation completes.
   * @param  multicastAddress  the address of the multicast group to join
   * @param  networkInterface  the network interface on which to listen for packets.
   * @param  source  the address of the source for which we will listen for multicast packets
   * @param  handler  then handler to notify once the operation completes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listenMulticastGroup(multicastAddress: string, networkInterface: string, source: string | null | undefined, handler: (result: AsyncResult<DatagramSocket>) => void) : DatagramSocket;

  /**
   *  Leaves a multicast group and stops listening for packets send to it.
   *  The {@link Handler} is notified once the operation completes.
   * @param multicastAddress  the address of the multicast group to leave
   * @param handler  then handler to notify once the operation completes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  unlistenMulticastGroup(multicastAddress: string, handler: (result: AsyncResult<DatagramSocket>) => void) : DatagramSocket;

  /**
   *  Leaves a multicast group and stops listening for packets send to it on the given network interface.
   *  The {@link Handler} is notified once the operation completes.
   * @param  multicastAddress  the address of the multicast group to join
   * @param  networkInterface  the network interface on which to listen for packets.
   * @param  source  the address of the source for which we will listen for multicast packets
   * @param  handler the handler to notify once the operation completes
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  unlistenMulticastGroup(multicastAddress: string, networkInterface: string, source: string | null | undefined, handler: (result: AsyncResult<DatagramSocket>) => void) : DatagramSocket;

  /**
   *  Block the given address for the given multicast address and notifies the {@link Handler} once
   *  the operation completes.
   * @param multicastAddress  the address for which you want to block the source address
   * @param sourceToBlock  the source address which should be blocked. You will not receive an multicast packets
   *                        for it anymore.
   * @param handler  the handler to notify once the operation completes
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  blockMulticastGroup(multicastAddress: string, sourceToBlock: string, handler: (result: AsyncResult<DatagramSocket>) => void) : DatagramSocket;

  /**
   *  Block the given address for the given multicast address on the given network interface and notifies
   *  the {@link Handler} once the operation completes.
   * @param  multicastAddress  the address for which you want to block the source address
   * @param  networkInterface  the network interface on which the blocking should occur.
   * @param  sourceToBlock  the source address which should be blocked. You will not receive an multicast packets
   *                         for it anymore.
   * @param  handler  the handler to notify once the operation completes
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  blockMulticastGroup(multicastAddress: string, networkInterface: string, sourceToBlock: string, handler: (result: AsyncResult<DatagramSocket>) => void) : DatagramSocket;

  /**
   *  Start listening on the given port and host. The handler will be called when the socket is listening.
   * @param port  the port to listen on
   * @param host  the host to listen on
   * @param handler  the handler will be called when listening
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  listen(port: number, host: string, handler: (result: AsyncResult<DatagramSocket>) => void) : DatagramSocket;

  pause() : DatagramSocket;

  resume() : DatagramSocket;

  endHandler(endHandler: (result: void) => void | null | undefined) : DatagramSocket;

  handler(handler: (result: DatagramPacket) => void | null | undefined) : DatagramSocket;

  exceptionHandler(handler: (result: Error) => void | null | undefined) : DatagramSocket;

}


export class DnsClient {
  /**
   *  Try to lookup the A (ipv4) or AAAA (ipv6) record for the given name. The first found will be used.
   * @param name  the name to resolve
   * @param handler  the {@link io.vertx.core.Handler} to notify with the {@link io.vertx.core.AsyncResult}.
   *                  The handler will get notified with the resolved address if a record was found. If non was found it
   *                  will get notifed with {@code null}. If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  lookup(name: string, handler: (result: AsyncResult<string>) => void) : DnsClient;

  /**
   *  Try to lookup the A (ipv4) record for the given name. The first found will be used.
   * @param name  the name to resolve
   * @param handler  the {@link Handler} to notify with the {@link io.vertx.core.AsyncResult}.
   *                  The handler will get notified with the resolved {@link java.net.Inet4Address} if a record was found.
   *                  If non was found it will get notifed with {@code null}. If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  lookup4(name: string, handler: (result: AsyncResult<string>) => void) : DnsClient;

  /**
   *  Try to lookup the AAAA (ipv6) record for the given name. The first found will be used.
   * @param name  the name to resolve
   * @param handler  the {@link Handler} to notify with the {@link AsyncResult}. The handler will get
   *                  notified with the resolved {@link java.net.Inet6Address} if a record was found. If non was found
   *                  it will get notifed with {@code null}. If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  lookup6(name: string, handler: (result: AsyncResult<string>) => void) : DnsClient;

  /**
   *  Try to resolve all A (ipv4) records for the given name.
   * @param name  the name to resolve
   * @param handler  the {@link io.vertx.core.Handler} to notify with the {@link io.vertx.core.AsyncResult}.
   *                  The handler will get notified with a {@link java.util.List} that contains all the resolved
   *                  {@link java.net.Inet4Address}es. If none was found an empty {@link java.util.List} will be used.
   *                  If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  resolveA(name: string, handler: (result: AsyncResult<string[]>) => void) : DnsClient;

  /**
   *  Try to resolve all AAAA (ipv6) records for the given name.
   * @param name  the name to resolve
   * @param handler the {@link io.vertx.core.Handler} to notify with the {@link io.vertx.core.AsyncResult}.
   *                 The handler will get notified with a {@link java.util.List} that contains all the resolved
   *                 {@link java.net.Inet6Address}es. If none was found an empty {@link java.util.List} will be used.
   *                 If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  resolveAAAA(name: string, handler: (result: AsyncResult<string[]>) => void) : DnsClient;

  /**
   *  Try to resolve the CNAME record for the given name.
   * @param name  the name to resolve the CNAME for
   * @param handler  the {@link Handler} to notify with the {@link AsyncResult}. The handler will get
   *                  notified with the resolved {@link String} if a record was found. If none was found it will
   *                  get notified with {@code null}. If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently.
   * 
   */
  resolveCNAME(name: string, handler: (result: AsyncResult<string[]>) => void) : DnsClient;

  /**
   *  Try to resolve the MX records for the given name.
   * @param name  the name for which the MX records should be resolved
   * @param handler  the {@link io.vertx.core.Handler} to notify with the {@link io.vertx.core.AsyncResult}.
   *                  The handler will get notified with a List that contains all resolved {@link MxRecord}s, sorted by
   *                  their {@link MxRecord#priority()}. If non was found it will get notified with an empty
   *                  {@link java.util.List}.  If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently.
   * 
   */
  resolveMX(name: string, handler: (result: AsyncResult<MxRecord[]>) => void) : DnsClient;

  /**
   *  Try to resolve the TXT records for the given name.
   * @param name  the name for which the TXT records should be resolved
   * @param handler  the {@link Handler} to notify with the {@link AsyncResult}. The handler will get
   *                  notified with a List that contains all resolved {@link String}s. If none was found it will
   *                  get notified with an empty {@link java.util.List}. If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently.
   * 
   */
  resolveTXT(name: string, handler: (result: AsyncResult<string[]>) => void) : DnsClient;

  /**
   *  Try to resolve the PTR record for the given name.
   * @param name  the name to resolve the PTR for
   * @param handler  the {@link Handler} to notify with the {@link AsyncResult}. The handler will get
   *                  notified with the resolved {@link String} if a record was found. If none was found it will
   *                  get notified with {@code null}. If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently.
   * 
   */
  resolvePTR(name: string, handler: (result: AsyncResult<string>) => void) : DnsClient;

  /**
   *  Try to resolve the NS records for the given name.
   * @param name  the name for which the NS records should be resolved
   * @param handler  the {@link Handler} to notify with the {@link AsyncResult}. The handler will get
   *                  notified with a List that contains all resolved {@link String}s. If none was found it will
   *                  get notified with an empty {@link java.util.List}.  If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently.
   * 
   */
  resolveNS(name: string, handler: (result: AsyncResult<string[]>) => void) : DnsClient;

  /**
   *  Try to resolve the SRV records for the given name.
   * @param name  the name for which the SRV records should be resolved
   * @param handler  the {@link Handler} to notify with the {@link AsyncResult}. The handler will get
   *                  notified with a List that contains all resolved {@link SrvRecord}s. If none was found it will
   *                  get notified with an empty {@link java.util.List}. If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently.
   * 
   */
  resolveSRV(name: string, handler: (result: AsyncResult<SrvRecord[]>) => void) : DnsClient;

  /**
   *  Try to do a reverse lookup of an IP address. This is basically the same as doing trying to resolve a PTR record
   *  but allows you to just pass in the IP address and not a valid ptr query string.
   * @param ipaddress  the IP address to resolve the PTR for
   * @param handler  the {@link Handler} to notify with the {@link AsyncResult}. The handler will get
   *                  notified with the resolved {@link String} if a record was found. If none was found it will
   *                  get notified with {@code null}. If an error accours it will get failed.
   * @return a reference to this, so the API can be used fluently.
   * 
   */
  reverseLookup(ipaddress: string, handler: (result: AsyncResult<string>) => void) : DnsClient;

}

import { DeliveryOptions } from './options';

export class EventBus {
  /**
   *  Whether the metrics are enabled for this measured object
   * @return true if the metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

  /**
   *  Sends a message.
   *  <p>
   *  The message will be delivered to at most one of the handlers registered to the address.
   * @param address  the address to send it to
   * @param message  the message, may be {@code null}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  send(address: string, message: any) : EventBus;

  /**
   *  Like {@link #send(String, Object)} but specifying a {@code replyHandler} that will be called if the recipient
   *  subsequently replies to the message.
   * @param address  the address to send it to
   * @param message  the message, may be {@code null}
   * @param replyHandler  reply handler will be called when any reply from the recipient is received, may be {@code null}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  send(address: string, message: any, replyHandler: (result: AsyncResult<Message>) => void) : EventBus;

  /**
   *  Like {@link #send(String, Object)} but specifying {@code options} that can be used to configure the delivery.
   * @param address  the address to send it to
   * @param message  the message, may be {@code null}
   * @param options  delivery options
   * @return a reference to this, so the API can be used fluently
   * 
   */
  send(address: string, message: any, options: DeliveryOptions) : EventBus;

  /**
   *  Like {@link #send(String, Object, DeliveryOptions)} but specifying a {@code replyHandler} that will be called if the recipient
   *  subsequently replies to the message.
   * @param address  the address to send it to
   * @param message  the message, may be {@code null}
   * @param options  delivery options
   * @param replyHandler  reply handler will be called when any reply from the recipient is received, may be {@code null}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  send(address: string, message: any, options: DeliveryOptions, replyHandler: (result: AsyncResult<Message>) => void) : EventBus;

  /**
   *  Publish a message.<p>
   *  The message will be delivered to all handlers registered to the address.
   * @param address  the address to publish it to
   * @param message  the message, may be {@code null}
   * @return a reference to this, so the API can be used fluently
   * 
   * 
   */
  publish(address: string, message: any) : EventBus;

  /**
   *  Like {@link #publish(String, Object)} but specifying {@code options} that can be used to configure the delivery.
   * @param address  the address to publish it to
   * @param message  the message, may be {@code null}
   * @param options  the delivery options
   * @return a reference to this, so the API can be used fluently
   * 
   */
  publish(address: string, message: any, options: DeliveryOptions) : EventBus;

  /**
   *  Create a message consumer against the specified address.
   *  <p>
   *  The returned consumer is not yet registered
   *  at the address, registration will be effective when {@link MessageConsumer#handler(io.vertx.core.Handler)}
   *  is called.
   * @param address  the address that it will register it at
   * @return the event bus message consumer
   * 
   */
  consumer(address: string) : MessageConsumer;

  /**
   *  Create a consumer and register it against the specified address.
   * @param address  the address that will register it at
   * @param handler  the handler that will process the received messages
   * @return the event bus message consumer
   * 
   */
  consumer(address: string, handler: (result: Message) => void) : MessageConsumer;

  /**
   *  Like {@link #consumer(String)} but the address won't be propagated across the cluster.
   * @param address  the address to register it at
   * @return the event bus message consumer
   * 
   */
  localConsumer(address: string) : MessageConsumer;

  /**
   *  Like {@link #consumer(String, Handler)} but the address won't be propagated across the cluster.
   * @param address  the address that will register it at
   * @param handler  the handler that will process the received messages
   * @return the event bus message consumer
   * 
   */
  localConsumer(address: string, handler: (result: Message) => void) : MessageConsumer;

  /**
   *  Create a message sender against the specified address.
   *  <p>
   *  The returned sender will invoke the {@link #send(String, Object)}
   *  method when the stream {@link io.vertx.core.streams.WriteStream#write(Object)} method is called with the sender
   *  address and the provided data.
   * @param address  the address to send it to
   * @return The sender
   * 
   */
  sender(address: string) : MessageProducer;

  /**
   *  Like {@link #sender(String)} but specifying delivery options that will be used for configuring the delivery of
   *  the message.
   * @param address  the address to send it to
   * @param options  the delivery options
   * @return The sender
   * 
   */
  sender(address: string, options: DeliveryOptions) : MessageProducer;

  /**
   *  Create a message publisher against the specified address.
   *  <p>
   *  The returned publisher will invoke the {@link #publish(String, Object)}
   *  method when the stream {@link io.vertx.core.streams.WriteStream#write(Object)} method is called with the publisher
   *  address and the provided data.
   * @param address The address to publish it to
   * @return The publisher
   * 
   */
  publisher(address: string) : MessageProducer;

  /**
   *  Like {@link #publisher(String)} but specifying delivery options that will be used for configuring the delivery of
   *  the message.
   * @param address  the address to publish it to
   * @param options  the delivery options
   * @return The publisher
   * 
   */
  publisher(address: string, options: DeliveryOptions) : MessageProducer;

  /**
   *  Add an interceptor that will be called whenever a message is sent from Vert.x
   * @param interceptor  the interceptor
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addInterceptor(interceptor: (result: SendContext) => void) : EventBus;

  /**
   *  Remove an interceptor
   * @param interceptor  the interceptor
   * @return a reference to this, so the API can be used fluently
   * 
   */
  removeInterceptor(interceptor: (result: SendContext) => void) : EventBus;

}


export class FileProps {
  /**
   *  The date the file was created
   * 
   */
  creationTime() : number;

  /**
   *  The date the file was last accessed
   * 
   */
  lastAccessTime() : number;

  /**
   *  The date the file was last modified
   * 
   */
  lastModifiedTime() : number;

  /**
   *  Is the file a directory?
   * 
   */
  isDirectory() : boolean;

  /**
   *  Is the file some other type? (I.e. not a directory, regular file or symbolic link)
   * 
   */
  isOther() : boolean;

  /**
   *  Is the file a regular file?
   * 
   */
  isRegularFile() : boolean;

  /**
   *  Is the file a symbolic link?
   * 
   */
  isSymbolicLink() : boolean;

  /**
   *  The size of the file, in bytes
   * 
   */
  size() : number;

}

import { OpenOptions } from './options';
import { CopyOptions } from './options';

export class FileSystem {
  /**
   *  Copy a file from the path {@code from} to path {@code to}, asynchronously.
   *  <p>
   *  The copy will fail if the destination already exists.
   * @param from  the path to copy from
   * @param to  the path to copy to
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  copy(from: string, to: string, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Copy a file from the path {@code from} to path {@code to}, asynchronously.
   * @param from    the path to copy from
   * @param to      the path to copy to
   * @param options options describing how the file should be copied
   * @param handler the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  copy(from: string, to: string, options: CopyOptions, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #copy(String, String, Handler)}
   * 
   */
  copyBlocking(from: string, to: string) : FileSystem;

  /**
   *  Copy a file from the path {@code from} to path {@code to}, asynchronously.
   *  <p>
   *  If {@code recursive} is {@code true} and {@code from} represents a directory, then the directory and its contents
   *  will be copied recursively to the destination {@code to}.
   *  <p>
   *  The copy will fail if the destination if the destination already exists.
   * @param from  the path to copy from
   * @param to  the path to copy to
   * @param recursive
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  copyRecursive(from: string, to: string, recursive: boolean, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #copyRecursive(String, String, boolean, Handler)}
   * 
   */
  copyRecursiveBlocking(from: string, to: string, recursive: boolean) : FileSystem;

  /**
   *  Move a file from the path {@code from} to path {@code to}, asynchronously.
   *  <p>
   *  The move will fail if the destination already exists.
   * @param from  the path to copy from
   * @param to  the path to copy to
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  move(from: string, to: string, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Move a file from the path {@code from} to path {@code to}, asynchronously.
   * @param from    the path to copy from
   * @param to      the path to copy to
   * @param options options describing how the file should be copied
   * @param handler the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  move(from: string, to: string, options: CopyOptions, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #move(String, String, Handler)}
   * 
   */
  moveBlocking(from: string, to: string) : FileSystem;

  /**
   *  Truncate the file represented by {@code path} to length {@code len} in bytes, asynchronously.
   *  <p>
   *  The operation will fail if the file does not exist or {@code len} is less than {@code zero}.
   * @param path  the path to the file
   * @param len  the length to truncate it to
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  truncate(path: string, len: number, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #truncate(String, long, Handler)}
   * 
   */
  truncateBlocking(path: string, len: number) : FileSystem;

  /**
   *  Change the permissions on the file represented by {@code path} to {@code perms}, asynchronously.
   *  <p>
   *  The permission String takes the form rwxr-x--- as
   *  specified <a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>.
   * @param path  the path to the file
   * @param perms  the permissions string
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  chmod(path: string, perms: string, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #chmod(String, String, Handler) }
   * 
   */
  chmodBlocking(path: string, perms: string) : FileSystem;

  /**
   *  Change the permissions on the file represented by {@code path} to {@code perms}, asynchronously.<p>
   *  The permission String takes the form rwxr-x--- as
   *  specified in {<a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>}.
   *  <p>
   *  If the file is directory then all contents will also have their permissions changed recursively. Any directory permissions will
   *  be set to {@code dirPerms}, whilst any normal file permissions will be set to {@code perms}.
   * @param path  the path to the file
   * @param perms  the permissions string
   * @param dirPerms  the directory permissions
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  chmodRecursive(path: string, perms: string, dirPerms: string, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #chmodRecursive(String, String, String, Handler)}
   * 
   */
  chmodRecursiveBlocking(path: string, perms: string, dirPerms: string) : FileSystem;

  /**
   *  Change the ownership on the file represented by {@code path} to {@code user} and {code group}, asynchronously.
   * @param path  the path to the file
   * @param user  the user name, {@code null} will not change the user name
   * @param group  the user group, {@code null} will not change the user group name
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  chown(path: string, user: string | null | undefined, group: string | null | undefined, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #chown(String, String, String, Handler)}
   * 
   * 
   */
  chownBlocking(path: string, user: string | null | undefined, group: string | null | undefined) : FileSystem;

  /**
   *  Obtain properties for the file represented by {@code path}, asynchronously.
   *  <p>
   *  If the file is a link, the link will be followed.
   * @param path  the path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  props(path: string, handler: (result: AsyncResult<FileProps>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #props(String, Handler)}
   * 
   */
  propsBlocking(path: string) : FileProps;

  /**
   *  Obtain properties for the link represented by {@code path}, asynchronously.
   *  <p>
   *  The link will not be followed.
   * @param path  the path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  lprops(path: string, handler: (result: AsyncResult<FileProps>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #lprops(String, Handler)}
   * 
   */
  lpropsBlocking(path: string) : FileProps;

  /**
   *  Create a hard link on the file system from {@code link} to {@code existing}, asynchronously.
   * @param link  the link
   * @param existing  the link destination
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  link(link: string, existing: string, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #link(String, String, Handler)}
   * 
   */
  linkBlocking(link: string, existing: string) : FileSystem;

  /**
   *  Create a symbolic link on the file system from {@code link} to {@code existing}, asynchronously.
   * @param link  the link
   * @param existing  the link destination
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  symlink(link: string, existing: string, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #link(String, String, Handler)}
   * 
   */
  symlinkBlocking(link: string, existing: string) : FileSystem;

  /**
   *  Unlinks the link on the file system represented by the path {@code link}, asynchronously.
   * @param link  the link
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  unlink(link: string, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #unlink(String, Handler)}
   * 
   */
  unlinkBlocking(link: string) : FileSystem;

  /**
   *  Returns the path representing the file that the symbolic link specified by {@code link} points to, asynchronously.
   * @param link  the link
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  readSymlink(link: string, handler: (result: AsyncResult<string>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #readSymlink(String, Handler)}
   * 
   */
  readSymlinkBlocking(link: string) : string;

  /**
   *  Deletes the file represented by the specified {@code path}, asynchronously.
   * @param path  path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  delete(path: string, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #delete(String, Handler)}
   * 
   */
  deleteBlocking(path: string) : FileSystem;

  /**
   *  Deletes the file represented by the specified {@code path}, asynchronously.
   *  <p>
   *  If the path represents a directory and {@code recursive = true} then the directory and its contents will be
   *  deleted recursively.
   * @param path  path to the file
   * @param recursive  delete recursively?
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  deleteRecursive(path: string, recursive: boolean, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #deleteRecursive(String, boolean, Handler)}
   * 
   */
  deleteRecursiveBlocking(path: string, recursive: boolean) : FileSystem;

  /**
   *  Create the directory represented by {@code path}, asynchronously.
   *  <p>
   *  The operation will fail if the directory already exists.
   * @param path  path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  mkdir(path: string, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #mkdir(String, Handler)}
   * 
   */
  mkdirBlocking(path: string) : FileSystem;

  /**
   *  Create the directory represented by {@code path}, asynchronously.
   *  <p>
   *  The new directory will be created with permissions as specified by {@code perms}.
   *  <p>
   *  The permission String takes the form rwxr-x--- as specified
   *  in <a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>.
   *  <p>
   *  The operation will fail if the directory already exists.
   * @param path  path to the file
   * @param perms  the permissions string
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  mkdir(path: string, perms: string, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #mkdir(String, String, Handler)}
   * 
   */
  mkdirBlocking(path: string, perms: string) : FileSystem;

  /**
   *  Create the directory represented by {@code path} and any non existent parents, asynchronously.
   *  <p>
   *  The operation will fail if the directory already exists.
   * @param path  path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  mkdirs(path: string, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #mkdirs(String, Handler)}
   * 
   */
  mkdirsBlocking(path: string) : FileSystem;

  /**
   *  Create the directory represented by {@code path} and any non existent parents, asynchronously.
   *  <p>
   *  The new directory will be created with permissions as specified by {@code perms}.
   *  <p>
   *  The permission String takes the form rwxr-x--- as specified
   *  in <a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>.
   *  <p>
   *  The operation will fail if the directory already exists.<p>
   * @param path  path to the file
   * @param perms  the permissions string
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  mkdirs(path: string, perms: string, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #mkdirs(String, String, Handler)}
   * 
   */
  mkdirsBlocking(path: string, perms: string) : FileSystem;

  /**
   *  Read the contents of the directory specified by {@code path}, asynchronously.
   *  <p>
   *  The result is an array of String representing the paths of the files inside the directory.
   * @param path  path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  readDir(path: string, handler: (result: AsyncResult<string[]>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #readDir(String, Handler)}
   * 
   */
  readDirBlocking(path: string) : string[];

  /**
   *  Read the contents of the directory specified by {@code path}, asynchronously.
   *  <p>
   *  The parameter {@code filter} is a regular expression. If {@code filter} is specified then only the paths that
   *  match  @{filter}will be returned.
   *  <p>
   *  The result is an array of String representing the paths of the files inside the directory.
   * @param path  path to the directory
   * @param filter  the filter expression
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  readDir(path: string, filter: string, handler: (result: AsyncResult<string[]>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #readDir(String, String, Handler)}
   * 
   */
  readDirBlocking(path: string, filter: string) : string[];

  /**
   *  Reads the entire file as represented by the path {@code path} as a {@link Buffer}, asynchronously.
   *  <p>
   *  Do not use this method to read very large files or you risk running out of available RAM.
   * @param path  path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  readFile(path: string, handler: (result: AsyncResult<Buffer>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #readFile(String, Handler)}
   * 
   */
  readFileBlocking(path: string) : Buffer;

  /**
   *  Creates the file, and writes the specified {@code Buffer data} to the file represented by the path {@code path},
   *  asynchronously.
   * @param path  path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeFile(path: string, data: Buffer, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #writeFile(String, Buffer, Handler)}
   * 
   */
  writeFileBlocking(path: string, data: Buffer) : FileSystem;

  /**
   *  Open the file represented by {@code path}, asynchronously.
   *  <p>
   *  The file is opened for both reading and writing. If the file does not already exist it will be created.
   * @param path  path to the file
   * @param options options describing how the file should be opened
   * @return a reference to this, so the API can be used fluently
   * 
   * 
   */
  open(path: string, options: OpenOptions, handler: (result: AsyncResult<AsyncFile>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #open(String, io.vertx.core.file.OpenOptions, Handler)}
   * 
   */
  openBlocking(path: string, options: OpenOptions) : AsyncFile;

  /**
   *  Creates an empty file with the specified {@code path}, asynchronously.
   * @param path  path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  createFile(path: string, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #createFile(String, Handler)}
   * 
   */
  createFileBlocking(path: string) : FileSystem;

  /**
   *  Creates an empty file with the specified {@code path} and permissions {@code perms}, asynchronously.
   * @param path  path to the file
   * @param perms  the permissions string
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  createFile(path: string, perms: string, handler: (result: AsyncResult<void>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #createFile(String, String, Handler)}
   * 
   */
  createFileBlocking(path: string, perms: string) : FileSystem;

  /**
   *  Determines whether the file as specified by the path {@code path} exists, asynchronously.
   * @param path  path to the file
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exists(path: string, handler: (result: AsyncResult<boolean>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #exists(String, Handler)}
   * 
   */
  existsBlocking(path: string) : boolean;

  /**
   *  Returns properties of the file-system being used by the specified {@code path}, asynchronously.
   * @param path  path to anywhere on the filesystem
   * @param handler  the handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  fsProps(path: string, handler: (result: AsyncResult<FileSystemProps>) => void) : FileSystem;

  /**
   *  Blocking version of {@link #fsProps(String, Handler)}
   * 
   */
  fsPropsBlocking(path: string) : FileSystemProps;

}


export class FileSystemProps {
  /**
   * 
   * @return The total space on the file system, in bytes
   * 
   */
  totalSpace() : number;

  /**
   * 
   * @return The total un-allocated space on the file system, in bytes
   * 
   */
  unallocatedSpace() : number;

  /**
   * 
   * @return The total usable space on the file system, in bytes
   * 
   */
  usableSpace() : number;

}


export class Future {
  /**
   *  Create a future that hasn't completed yet and that is passed to the {@code handler} before it is returned.
   * @param handler the handler
   * @param <T> the result type
   * @return the future.
   * 
   */
  static future(handler: (result: Future) => void) : Future;

  /**
   *  Create a future that hasn't completed yet
   * @param <T>  the result type
   * @return  the future
   * 
   */
  static future() : Future;

  /**
   *  Create a succeeded future with a null result
   * @param <T>  the result type
   * @return  the future
   * 
   */
  static succeededFuture() : Future;

  /**
   *  Created a succeeded future with the specified result.
   * @param result  the result
   * @param <T>  the result type
   * @return  the future
   * 
   */
  static succeededFuture(result: any) : Future;

  /**
   *  Create a failed future with the specified failure cause.
   * @param t  the failure cause as a Throwable
   * @param <T>  the result type
   * @return  the future
   * 
   */
  static failedFuture(t: Error) : Future;

  /**
   *  Create a failed future with the specified failure message.
   * @param failureMessage  the failure message
   * @param <T>  the result type
   * @return  the future
   * 
   */
  static failedFuture(failureMessage: string) : Future;

  /**
   *  Has the future completed?
   *  <p>
   *  It's completed if it's either succeeded or failed.
   * @return true if completed, false if not
   * 
   */
  isComplete() : boolean;

  /**
   *  Set a handler for the result.
   *  <p>
   *  If the future has already been completed it will be called immediately. Otherwise it will be called when the
   *  future is completed.
   * @param handler  the Handler that will be called with the result
   * @return a reference to this, so it can be used fluently
   * 
   * 
   */
  setHandler(handler: (result: AsyncResult<any>) => void) : Future;

  /**
   *  Set the result. Any handler will be called, if there is one, and the future will be marked as completed.
   * @param result  the result
   * 
   */
  complete(result: any) : void;

  /**
   *   Set a null result. Any handler will be called, if there is one, and the future will be marked as completed.
   * 
   */
  complete() : void;

  /**
   *  Set the failure. Any handler will be called, if there is one, and the future will be marked as completed.
   * @param cause  the failure cause
   * 
   */
  fail(cause: Error) : void;

  /**
   *  Try to set the failure. When it happens, any handler will be called, if there is one, and the future will be marked as completed.
   * @param failureMessage  the failure message
   * 
   */
  fail(failureMessage: string) : void;

  /**
   *  Set the failure. Any handler will be called, if there is one, and the future will be marked as completed.
   * @param result  the result
   * @return false when the future is already completed
   * 
   */
  tryComplete(result: any) : boolean;

  /**
   *  Try to set the result. When it happens, any handler will be called, if there is one, and the future will be marked as completed.
   * @return false when the future is already completed
   * 
   */
  tryComplete() : boolean;

  /**
   *  Try to set the failure. When it happens, any handler will be called, if there is one, and the future will be marked as completed.
   * @param cause  the failure cause
   * @return false when the future is already completed
   * 
   */
  tryFail(cause: Error) : boolean;

  /**
   *  Try to set the failure. When it happens, any handler will be called, if there is one, and the future will be marked as completed.
   * @param failureMessage  the failure message
   * @return false when the future is already completed
   * 
   */
  tryFail(failureMessage: string) : boolean;

  /**
   *  The result of the operation. This will be null if the operation failed.
   * @return the result or null if the operation failed.
   * 
   */
  result() : Object;

  /**
   *  A Throwable describing failure. This will be null if the operation succeeded.
   * @return the cause or null if the operation succeeded.
   * 
   */
  cause() : Error;

  /**
   *  Did it succeed?
   * @return true if it succeded or false otherwise
   * 
   */
  succeeded() : boolean;

  /**
   *  Did it fail?
   * @return true if it failed or false otherwise
   * 
   */
  failed() : boolean;

  /**
   *  Compose this future with a provided {@code next} future.<p>
   * 
   *  When this (the one on which {@code compose} is called) future succeeds, the {@code handler} will be called with
   *  the completed value, this handler should complete the next future.<p>
   * 
   *  If the {@code handler} throws an exception, the returned future will be failed with this exception.<p>
   * 
   *  When this future fails, the failure will be propagated to the {@code next} future and the {@code handler}
   *  will not be called.
   * @param handler the handler
   * @param next the next future
   * @return the next future, used for chaining
   * 
   */
  compose(handler: (result: any) => void, next: Future) : Future;

  /**
   *  Compose this future with a {@code mapper} function.<p>
   * 
   *  When this future (the one on which {@code compose} is called) succeeds, the {@code mapper} will be called with
   *  the completed value and this mapper returns another future object. This returned future completion will complete
   *  the future returned by this method call.<p>
   * 
   *  If the {@code mapper} throws an exception, the returned future will be failed with this exception.<p>
   * 
   *  When this future fails, the failure will be propagated to the returned future and the {@code mapper}
   *  will not be called.
   * @param mapper the mapper function
   * @return the composed future
   * 
   */
  compose(mapper: (t: any) => Future) : Future;

  /**
   *  Apply a {@code mapper} function on this future.<p>
   * 
   *  When this future succeeds, the {@code mapper} will be called with the completed value and this mapper
   *  returns a value. This value will complete the future returned by this method call.<p>
   * 
   *  If the {@code mapper} throws an exception, the returned future will be failed with this exception.<p>
   * 
   *  When this future fails, the failure will be propagated to the returned future and the {@code mapper}
   *  will not be called.
   * @param mapper the mapper function
   * @return the mapped future
   * 
   */
  map(mapper: (t: any) => any) : Future;

  /**
   *  Map the result of a future to a specific {@code value}.<p>
   * 
   *  When this future succeeds, this {@code value} will complete the future returned by this method call.<p>
   * 
   *  When this future fails, the failure will be propagated to the returned future.
   * @param value the value that eventually completes the mapped future
   * @return the mapped future
   * 
   */
  map(value: any) : Future;

  /**
   *  Map the result of a future to {@code null}.<p>
   * 
   *  This is a conveniency for {@code future.map((T) null)} or {@code future.map((Void) null)}.<p>
   * 
   *  When this future succeeds, {@code null} will complete the future returned by this method call.<p>
   * 
   *  When this future fails, the failure will be propagated to the returned future.
   * @return the mapped future
   * 
   */
  mapEmpty() : Future;

  /**
   * 
   * @return an handler completing this future
   * 
   */
  completer() : (result: AsyncResult) => void;

  /**
   *  Handles a failure of this Future by returning the result of another Future.
   *  If the mapper fails, then the returned future will be failed with this failure.
   * @param mapper A function which takes the exception of a failure and returns a new future.
   * @return A recovered future
   * 
   */
  recover(mapper: (t: Error) => Future) : Future;

  /**
   *  Apply a {@code mapper} function on this future.<p>
   * 
   *  When this future fails, the {@code mapper} will be called with the completed value and this mapper
   *  returns a value. This value will complete the future returned by this method call.<p>
   * 
   *  If the {@code mapper} throws an exception, the returned future will be failed with this exception.<p>
   * 
   *  When this future succeeds, the result will be propagated to the returned future and the {@code mapper}
   *  will not be called.
   * @param mapper the mapper function
   * @return the mapped future
   * 
   */
  otherwise(mapper: (t: Error) => any) : Future;

  /**
   *  Map the failure of a future to a specific {@code value}.<p>
   * 
   *  When this future fails, this {@code value} will complete the future returned by this method call.<p>
   * 
   *  When this future succeeds, the result will be propagated to the returned future.
   * @param value the value that eventually completes the mapped future
   * @return the mapped future
   * 
   */
  otherwise(value: any) : Future;

  /**
   *  Map the failure of a future to {@code null}.<p>
   * 
   *  This is a convenience for {@code future.otherwise((T) null)}.<p>
   * 
   *  When this future fails, the {@code null} value will complete the future returned by this method call.<p>
   * 
   *  When this future succeeds, the result will be propagated to the returned future.
   * @return the mapped future
   * 
   */
  otherwiseEmpty() : Future;

}

import { RequestOptions } from './options';
import { HttpMethod } from './enums';
import { WebsocketVersion } from './enums';

export class HttpClient {
  /**
   *  Whether the metrics are enabled for this measured object
   * @return true if the metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

  /**
   *  Create an HTTP request to send to the server with the specified options.
   * @param method  the HTTP method
   * @param options  the request options
   * @return  an HTTP client request object
   * 
   */
  request(method: HttpMethod, options: RequestOptions) : HttpClientRequest;

  /**
   *  Create an HTTP request to send to the server at the specified host and port.
   * @param method  the HTTP method
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  request(method: HttpMethod, port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP request to send to the server at the specified host and default port.
   * @param method  the HTTP method
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  request(method: HttpMethod, host: string, requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP request to send to the server with the specified options, specifying a response handler to receive
   * @param method  the HTTP method
   * @param options  the request options
   * @return  an HTTP client request object
   * 
   */
  request(method: HttpMethod, options: RequestOptions, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP request to send to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param method  the HTTP method
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  request(method: HttpMethod, port: number, host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP request to send to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param method  the HTTP method
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  request(method: HttpMethod, host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP request to send to the server at the default host and port.
   * @param method  the HTTP method
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  request(method: HttpMethod, requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP request to send to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param method  the HTTP method
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  request(method: HttpMethod, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP request to send to the server using an absolute URI
   * @param method  the HTTP method
   * @param absoluteURI  the absolute URI
   * @return  an HTTP client request object
   * 
   */
  requestAbs(method: HttpMethod, absoluteURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP request to send to the server using an absolute URI, specifying a response handler to receive
   *  the response
   * @param method  the HTTP method
   * @param absoluteURI  the absolute URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  requestAbs(method: HttpMethod, absoluteURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP GET request to send to the server with the specified options.
   * @param options  the request options
   * @return  an HTTP client request object
   * 
   */
  get(options: RequestOptions) : HttpClientRequest;

  /**
   *  Create an HTTP GET request to send to the server at the specified host and port.
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  get(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP GET request to send to the server at the specified host and default port.
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  get(host: string, requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP GET request to send to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  get(options: RequestOptions, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP GET request to send to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  get(port: number, host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP GET request to send to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  get(host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP GET request to send to the server at the default host and port.
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  get(requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP GET request to send to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  get(requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP GET request to send to the server using an absolute URI
   * @param absoluteURI  the absolute URI
   * @return  an HTTP client request object
   * 
   */
  getAbs(absoluteURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP GET request to send to the server using an absolute URI, specifying a response handler to receive
   *  the response
   * @param absoluteURI  the absolute URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  getAbs(absoluteURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Sends an HTTP GET request to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getNow(options: RequestOptions, responseHandler: (result: HttpClientResponse) => void) : HttpClient;

  /**
   *  Sends an HTTP GET request to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getNow(port: number, host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClient;

  /**
   *  Sends an HTTP GET request to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getNow(host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClient;

  /**
   *  Sends an HTTP GET request  to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  getNow(requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClient;

  /**
   *  Create an HTTP POST request to send to the server with the specified options.
   * @param options  the request options
   * @return  an HTTP client request object
   * 
   */
  post(options: RequestOptions) : HttpClientRequest;

  /**
   *  Create an HTTP POST request to send to the server at the specified host and port.
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  post(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP POST request to send to the server at the specified host and default port.
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  post(host: string, requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP POST request to send to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  post(options: RequestOptions, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP POST request to send to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  post(port: number, host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP POST request to send to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  post(host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP POST request to send to the server at the default host and port.
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  post(requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP POST request to send to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  post(requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP POST request to send to the server using an absolute URI
   * @param absoluteURI  the absolute URI
   * @return  an HTTP client request object
   * 
   */
  postAbs(absoluteURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP POST request to send to the server using an absolute URI, specifying a response handler to receive
   *  the response
   * @param absoluteURI  the absolute URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  postAbs(absoluteURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP HEAD request to send to the server with the specified options.
   * @param options  the request options
   * @return  an HTTP client request object
   * 
   */
  head(options: RequestOptions) : HttpClientRequest;

  /**
   *  Create an HTTP HEAD request to send to the server at the specified host and port.
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  head(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP HEAD request to send to the server at the specified host and default port.
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  head(host: string, requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP HEAD request to send to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  head(options: RequestOptions, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP HEAD request to send to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  head(port: number, host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP HEAD request to send to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  head(host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP HEAD request to send to the server at the default host and port.
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  head(requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP HEAD request to send to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  head(requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP HEAD request to send to the server using an absolute URI
   * @param absoluteURI  the absolute URI
   * @return  an HTTP client request object
   * 
   */
  headAbs(absoluteURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP HEAD request to send to the server using an absolute URI, specifying a response handler to receive
   *  the response
   * @param absoluteURI  the absolute URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  headAbs(absoluteURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Sends an HTTP HEAD request to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  headNow(options: RequestOptions, responseHandler: (result: HttpClientResponse) => void) : HttpClient;

  /**
   *  Sends an HTTP HEAD request to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  headNow(port: number, host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClient;

  /**
   *  Sends an HTTP HEAD request to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  headNow(host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClient;

  /**
   *  Sends an HTTP HEAD request  to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  headNow(requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClient;

  /**
   *  Create an HTTP OPTIONS request to send to the server with the specified options.
   * @param options  the request options
   * @return  an HTTP client request object
   * 
   */
  options(options: RequestOptions) : HttpClientRequest;

  /**
   *  Create an HTTP OPTIONS request to send to the server at the specified host and port.
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  options(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP OPTIONS request to send to the server at the specified host and default port.
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  options(host: string, requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP OPTIONS request to send to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  options(options: RequestOptions, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP OPTIONS request to send to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  options(port: number, host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP OPTIONS request to send to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  options(host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP OPTIONS request to send to the server at the default host and port.
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  options(requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP OPTIONS request to send to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  options(requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP OPTIONS request to send to the server using an absolute URI
   * @param absoluteURI  the absolute URI
   * @return  an HTTP client request object
   * 
   */
  optionsAbs(absoluteURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP OPTIONS request to send to the server using an absolute URI, specifying a response handler to receive
   *  the response
   * @param absoluteURI  the absolute URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  optionsAbs(absoluteURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Sends an HTTP OPTIONS request to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  optionsNow(options: RequestOptions, responseHandler: (result: HttpClientResponse) => void) : HttpClient;

  /**
   *  Sends an HTTP OPTIONS request to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  optionsNow(port: number, host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClient;

  /**
   *  Sends an HTTP OPTIONS request to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  optionsNow(host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClient;

  /**
   *  Sends an HTTP OPTIONS request  to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  optionsNow(requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClient;

  /**
   *  Create an HTTP PUT request to send to the server with the specified options.
   * @param options  the request options
   * @return  an HTTP client request object
   * 
   */
  put(options: RequestOptions) : HttpClientRequest;

  /**
   *  Create an HTTP PUT request to send to the server at the specified host and port.
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  put(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP PUT request to send to the server at the specified host and default port.
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  put(host: string, requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP PUT request to send to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  put(options: RequestOptions, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP PUT request to send to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  put(port: number, host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP PUT request to send to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  put(host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP PUT request to send to the server at the default host and port.
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  put(requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP PUT request to send to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  put(requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP PUT request to send to the server using an absolute URI
   * @param absoluteURI  the absolute URI
   * @return  an HTTP client request object
   * 
   */
  putAbs(absoluteURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP PUT request to send to the server using an absolute URI, specifying a response handler to receive
   *  the response
   * @param absoluteURI  the absolute URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  putAbs(absoluteURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP DELETE request to send to the server with the specified options.
   * @param options  the request options
   * @return  an HTTP client request object
   * 
   */
  delete(options: RequestOptions) : HttpClientRequest;

  /**
   *  Create an HTTP DELETE request to send to the server at the specified host and port.
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  delete(port: number, host: string, requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP DELETE request to send to the server at the specified host and default port.
   * @param host  the host
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  delete(host: string, requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP DELETE request to send to the server with the specified options, specifying a response handler to receive
   *  the response
   * @param options  the request options
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  delete(options: RequestOptions, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP DELETE request to send to the server at the specified host and port, specifying a response handler to receive
   *  the response
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  delete(port: number, host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP DELETE request to send to the server at the specified host and default port, specifying a response handler to receive
   *  the response
   * @param host  the host
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  delete(host: string, requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP DELETE request to send to the server at the default host and port.
   * @param requestURI  the relative URI
   * @return  an HTTP client request object
   * 
   */
  delete(requestURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP DELETE request to send to the server at the default host and port, specifying a response handler to receive
   *  the response
   * @param requestURI  the relative URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  delete(requestURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Create an HTTP DELETE request to send to the server using an absolute URI
   * @param absoluteURI  the absolute URI
   * @return  an HTTP client request object
   * 
   */
  deleteAbs(absoluteURI: string) : HttpClientRequest;

  /**
   *  Create an HTTP DELETE request to send to the server using an absolute URI, specifying a response handler to receive
   *  the response
   * @param absoluteURI  the absolute URI
   * @param responseHandler  the response handler
   * @return  an HTTP client request object
   * 
   */
  deleteAbs(absoluteURI: string, responseHandler: (result: HttpClientResponse) => void) : HttpClientRequest;

  /**
   *  Connect a WebSocket with the specified options
   * @param options  the request options
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(options: RequestOptions, wsConnect: (result: WebSocket) => void) : HttpClient;

  /**
   *  Connect a WebSocket to the specified port, host and relative request URI
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(port: number, host: string, requestURI: string, wsConnect: (result: WebSocket) => void) : HttpClient;

  /**
   *  Connect a WebSocket with the specified options
   * @param options  the request options
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(options: RequestOptions, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Connect a WebSocket to the specified port, host and relative request URI
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(port: number, host: string, requestURI: string, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Connect a WebSocket to the host and relative request URI and default port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(host: string, requestURI: string, wsConnect: (result: WebSocket) => void) : HttpClient;

  /**
   *  Connect a WebSocket to the host and relative request URI and default port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(host: string, requestURI: string, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Connect a WebSocket with the specified options, and with the specified headers
   * @param options  the request options
   * @param headers  the headers
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(options: RequestOptions, headers: MultiMap, wsConnect: (result: WebSocket) => void) : HttpClient;

  /**
   *  Connect a WebSocket to the specified port, host and relative request URI, and with the specified headers
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, wsConnect: (result: WebSocket) => void) : HttpClient;

  /**
   *  Connect a WebSocket with the specified options, and with the specified headers
   * @param options  the request options
   * @param headers  the headers
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(options: RequestOptions, headers: MultiMap, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Connect a WebSocket to the specified port, host and relative request URI, and with the specified headers
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Connect a WebSocket to the specified host,relative request UR, and default port and with the specified headers
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(host: string, requestURI: string, headers: MultiMap, wsConnect: (result: WebSocket) => void) : HttpClient;

  /**
   *  Connect a WebSocket to the specified host,relative request UR, and default port and with the specified headers
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(host: string, requestURI: string, headers: MultiMap, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Connect a WebSocket with the specified optionsI, with the specified headers and using
   *  the specified version of WebSockets
   * @param options  the request options
   * @param headers  the headers
   * @param version  the websocket version
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(options: RequestOptions, headers: MultiMap, version: WebsocketVersion, wsConnect: (result: WebSocket) => void) : HttpClient;

  /**
   *  Connect a WebSocket to the specified port, host and relative request URI, with the specified headers and using
   *  the specified version of WebSockets
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: (result: WebSocket) => void) : HttpClient;

  /**
   *  Connect a WebSocket with the specified options, with the specified headers and using
   *  the specified version of WebSockets
   * @param options  the request options
   * @param headers  the headers
   * @param version  the websocket version
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(options: RequestOptions, headers: MultiMap, version: WebsocketVersion, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Connect a WebSocket to the specified port, host and relative request URI, with the specified headers and using
   *  the specified version of WebSockets
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Connect a WebSocket to the specified host, relative request URI and default port with the specified headers and using
   *  the specified version of WebSockets
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: (result: WebSocket) => void) : HttpClient;

  /**
   *  Connect a WebSocket to the specified host, relative request URI and default port with the specified headers and using
   *  the specified version of WebSockets
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Connect a WebSocket with the specified options, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param options  the request options
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(options: RequestOptions, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: (result: WebSocket) => void) : HttpClient;

  /**
   *  Connect a WebSocket to the specified port, host and relative request URI, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: (result: WebSocket) => void) : HttpClient;

  /**
   *  Connect a WebSocket with the specified absolute url, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols.
   * @param url            the absolute url
   * @param headers        the headers
   * @param version        the websocket version
   * @param subProtocols   the subprotocols to use
   * @param wsConnect      handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocketAbs(url: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Connect a WebSocket with the specified options, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param options  the request options
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(options: RequestOptions, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Connect a WebSocket to the specified port, host and relative request URI, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Connect a WebSocket to the specified host, relative request URI and default port, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: (result: WebSocket) => void) : HttpClient;

  /**
   *  Connect a WebSocket to the specified host, relative request URI and default port, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Connect a WebSocket at the relative request URI using the default host and port
   * @param requestURI  the relative URI
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(requestURI: string, wsConnect: (result: WebSocket) => void) : HttpClient;

  /**
   *  Connect a WebSocket at the relative request URI using the default host and port
   * @param requestURI  the relative URI
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(requestURI: string, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Connect a WebSocket at the relative request URI using the default host and port and the specified headers
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(requestURI: string, headers: MultiMap, wsConnect: (result: WebSocket) => void) : HttpClient;

  /**
   *  Connect a WebSocket at the relative request URI using the default host and port and the specified headers
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(requestURI: string, headers: MultiMap, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Connect a WebSocket at the relative request URI using the default host and port, the specified headers and the
   *  specified version of WebSockets
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: (result: WebSocket) => void) : HttpClient;

  /**
   *  Connect a WebSocket at the relative request URI using the default host and port, the specified headers and the
   *  specified version of WebSockets
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(requestURI: string, headers: MultiMap, version: WebsocketVersion, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Connect a WebSocket at the relative request URI using the default host and port, the specified headers, the
   *  specified version of WebSockets and the specified sub protocols
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols
   * @param wsConnect  handler that will be called with the websocket when connected
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: (result: WebSocket) => void) : HttpClient;

  /**
   *  Connect a WebSocket at the relative request URI using the default host and port, the specified headers, the
   *  specified version of WebSockets and the specified sub protocols
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols
   * @param wsConnect  handler that will be called with the websocket when connected
   * @param failureHandler handler that will be called if websocket connection fails
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocket(requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string, wsConnect: (result: WebSocket) => void, failureHandler: (result: Error) => void) : HttpClient;

  /**
   *  Create a WebSocket stream with the specified options
   * @param options  the request options
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStream(options: RequestOptions) : ReadStream;

  /**
   *  Create a WebSocket stream to the specified port, host and relative request URI
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStream(port: number, host: string, requestURI: string) : ReadStream;

  /**
   *  Create a WebSocket stream to the specified host, relative request URI and default port
   * @param host  the host
   * @param requestURI  the relative URI
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStream(host: string, requestURI: string) : ReadStream;

  /**
   *  Create a WebSocket stream with the specified options, and with the specified headers
   * @param options  the request options
   * @param headers  the headers
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStream(options: RequestOptions, headers: MultiMap) : ReadStream;

  /**
   *  Create a WebSocket stream to the specified port, host and relative request URI, and with the specified headers
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStream(port: number, host: string, requestURI: string, headers: MultiMap) : ReadStream;

  /**
   *  Create a WebSocket stream to the specified host, relative request URI and default port and with the specified headers
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStream(host: string, requestURI: string, headers: MultiMap) : ReadStream;

  /**
   *  Create a WebSocket stream with the specified options, with the specified headers and using
   *  the specified version of WebSockets
   * @param options  the request options
   * @param headers  the headers
   * @param version  the websocket version
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStream(options: RequestOptions, headers: MultiMap, version: WebsocketVersion) : ReadStream;

  /**
   *  Create a WebSocket stream to the specified port, host and relative request URI, with the specified headers and using
   *  the specified version of WebSockets
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStream(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion) : ReadStream;

  /**
   *  Create a WebSocket stream with the specified options and with the specified headers and using
   *  the specified version of WebSockets
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStream(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion) : ReadStream;

  /**
   *  Create a WebSocket stream with the specified absolute url, the specified headers, using the specified version of WebSockets,
   *  and the specified websocket sub protocols.
   * @param url          the absolute url
   * @param headers      the headers
   * @param version      the websocket version
   * @param subProtocols the subprotocols to use
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStreamAbs(url: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string) : ReadStream;

  /**
   *  Create a WebSocket stream to the specified port, host and relative request URI, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param options  the request options
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStream(options: RequestOptions, headers: MultiMap, version: WebsocketVersion, subProtocols: string) : ReadStream;

  /**
   *  Create a WebSocket stream to the specified port, host and relative request URI, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param port  the port
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStream(port: number, host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string) : ReadStream;

  /**
   *  Create a WebSocket stream to the specified host, relative request URI and default port, with the specified headers, using
   *  the specified version of WebSockets, and the specified websocket sub protocols
   * @param host  the host
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols to use
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStream(host: string, requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string) : ReadStream;

  /**
   *  Create a WebSocket stream at the relative request URI using the default host and port and the specified headers
   * @param requestURI  the relative URI
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStream(requestURI: string) : ReadStream;

  /**
   *  Create a WebSocket stream at the relative request URI using the default host and port and the specified headers
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStream(requestURI: string, headers: MultiMap) : ReadStream;

  /**
   *  Create a WebSocket stream at the relative request URI using the default host and port, the specified headers and the
   *  specified version of WebSockets
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStream(requestURI: string, headers: MultiMap, version: WebsocketVersion) : ReadStream;

  /**
   *  Create a WebSocket stream at the relative request URI using the default host and port, the specified headers, the
   *  specified version of WebSockets and the specified sub protocols
   * @param requestURI  the relative URI
   * @param headers  the headers
   * @param version  the websocket version
   * @param subProtocols  the subprotocols
   * @return a stream emitting a WebSocket event when the client connection has been upgraded to a websocket
   * 
   */
  websocketStream(requestURI: string, headers: MultiMap, version: WebsocketVersion, subProtocols: string) : ReadStream;

  /**
   *  Set a redirect handler for the http client.
   *  <p>
   *  The redirect handler is called when a {@code 3xx} response is received and the request is configured to
   *  follow redirects with {@link HttpClientRequest#setFollowRedirects(boolean)}.
   *  <p>
   *  The redirect handler is passed the {@link HttpClientResponse}, it can return an {@link HttpClientRequest} or {@code null}.
   *  <ul>
   *    <li>when null is returned, the original response is processed by the original request response handler</li>
   *    <li>when a new {@code Future<HttpClientRequest>} is returned, the client will send this new request</li>
   *  </ul>
   *  The handler must return a {@code Future<HttpClientRequest>} unsent so the client can further configure it and send it.
   * @param handler the new redirect handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  redirectHandler(handler: (t: HttpClientResponse) => Future) : HttpClient;

  /**
   *  Close the client. Closing will close down any pooled connections.
   *  Clients should always be closed after use.
   * 
   */
  close() : void;

}

import { HttpVersion } from './enums';

export class HttpClientRequest {
  /**
   *  This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  exceptionHandler(handler: (result: Error) => void | null | undefined) : HttpClientRequest;

  /**
   * 
   * @throws java.lang.IllegalStateException when no response handler is set
   * 
   */
  write(data: Buffer) : HttpClientRequest;

  setWriteQueueMaxSize(maxSize: number) : HttpClientRequest;

  drainHandler(handler: (result: void) => void | null | undefined) : HttpClientRequest;

  handler(handler: (result: HttpClientResponse) => void | null | undefined) : HttpClientRequest;

  pause() : HttpClientRequest;

  resume() : HttpClientRequest;

  endHandler(endHandler: (result: void) => void | null | undefined) : HttpClientRequest;

  setFollowRedirects(followRedirects: boolean) : HttpClientRequest;

  /**
   *  If chunked is true then the request will be set into HTTP chunked mode
   * @param chunked true if chunked encoding
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setChunked(chunked: boolean) : HttpClientRequest;

  /**
   * 
   * @return Is the request chunked?
   * 
   */
  isChunked() : boolean;

  /**
   *  The HTTP method for the request.
   * 
   */
  method() : HttpMethod;

  /**
   * 
   * @return the raw value of the method this request sends
   * 
   */
  getRawMethod() : string;

  /**
   *  Set the value the method to send when the method {@link HttpMethod#OTHER} is used.
   * @param method the raw method
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setRawMethod(method: string) : HttpClientRequest;

  /**
   * 
   * @return the absolute URI corresponding to the the HTTP request
   * 
   */
  absoluteURI() : string;

  /**
   * 
   * @return The URI of the request.
   * 
   */
  uri() : string;

  /**
   * 
   * @return The path part of the uri. For example /somepath/somemorepath/someresource.foo
   * 
   */
  path() : string;

  /**
   * 
   * @return the query part of the uri. For example someparam=32&amp;someotherparam=x
   * 
   */
  query() : string;

  /**
   *  Set the request host.<p/>
   * 
   *  For HTTP/2 it sets the {@literal :authority} pseudo header otherwise it sets the {@literal Host} header
   * 
   */
  setHost(host: string) : HttpClientRequest;

  /**
   * 
   * @return the request host. For HTTP/2 it returns the {@literal :authority} pseudo header otherwise it returns the {@literal Host} header
   * 
   */
  getHost() : string;

  /**
   * 
   * @return The HTTP headers
   * 
   */
  headers() : MultiMap;

  /**
   *  Put an HTTP header
   * @param name  The header name
   * @param value The header value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  putHeader(name: string, value: string) : HttpClientRequest;

  /**
   *  Write a {@link String} to the request body, encoded as UTF-8.
   * @return @return a reference to this, so the API can be used fluently
   * @throws java.lang.IllegalStateException when no response handler is set
   * 
   */
  write(chunk: string) : HttpClientRequest;

  /**
   *  Write a {@link String} to the request body, encoded using the encoding {@code enc}.
   * @return @return a reference to this, so the API can be used fluently
   * @throws java.lang.IllegalStateException when no response handler is set
   * 
   */
  write(chunk: string, enc: string) : HttpClientRequest;

  /**
   *  If you send an HTTP request with the header {@code Expect} set to the value {@code 100-continue}
   *  and the server responds with an interim HTTP response with a status code of {@code 100} and a continue handler
   *  has been set using this method, then the {@code handler} will be called.
   *  <p>
   *  You can then continue to write data to the request body and later end it. This is normally used in conjunction with
   *  the {@link #sendHead()} method to force the request header to be written before the request has ended.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  continueHandler(handler: (result: void) => void | null | undefined) : HttpClientRequest;

  /**
   *  Forces the head of the request to be written before {@link #end()} is called on the request or any data is
   *  written to it.
   *  <p>
   *  This is normally used to implement HTTP 100-continue handling, see {@link #continueHandler(io.vertx.core.Handler)} for
   *  more information.
   * @return a reference to this, so the API can be used fluently
   * @throws java.lang.IllegalStateException when no response handler is set
   * 
   */
  sendHead() : HttpClientRequest;

  /**
   *  Like {@link #sendHead()} but with an handler after headers have been sent. The handler will be called with
   *  the {@link HttpVersion} if it can be determined or null otherwise.<p>
   * 
   */
  sendHead(completionHandler: (result: HttpVersion) => void) : HttpClientRequest;

  /**
   *  Same as {@link #end(Buffer)} but writes a String in UTF-8 encoding
   * @throws java.lang.IllegalStateException when no response handler is set
   * 
   */
  end(chunk: string) : void;

  /**
   *  Same as {@link #end(Buffer)} but writes a String with the specified encoding
   * @throws java.lang.IllegalStateException when no response handler is set
   * 
   */
  end(chunk: string, enc: string) : void;

  /**
   *  Same as {@link #end()} but writes some data to the request body before ending. If the request is not chunked and
   *  no other data has been written then the {@code Content-Length} header will be automatically set
   * @throws java.lang.IllegalStateException when no response handler is set
   * 
   */
  end(chunk: Buffer) : void;

  /**
   *  Ends the request. If no data has been written to the request body, and {@link #sendHead()} has not been called then
   *  the actual request won't get written until this method gets called.
   *  <p>
   *  Once the request has ended, it cannot be used any more,
   * @throws java.lang.IllegalStateException when no response handler is set
   * 
   */
  end() : void;

  /**
   *  Set's the amount of time after which if the request does not return any data within the timeout period an
   *  {@link java.util.concurrent.TimeoutException} will be passed to the exception handler (if provided) and
   *  the request will be closed.
   *  <p>
   *  Calling this method more than once has the effect of canceling any existing timeout and starting
   *  the timeout from scratch.
   * @param timeoutMs The quantity of time in milliseconds.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setTimeout(timeoutMs: number) : HttpClientRequest;

  /**
   *  Set a push handler for this request.<p/>
   * 
   *  The handler is called when the client receives a <i>push promise</i> from the server. The handler can be called
   *  multiple times, for each push promise.<p/>
   * 
   *  The handler is called with a <i>read-only</i> {@link HttpClientRequest}, the following methods can be called:<p/>
   * 
   *  <ul>
   *    <li>{@link HttpClientRequest#method()}</li>
   *    <li>{@link HttpClientRequest#uri()}</li>
   *    <li>{@link HttpClientRequest#headers()}</li>
   *    <li>{@link HttpClientRequest#getHost()}</li>
   *  </ul>
   * 
   *  In addition the handler should call the {@link HttpClientRequest#handler} method to set an handler to
   *  process the response.<p/>
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pushHandler(handler: (result: HttpClientRequest) => void) : HttpClientRequest;

  /**
   *  Reset this stream with the error code {@code 0}.
   * @see #reset(long)
   * 
   */
  reset() : boolean;

  /**
   *  Reset this request:
   *  <p/>
   *  <ul>
   *    <li>for HTTP/2, this performs send an HTTP/2 reset frame with the specified error {@code code}</li>
   *    <li>for HTTP/1.x, this closes the connection when the current request is inflight</li>
   *  </ul>
   *  <p/>
   *  When the request has not yet been sent, the request will be aborted and false is returned as indicator.
   *  <p/>
   * @param code the error code
   * @return true when reset has been performed
   * 
   */
  reset(code: number) : boolean;

  /**
   * 
   * @return the {@link HttpConnection} associated with this request
   * 
   */
  connection() : HttpConnection;

  /**
   *  Set a connection handler called when an HTTP connection has been established.
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connectionHandler(handler: (result: HttpConnection) => void | null | undefined) : HttpClientRequest;

  /**
   *  Write an HTTP/2 frame to the request, allowing to extend the HTTP/2 protocol.<p>
   * 
   *  The frame is sent immediatly and is not subject to flow control.<p>
   * 
   *  This method must be called after the request headers have been sent and only for the protocol HTTP/2.
   *  The {@link #sendHead(Handler)} should be used for this purpose.
   * @param type the 8-bit frame type
   * @param flags the 8-bit frame flags
   * @param payload the frame payload
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeCustomFrame(type: number, flags: number, payload: Buffer) : HttpClientRequest;

  /**
   * 
   * @return the id of the stream of this response, {@literal -1} when it is not yet determined, i.e
   *          the request has not been yet sent or it is not supported HTTP/1.x
   * 
   */
  streamId() : number;

  /**
   *  Like {@link #writeCustomFrame(int, int, Buffer)} but with an {@link HttpFrame}.
   * @param frame the frame to write
   * 
   */
  writeCustomFrame(frame: HttpFrame) : HttpClientRequest;

}


export class HttpClientResponse {
  resume() : HttpClientResponse;

  exceptionHandler(handler: (result: Error) => void | null | undefined) : HttpClientResponse;

  handler(handler: (result: Buffer) => void | null | undefined) : HttpClientResponse;

  pause() : HttpClientResponse;

  endHandler(endHandler: (result: void) => void | null | undefined) : HttpClientResponse;

  /**
   * 
   * @return the version of the response
   * 
   */
  version() : HttpVersion;

  /**
   * 
   * @return the status code of the response
   * 
   */
  statusCode() : number;

  /**
   * 
   * @return the status message of the response
   * 
   */
  statusMessage() : string;

  /**
   * 
   * @return the headers
   * 
   */
  headers() : MultiMap;

  /**
   *  Return the first header value with the specified name
   * @param headerName  the header name
   * @return the header value
   * 
   */
  getHeader(headerName: string) : string | null;

  /**
   *  Return the first trailer value with the specified name
   * @param trailerName  the trailer name
   * @return the trailer value
   * 
   */
  getTrailer(trailerName: string) : string | null;

  /**
   * 
   * @return the trailers
   * 
   */
  trailers() : MultiMap;

  /**
   * 
   * @return the Set-Cookie headers (including trailers)
   * 
   */
  cookies() : string[];

  /**
   *  Convenience method for receiving the entire request body in one piece.
   *  <p>
   *  This saves you having to manually set a dataHandler and an endHandler and append the chunks of the body until
   *  the whole body received. Don't use this if your request body is large - you could potentially run out of RAM.
   * @param bodyHandler This handler will be called after all the body has been received
   * 
   */
  bodyHandler(bodyHandler: (result: Buffer) => void) : HttpClientResponse;

  /**
   *  Set an custom frame handler. The handler will get notified when the http stream receives an custom HTTP/2
   *  frame. HTTP/2 permits extension of the protocol.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  customFrameHandler(handler: (result: HttpFrame) => void) : HttpClientResponse;

  /**
   *  Get a net socket for the underlying connection of this request.
   *  <p>
   *  USE THIS WITH CAUTION! Writing to the socket directly if you don't know what you're doing can easily break the HTTP protocol
   *  <p>
   *  One valid use-case for calling this is to receive the {@link io.vertx.core.net.NetSocket} after a HTTP CONNECT was issued to the
   *  remote peer and it responded with a status code of 200.
   * @return the net socket
   * 
   */
  netSocket() : NetSocket;

  /**
   * 
   * @return the corresponding request
   * 
   */
  request() : HttpClientRequest;

}

import { GoAway } from './options';
import { Http2Settings } from './options';

export class HttpConnection {
  /**
   * 
   * @return the current connection window size or {@code -1} for HTTP/1.x
   * 
   */
  getWindowSize() : number;

  /**
   *  Update the current connection wide window size to a new size.
   *  <p/>
   *  Increasing this value, gives better performance when several data streams are multiplexed
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param windowSize the new window size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWindowSize(windowSize: number) : HttpConnection;

  /**
   *  Like {@link #goAway(long, int)} with a last stream id {@code -1} which means to disallow any new stream creation.
   * 
   */
  goAway(errorCode: number) : HttpConnection;

  /**
   *  Like {@link #goAway(long, int, Buffer)} with no buffer.
   * 
   */
  goAway(errorCode: number, lastStreamId: number) : HttpConnection;

  /**
   *  Send a go away frame to the remote endpoint of the connection.
   *  <p/>
   *  <ul>
   *    <li>a {@literal GOAWAY} frame is sent to the to the remote endpoint with the {@code errorCode} and {@code debugData}</li>
   *    <li>any stream created after the stream identified by {@code lastStreamId} will be closed</li>
   *    <li>for an {@literal errorCode} is different than {@code 0} when all the remaining streams are closed this connection will be closed automatically</li>
   *  </ul>
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param errorCode the {@literal GOAWAY} error code
   * @param lastStreamId the last stream id
   * @param debugData additional debug data sent to the remote endpoint
   * @return a reference to this, so the API can be used fluently
   * 
   */
  goAway(errorCode: number, lastStreamId: number, debugData: Buffer) : HttpConnection;

  /**
   *  Set an handler called when a {@literal GOAWAY} frame is received.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  goAwayHandler(handler: (result: GoAway) => void | null | undefined) : HttpConnection;

  /**
   *  Set an handler called when a {@literal GOAWAY} frame has been sent or received and all connections are closed.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  shutdownHandler(handler: (result: void) => void | null | undefined) : HttpConnection;

  /**
   *  Initiate a connection shutdown, a go away frame is sent and the connection is closed when all current active streams
   *  are closed or after a time out of 30 seconds.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  shutdown() : HttpConnection;

  /**
   *  Initiate a connection shutdown, a go away frame is sent and the connection is closed when all current streams
   *  will be closed or the {@code timeout} is fired.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param timeoutMs the timeout in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  shutdown(timeoutMs: number) : HttpConnection;

  /**
   *  Set a close handler. The handler will get notified when the connection is closed.
   * @param handler the handler to be notified
   * @return a reference to this, so the API can be used fluently
   * 
   */
  closeHandler(handler: (result: void) => void) : HttpConnection;

  /**
   *  Close the connection and all the currently active streams.
   *  <p/>
   *  An HTTP/2 connection will send a {@literal GOAWAY} frame before.
   * 
   */
  close() : void;

  /**
   * 
   * @return the latest server settings acknowledged by the remote endpoint - this is not implemented for HTTP/1.x
   * 
   */
  settings() : Http2Settings;

  /**
   *  Send to the remote endpoint an update of the server settings.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param settings the new settings
   * @return a reference to this, so the API can be used fluently
   * 
   */
  updateSettings(settings: Http2Settings) : HttpConnection;

  /**
   *  Send to the remote endpoint an update of this endpoint settings
   *  <p/>
   *  The {@code completionHandler} will be notified when the remote endpoint has acknowledged the settings.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param settings the new settings
   * @param completionHandler the handler notified when the settings have been acknowledged by the remote endpoint
   * @return a reference to this, so the API can be used fluently
   * 
   */
  updateSettings(settings: Http2Settings, completionHandler: (result: AsyncResult<void>) => void) : HttpConnection;

  /**
   * 
   * @return the current remote endpoint settings for this connection - this is not implemented for HTTP/1.x
   * 
   */
  remoteSettings() : Http2Settings;

  /**
   *  Set an handler that is called when remote endpoint {@link Http2Settings} are updated.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param handler the handler for remote endpoint settings
   * @return a reference to this, so the API can be used fluently
   * 
   */
  remoteSettingsHandler(handler: (result: Http2Settings) => void) : HttpConnection;

  /**
   *  Send a {@literal PING} frame to the remote endpoint.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param data the 8 bytes data of the frame
   * @param pongHandler an async result handler notified with pong reply or the failure
   * @return a reference to this, so the API can be used fluently
   * 
   */
  ping(data: Buffer, pongHandler: (result: AsyncResult<Buffer>) => void) : HttpConnection;

  /**
   *  Set an handler notified when a {@literal PING} frame is received from the remote endpoint.
   *  <p/>
   *  This is not implemented for HTTP/1.x.
   * @param handler the handler to be called when a {@literal PING} is received
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pingHandler(handler: (result: Buffer) => void | null | undefined) : HttpConnection;

  /**
   *  Set an handler called when a connection error happens
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(handler: (result: Error) => void) : HttpConnection;

  /**
   * 
   * @return the remote address for this connection
   * 
   */
  remoteAddress() : SocketAddress;

  /**
   * 
   * @return the remote address for this connection
   * 
   */
  localAddress() : SocketAddress;

  /**
   * 
   * @return true if this {@link io.vertx.core.http.HttpConnection} is encrypted via SSL/TLS.
   * 
   */
  isSsl() : boolean;

  /**
   *  Returns the SNI server name presented during the SSL handshake by the client.
   * @return the indicated server name
   * 
   */
  indicatedServerName() : string;

}


export class HttpFrame {
  /**
   * 
   * @return the 8-bit type of the frame
   * 
   */
  type() : number;

  /**
   * 
   * @return the 8-bit flags specific to the frame
   * 
   */
  flags() : number;

  /**
   * 
   * @return the frame payload
   * 
   */
  payload() : Buffer;

}


export class HttpServer {
  /**
   *  Whether the metrics are enabled for this measured object
   * @return true if the metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

  /**
   *  Return the request stream for the server. As HTTP requests are received by the server,
   *  instances of {@link HttpServerRequest} will be created and passed to the stream {@link io.vertx.core.streams.ReadStream#handler(io.vertx.core.Handler)}.
   * @return the request stream
   * 
   */
  requestStream() : ReadStream;

  /**
   *  Set the request handler for the server to {@code requestHandler}. As HTTP requests are received by the server,
   *  instances of {@link HttpServerRequest} will be created and passed to this handler.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  requestHandler(handler: (result: HttpServerRequest) => void) : HttpServer;

  /**
   *  Set a connection handler for the server.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connectionHandler(handler: (result: HttpConnection) => void) : HttpServer;

  /**
   *  Set an exception handler called for socket errors happening before the HTTP connection
   *  is established, e.g during the TLS handshake.
   * @param handler the handler to set
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(handler: (result: Error) => void) : HttpServer;

  /**
   *  Return the websocket stream for the server. If a websocket connect handshake is successful a
   *  new {@link ServerWebSocket} instance will be created and passed to the stream {@link io.vertx.core.streams.ReadStream#handler(io.vertx.core.Handler)}.
   * @return the websocket stream
   * 
   */
  websocketStream() : ReadStream;

  /**
   *  Set the websocket handler for the server to {@code wsHandler}. If a websocket connect handshake is successful a
   *  new {@link ServerWebSocket} instance will be created and passed to the handler.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocketHandler(handler: (result: ServerWebSocket) => void) : HttpServer;

  /**
   *  Tell the server to start listening. The server will listen on the port and host specified in the
   *  {@link io.vertx.core.http.HttpServerOptions} that was used when creating the server.
   *  <p>
   *  The listen happens asynchronously and the server may not be listening until some time after the call has returned.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen() : HttpServer;

  /**
   *  Tell the server to start listening. The server will listen on the port and host specified here,
   *  ignoring any value set in the {@link io.vertx.core.http.HttpServerOptions} that was used when creating the server.
   *  <p>
   *  The listen happens asynchronously and the server may not be listening until some time after the call has returned.
   * @param port  the port to listen on
   * @param host  the host to listen on
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(port: number, host: string) : HttpServer;

  /**
   *  Like {@link #listen(int, String)} but supplying a handler that will be called when the server is actually
   *  listening (or has failed).
   * @param port  the port to listen on
   * @param host  the host to listen on
   * @param listenHandler  the listen handler
   * 
   */
  listen(port: number, host: string, listenHandler: (result: AsyncResult<HttpServer>) => void) : HttpServer;

  /**
   *  Like {@link #listen(int, String)} but the server will listen on host "0.0.0.0" and port specified here ignoring
   *  any value in the {@link io.vertx.core.http.HttpServerOptions} that was used when creating the server.
   * @param port  the port to listen on
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(port: number) : HttpServer;

  /**
   *  Like {@link #listen(int)} but supplying a handler that will be called when the server is actually listening (or has failed).
   * @param port  the port to listen on
   * @param listenHandler  the listen handler
   * 
   */
  listen(port: number, listenHandler: (result: AsyncResult<HttpServer>) => void) : HttpServer;

  /**
   *  Like {@link #listen} but supplying a handler that will be called when the server is actually listening (or has failed).
   * @param listenHandler  the listen handler
   * 
   */
  listen(listenHandler: (result: AsyncResult<HttpServer>) => void) : HttpServer;

  /**
   *  Close the server. Any open HTTP connections will be closed.
   *  <p>
   *  The close happens asynchronously and the server may not be closed until some time after the call has returned.
   * 
   */
  close() : void;

  /**
   *  Like {@link #close} but supplying a handler that will be called when the server is actually closed (or has failed).
   * @param completionHandler  the handler
   * 
   */
  close(completionHandler: (result: AsyncResult<void>) => void) : void;

  /**
   *  The actual port the server is listening on. This is useful if you bound the server specifying 0 as port number
   *  signifying an ephemeral port
   * @return the actual port the server is listening on.
   * 
   */
  actualPort() : number;

}


export class HttpServerFileUpload {
  exceptionHandler(handler: (result: Error) => void | null | undefined) : HttpServerFileUpload;

  handler(handler: (result: Buffer) => void | null | undefined) : HttpServerFileUpload;

  endHandler(endHandler: (result: void) => void | null | undefined) : HttpServerFileUpload;

  pause() : HttpServerFileUpload;

  resume() : HttpServerFileUpload;

  /**
   *  Stream the content of this upload to the given file on storage.
   * @param filename  the name of the file
   * 
   */
  streamToFileSystem(filename: string) : HttpServerFileUpload;

  /**
   * 
   * @return the filename which was used when upload the file.
   * 
   */
  filename() : string;

  /**
   * 
   * @return the name of the attribute
   * 
   */
  name() : string;

  /**
   * 
   * @return  the content type for the upload
   * 
   */
  contentType() : string;

  /**
   * 
   * @return the contentTransferEncoding for the upload
   * 
   */
  contentTransferEncoding() : string;

  /**
   * 
   * @return the charset for the upload
   * 
   */
  charset() : string;

  /**
   *  The size of the upload may not be available until it is all read.
   *  Check {@link #isSizeAvailable} to determine this
   * @return the size of the upload (in bytes)
   * 
   */
  size() : number;

  /**
   * 
   * @return true if the size of the upload can be retrieved via {@link #size()}.
   * 
   */
  isSizeAvailable() : boolean;

}


export class HttpServerRequest {
  exceptionHandler(handler: (result: Error) => void | null | undefined) : HttpServerRequest;

  handler(handler: (result: Buffer) => void | null | undefined) : HttpServerRequest;

  pause() : HttpServerRequest;

  resume() : HttpServerRequest;

  endHandler(endHandler: (result: void) => void | null | undefined) : HttpServerRequest;

  /**
   * 
   * @return the HTTP version of the request
   * 
   */
  version() : HttpVersion;

  /**
   * 
   * @return the HTTP method for the request.
   * 
   */
  method() : HttpMethod;

  /**
   * 
   * @return the HTTP method as sent by the client
   * 
   */
  rawMethod() : string;

  /**
   * 
   * @return true if this {@link io.vertx.core.net.NetSocket} is encrypted via SSL/TLS
   * 
   */
  isSSL() : boolean;

  /**
   * 
   * @return the scheme of the request
   * 
   */
  scheme() : string | null;

  /**
   * 
   * @return the URI of the request. This is usually a relative URI
   * 
   */
  uri() : string;

  /**
   * 
   * @return The path part of the uri. For example /somepath/somemorepath/someresource.foo
   * 
   */
  path() : string | null;

  /**
   * 
   * @return the query part of the uri. For example someparam=32&amp;someotherparam=x
   * 
   */
  query() : string | null;

  /**
   * 
   * @return the request host. For HTTP2 it returns the {@literal :authority} pseudo header otherwise it returns the {@literal Host} header
   * 
   */
  host() : string | null;

  /**
   * 
   * @return the response. Each instance of this class has an {@link HttpServerResponse} instance attached to it. This is used
   *  to send the response back to the client.
   * 
   */
  response() : HttpServerResponse;

  /**
   * 
   * @return the headers in the request.
   * 
   */
  headers() : MultiMap;

  /**
   *  Return the first header value with the specified name
   * @param headerName  the header name
   * @return the header value
   * 
   */
  getHeader(headerName: string) : string | null;

  /**
   * 
   * @return the query parameters in the request
   * 
   */
  params() : MultiMap;

  /**
   *  Return the first param value with the specified name
   * @param paramName  the param name
   * @return the param value
   * 
   */
  getParam(paramName: string) : string | null;

  /**
   * 
   * @return the remote (client side) address of the request
   * 
   */
  remoteAddress() : SocketAddress;

  /**
   * 
   * @return the local (server side) address of the server that handles the request
   * 
   */
  localAddress() : SocketAddress;

  /**
   * 
   * @return the absolute URI corresponding to the the HTTP request
   * 
   */
  absoluteURI() : string;

  /**
   *  Convenience method for receiving the entire request body in one piece.
   *  <p>
   *  This saves the user having to manually setting a data and end handler and append the chunks of the body until
   *  the whole body received. Don't use this if your request body is large - you could potentially run out of RAM.
   * @param bodyHandler This handler will be called after all the body has been received
   * 
   */
  bodyHandler(bodyHandler: (result: Buffer) => void | null | undefined) : HttpServerRequest;

  /**
   *  Get a net socket for the underlying connection of this request.
   *  <p>
   *  USE THIS WITH CAUTION!
   *  <p>
   *  Once you have called this method, you must handle writing to the connection yourself using the net socket,
   *  the server request instance will no longer be usable as normal.
   *  Writing to the socket directly if you don't know what you're doing can easily break the HTTP protocol.
   * @return the net socket
   * 
   */
  netSocket() : NetSocket;

  /**
   *  Call this with true if you are expecting a multi-part body to be submitted in the request.
   *  This must be called before the body of the request has been received
   * @param expect  true - if you are expecting a multi-part body
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setExpectMultipart(expect: boolean) : HttpServerRequest;

  /**
   * 
   * @return  true if we are expecting a multi-part body for this request. See {@link #setExpectMultipart}.
   * 
   */
  isExpectMultipart() : boolean;

  /**
   *  Set an upload handler. The handler will get notified once a new file upload was received to allow you to deal
   *  with the file upload.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  uploadHandler(uploadHandler: (result: HttpServerFileUpload) => void | null | undefined) : HttpServerRequest;

  /**
   *  Returns a map of all form attributes in the request.
   *  <p>
   *  Be aware that the attributes will only be available after the whole body has been received, i.e. after
   *  the request end handler has been called.
   *  <p>
   *  {@link #setExpectMultipart(boolean)} must be called first before trying to get the form attributes.
   * @return the form attributes
   * 
   */
  formAttributes() : MultiMap;

  /**
   *  Return the first form attribute value with the specified name
   * @param attributeName  the attribute name
   * @return the attribute value
   * 
   */
  getFormAttribute(attributeName: string) : string | null;

  /**
   *  Upgrade the connection to a WebSocket connection.
   *  <p>
   *  This is an alternative way of handling WebSockets and can only be used if no websocket handlers are set on the
   *  Http server, and can only be used during the upgrade request during the WebSocket handshake.
   * @return  the WebSocket
   * 
   */
  upgrade() : ServerWebSocket;

  /**
   *  Has the request ended? I.e. has the entire request, including the body been read?
   * @return true if ended
   * 
   */
  isEnded() : boolean;

  /**
   *  Set a custom frame handler. The handler will get notified when the http stream receives an custom HTTP/2
   *  frame. HTTP/2 permits extension of the protocol.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  customFrameHandler(handler: (result: HttpFrame) => void) : HttpServerRequest;

  /**
   * 
   * @return the {@link HttpConnection} associated with this request
   * 
   */
  connection() : HttpConnection;

}


export class HttpServerResponse {
  /**
   *  This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  exceptionHandler(handler: (result: Error) => void | null | undefined) : HttpServerResponse;

  write(data: Buffer) : HttpServerResponse;

  setWriteQueueMaxSize(maxSize: number) : HttpServerResponse;

  drainHandler(handler: (result: void) => void | null | undefined) : HttpServerResponse;

  /**
   * 
   * @return the HTTP status code of the response. The default is {@code 200} representing {@code OK}.
   * 
   */
  getStatusCode() : number;

  /**
   *  Set the status code. If the status message hasn't been explicitly set, a default status message corresponding
   *  to the code will be looked-up and used.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setStatusCode(statusCode: number) : HttpServerResponse;

  /**
   * 
   * @return the HTTP status message of the response. If this is not specified a default value will be used depending on what
   *  {@link #setStatusCode} has been set to.
   * 
   */
  getStatusMessage() : string;

  /**
   *  Set the status message
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setStatusMessage(statusMessage: string) : HttpServerResponse;

  /**
   *  If {@code chunked} is {@code true}, this response will use HTTP chunked encoding, and each call to write to the body
   *  will correspond to a new HTTP chunk sent on the wire.
   *  <p>
   *  If chunked encoding is used the HTTP header {@code Transfer-Encoding} with a value of {@code Chunked} will be
   *  automatically inserted in the response.
   *  <p>
   *  If {@code chunked} is {@code false}, this response will not use HTTP chunked encoding, and therefore the total size
   *  of any data that is written in the respone body must be set in the {@code Content-Length} header <b>before</b> any
   *  data is written out.
   *  <p>
   *  An HTTP chunked response is typically used when you do not know the total size of the request body up front.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setChunked(chunked: boolean) : HttpServerResponse;

  /**
   * 
   * @return is the response chunked?
   * 
   */
  isChunked() : boolean;

  /**
   * 
   * @return The HTTP headers
   * 
   */
  headers() : MultiMap;

  /**
   *  Put an HTTP header
   * @param name  the header name
   * @param value  the header value.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  putHeader(name: string, value: string) : HttpServerResponse;

  /**
   * 
   * @return The HTTP trailers
   * 
   */
  trailers() : MultiMap;

  /**
   *  Put an HTTP trailer
   * @param name  the trailer name
   * @param value  the trailer value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  putTrailer(name: string, value: string) : HttpServerResponse;

  /**
   *  Set a close handler for the response, this is called when the underlying connection is closed and the response
   *  was still using the connection.
   *  <p>
   *  For HTTP/1.x it is called when the connection is closed before {@code end()} is called, therefore it is not
   *  guaranteed to be called.
   *  <p>
   *  For HTTP/2 it is called when the related stream is closed, and therefore it will be always be called.
   * @param handler  the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  closeHandler(handler: (result: void) => void | null | undefined) : HttpServerResponse;

  /**
   *  Set an end handler for the response. This will be called when the response is disposed to allow consistent cleanup
   *  of the response.
   * @param handler  the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  endHandler(handler: (result: void) => void | null | undefined) : HttpServerResponse;

  /**
   *  Write a {@link String} to the response body, encoded using the encoding {@code enc}.
   * @param chunk  the string to write
   * @param enc  the encoding to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  write(chunk: string, enc: string) : HttpServerResponse;

  /**
   *  Write a {@link String} to the response body, encoded in UTF-8.
   * @param chunk  the string to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  write(chunk: string) : HttpServerResponse;

  /**
   *  Used to write an interim 100 Continue response to signify that the client should send the rest of the request.
   *  Must only be used if the request contains an "Expect:100-Continue" header
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeContinue() : HttpServerResponse;

  /**
   *  Same as {@link #end(Buffer)} but writes a String in UTF-8 encoding before ending the response.
   * @param chunk  the string to write before ending the response
   * 
   */
  end(chunk: string) : void;

  /**
   *  Same as {@link #end(Buffer)} but writes a String with the specified encoding before ending the response.
   * @param chunk  the string to write before ending the response
   * @param enc  the encoding to use
   * 
   */
  end(chunk: string, enc: string) : void;

  /**
   *  Same as {@link #end()} but writes some data to the response body before ending. If the response is not chunked and
   *  no other data has been written then the @code{Content-Length} header will be automatically set.
   * @param chunk  the buffer to write before ending the response
   * 
   */
  end(chunk: Buffer) : void;

  /**
   *  Ends the response. If no data has been written to the response body,
   *  the actual response won't get written until this method gets called.
   *  <p>
   *  Once the response has ended, it cannot be used any more.
   * 
   */
  end() : void;

  /**
   *  Same as {@link #sendFile(String, long)} using offset @code{0} which means starting from the beginning of the file.
   * @param filename  path to the file to serve
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string) : HttpServerResponse;

  /**
   *  Same as {@link #sendFile(String, long, long)} using length @code{Long.MAX_VALUE} which means until the end of the
   *  file.
   * @param filename  path to the file to serve
   * @param offset offset to start serving from
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, offset: number) : HttpServerResponse;

  /**
   *  Ask the OS to stream a file as specified by {@code filename} directly
   *  from disk to the outgoing connection, bypassing userspace altogether
   *  (where supported by the underlying operating system.
   *  This is a very efficient way to serve files.<p>
   *  The actual serve is asynchronous and may not complete until some time after this method has returned.
   * @param filename  path to the file to serve
   * @param offset offset to start serving from
   * @param length length to serve to
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, offset: number, length: number) : HttpServerResponse;

  /**
   *  Like {@link #sendFile(String)} but providing a handler which will be notified once the file has been completely
   *  written to the wire.
   * @param filename path to the file to serve
   * @param resultHandler  handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, resultHandler: (result: AsyncResult<void>) => void) : HttpServerResponse;

  /**
   *  Like {@link #sendFile(String, long)} but providing a handler which will be notified once the file has been completely
   *  written to the wire.
   * @param filename path to the file to serve
   * @param offset the offset to serve from
   * @param resultHandler  handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, offset: number, resultHandler: (result: AsyncResult<void>) => void) : HttpServerResponse;

  /**
   *  Like {@link #sendFile(String, long, long)} but providing a handler which will be notified once the file has been
   *  completely written to the wire.
   * @param filename path to the file to serve
   * @param offset the offset to serve from
   * @param length the length to serve to
   * @param resultHandler  handler that will be called on completion
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, offset: number, length: number, resultHandler: (result: AsyncResult<void>) => void) : HttpServerResponse;

  /**
   *  Close the underlying TCP connection corresponding to the request.
   * 
   */
  close() : void;

  /**
   * 
   * @return has the response already ended?
   * 
   */
  ended() : boolean;

  /**
   * 
   * @return has the underlying TCP connection corresponding to the request already been closed?
   * 
   */
  closed() : boolean;

  /**
   * 
   * @return have the headers for the response already been written?
   * 
   */
  headWritten() : boolean;

  /**
   *  Provide a handler that will be called just before the headers are written to the wire.<p>
   *  This provides a hook allowing you to add any more headers or do any more operations before this occurs.
   * @param handler  the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  headersEndHandler(handler: (result: void) => void | null | undefined) : HttpServerResponse;

  /**
   *  Provides a handler that will be called after the last part of the body is written to the wire.
   *  The handler is called asynchronously of when the response has been received by the client.
   *  This provides a hook allowing you to do more operations once the request has been sent over the wire
   *  such as resource cleanup.
   * @param handler  the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  bodyEndHandler(handler: (result: void) => void | null | undefined) : HttpServerResponse;

  /**
   * 
   * @return the total number of bytes written for the body of the response.
   * 
   */
  bytesWritten() : number;

  /**
   * 
   * @return the id of the stream of this response, {@literal -1} for HTTP/1.x
   * 
   */
  streamId() : number;

  /**
   *  Like {@link #push(HttpMethod, String, String, MultiMap, Handler)} with no headers.
   * 
   */
  push(method: HttpMethod, host: string, path: string, handler: (result: AsyncResult<HttpServerResponse>) => void) : HttpServerResponse;

  /**
   *  Like {@link #push(HttpMethod, String, String, MultiMap, Handler)} with the host copied from the current request.
   * 
   */
  push(method: HttpMethod, path: string, headers: MultiMap, handler: (result: AsyncResult<HttpServerResponse>) => void) : HttpServerResponse;

  /**
   *  Like {@link #push(HttpMethod, String, String, MultiMap, Handler)} with the host copied from the current request.
   * 
   */
  push(method: HttpMethod, path: string, handler: (result: AsyncResult<HttpServerResponse>) => void) : HttpServerResponse;

  /**
   *  Push a response to the client.<p/>
   * 
   *  The {@code handler} will be notified with a <i>success</i> when the push can be sent and with
   *  a <i>failure</i> when the client has disabled push or reset the push before it has been sent.<p/>
   * 
   *  The {@code handler} may be queued if the client has reduced the maximum number of streams the server can push
   *  concurrently.<p/>
   * 
   *  Push can be sent only for peer initiated streams and if the response is not ended.
   * @param method the method of the promised request
   * @param host the host of the promised request
   * @param path the path of the promised request
   * @param headers the headers of the promised request
   * @param handler the handler notified when the response can be written
   * @return a reference to this, so the API can be used fluently
   * 
   */
  push(method: HttpMethod, host: string, path: string, headers: MultiMap, handler: (result: AsyncResult<HttpServerResponse>) => void) : HttpServerResponse;

  /**
   *  Reset this HTTP/2 stream with the error code {@code 0}.
   * 
   */
  reset() : void;

  /**
   *  Reset this HTTP/2 stream with the error {@code code}.
   * @param code the error code
   * 
   */
  reset(code: number) : void;

  /**
   *  Write an HTTP/2 frame to the response, allowing to extend the HTTP/2 protocol.<p>
   * 
   *  The frame is sent immediatly and is not subject to flow control.
   * @param type the 8-bit frame type
   * @param flags the 8-bit frame flags
   * @param payload the frame payload
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeCustomFrame(type: number, flags: number, payload: Buffer) : HttpServerResponse;

  /**
   *  Like {@link #writeCustomFrame(int, int, Buffer)} but with an {@link HttpFrame}.
   * @param frame the frame to write
   * 
   */
  writeCustomFrame(frame: HttpFrame) : HttpServerResponse;

}

import { JsonEventType } from './enums';

export class JsonEvent {
  /**
   * 
   * @return the type of the event
   * 
   */
  type() : JsonEventType;

  /**
   * 
   * @return the name of the field when the event is emitted as a JSON object member
   * 
   */
  fieldName() : string;

  /**
   * 
   * @return the json value for {@link JsonEventType#VALUE} events
   * 
   */
  value() : Object;

  /**
   * 
   * @return true when the JSON value is a number
   * 
   */
  isNumber() : boolean;

  /**
   * 
   * @return the {@code Integer} value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not an {@code Integer}
   * 
   */
  integerValue() : number;

  /**
   * 
   * @return the {@code Long} value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a {@code Long}
   * 
   */
  longValue() : number;

  /**
   * 
   * @return the {@code Float} value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a {@code Float}
   * 
   */
  floatValue() : number;

  /**
   * 
   * @return the {@code Double} value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a {@code Double}
   * 
   */
  doubleValue() : number;

  /**
   * 
   * @return true when the JSON value is a boolean
   * 
   */
  isBoolean() : boolean;

  /**
   * 
   * @return the {@code Boolean} value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a {@code Boolean}
   * 
   */
  booleanValue() : boolean;

  /**
   * 
   * @return true when the JSON value is a string
   * 
   */
  isString() : boolean;

  /**
   * 
   * @return the string value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a string
   * 
   */
  stringValue() : string;

  /**
   *  Return the binary value.
   *  <p>
   *  JSON itself has no notion of a binary, this extension complies to the RFC-7493, so this method assumes there is a
   *  String value with the key and it contains a Base64 encoded binary, which it decodes if found and returns.
   * @return the binary value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a String
   * @throws java.lang.IllegalArgumentException if the String value is not a legal Base64 encoded value
   * 
   */
  binaryValue() : Buffer;

  /**
   * 
   * @return true when the JSON value is null
   * 
   */
  isNull() : boolean;

  /**
   * 
   * @return true when the JSON value is a JSON object
   * 
   */
  isObject() : boolean;

  /**
   * 
   * @return the JSON object value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a JSON object
   * 
   */
  objectValue() : object;

  /**
   * 
   * @return true when the JSON value is a JSON array
   * 
   */
  isArray() : boolean;

  /**
   * 
   * @return the JSON array value or {@code null} if the event has no JSON value
   * @throws java.lang.ClassCastException if the value is not a JSON array
   * 
   */
  arrayValue() : any[];

  /**
   *  Decodes and returns the current value as the specified {@code type}.
   * @param type the type to decode the value to
   * @return the decoded value
   * 
   */
  mapTo(type: Class) : Object;

}


export class JsonParser {
  /**
   *  Something has happened, so handle it.
   * @param event  the event to handle
   * 
   */
  handle(event: Buffer) : void;

  /**
   *  Create a new {@code JsonParser} instance.
   * 
   */
  static newParser() : JsonParser;

  /**
   *  Create a new {@code JsonParser} instance.
   * 
   */
  static newParser(stream: ReadStream) : JsonParser;

  /**
   *  Handle a {@code Buffer}, pretty much like calling {@link #handle(Object)}.
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  write(buffer: Buffer) : JsonParser;

  /**
   *  End the stream, this must be called after all the json stream has been processed.
   * 
   */
  end() : void;

  /**
   *  Flip the parser to emit a stream of events for each new json object.
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  objectEventMode() : JsonParser;

  /**
   *  Flip the parser to emit a single value event for each new json object.
   *  </p>
   *  Json object currently streamed won't be affected.
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  objectValueMode() : JsonParser;

  /**
   *  Flip the parser to emit a stream of events for each new json array.
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  arrayEventMode() : JsonParser;

  /**
   *  Flip the parser to emit a single value event for each new json array.
   *  </p>
   *  Json array currently streamed won't be affected.
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  arrayValueMode() : JsonParser;

  pause() : JsonParser;

  resume() : JsonParser;

  endHandler(endHandler: (result: void) => void | null | undefined) : JsonParser;

  handler(handler: (result: JsonEvent) => void | null | undefined) : JsonParser;

  exceptionHandler(handler: (result: Error) => void | null | undefined) : JsonParser;

}


export class LocalMap {
  /**
   *  Get a value from the map
   * @param key the key
   * @return the value, or null if none
   * 
   */
  get(key: any) : Object;

  /**
   *  Put an entry in the map
   * @param key   the key
   * @param value the value
   * @return return the old value, or null if none
   * 
   */
  put(key: any, value: any) : Object;

  /**
   *  Remove an entry from the map
   * @param key the key
   * @return the old value
   * 
   */
  remove(key: any) : Object;

  /**
   *  Clear all entries in the map
   * 
   */
  clear() : void;

  /**
   *  Get the size of the map
   * @return the number of entries in the map
   * 
   */
  size() : number;

  /**
   * 
   * @return true if there are zero entries in the map
   * 
   */
  isEmpty() : boolean;

  /**
   *  Put the entry only if there is no existing entry for that key
   * @param key   the key
   * @param value the value
   * @return the old value or null, if none
   * 
   */
  putIfAbsent(key: any, value: any) : Object;

  /**
   *  Remove the entry only if there is an entry with the specified key and value.
   *  <p>
   *  This method is the poyglot version of {@link #remove(Object, Object)}.
   * @param key   the key
   * @param value the value
   * @return true if removed
   * 
   */
  removeIfPresent(key: any, value: any) : boolean;

  /**
   *  Replace the entry only if there is an existing entry with the specified key and value.
   *  <p>
   *  This method is the polyglot version of {@link #replace(Object, Object, Object)}.
   * @param key      the key
   * @param oldValue the old value
   * @param newValue the new value
   * @return true if removed
   * 
   */
  replaceIfPresent(key: any, oldValue: any, newValue: any) : boolean;

  /**
   *  Replace the entry only if there is an existing entry with the key
   * @param key   the key
   * @param value the new value
   * @return the old value
   * 
   */
  replace(key: any, value: any) : Object;

  /**
   *  Close and release the map
   * 
   */
  close() : void;

  /**
   *  Returns {@code true} if this map contains a mapping for the specified
   *  key.
   * @param key key whose presence in this map is to be tested
   * @return {@code true} if this map contains a mapping for the specified key
   * 
   */
  containsKey(key: any) : boolean;

  /**
   *  Returns @{code true} if this map maps one or more keys to the
   *  specified value.
   * @param value value whose presence in this map is to be tested
   * @return @{code true} if this map maps one or more keys to the specified value
   * 
   */
  containsValue(value: any) : boolean;

  /**
   *  Returns the value to which the specified key is mapped, or
   *  {@code defaultValue} if this map contains no mapping for the key.
   * @param key          the key whose associated value is to be returned
   * @param defaultValue the default mapping of the key
   * @return the value to which the specified key is mapped, or {@code defaultValue} if this map contains no mapping
   *  for the key
   * 
   */
  getOrDefault(key: any, defaultValue: any) : Object;

}


export class Lock {
  /**
   *  Release the lock. Once the lock is released another will be able to obtain the lock.
   * 
   */
  release() : void;

}


export interface Measured {
  /**
   *  Whether the metrics are enabled for this measured object
   * @return true if the metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

}


export class Message {
  /**
   *  The address the message was sent to
   * 
   */
  address() : string;

  /**
   *  Multi-map of message headers. Can be empty
   * @return  the headers
   * 
   */
  headers() : MultiMap;

  /**
   *  The body of the message. Can be null.
   * @return  the body, or null.
   * 
   */
  body() : Object;

  /**
   *  The reply address. Can be null.
   * @return the reply address, or null, if message was sent without a reply handler.
   * 
   */
  replyAddress() : string | null;

  /**
   *  Signals if this message represents a send or publish event.
   * @return true if this is a send.
   * 
   */
  isSend() : boolean;

  /**
   *  Reply to this message.
   *  <p>
   *  If the message was sent specifying a reply handler, that handler will be
   *  called when it has received a reply. If the message wasn't sent specifying a receipt handler
   *  this method does nothing.
   * @param message  the message to reply with.
   * 
   */
  reply(message: any) : void;

  /**
   *  The same as {@code reply(R message)} but you can specify handler for the reply - i.e.
   *  to receive the reply to the reply.
   * @param message  the message to reply with.
   * @param replyHandler  the reply handler for the reply.
   * 
   */
  reply(message: any, replyHandler: (result: AsyncResult<Message>) => void) : void;

  /**
   *  Link {@link #reply(Object)} but allows you to specify delivery options for the reply.
   * @param message  the reply message
   * @param options  the delivery options
   * 
   */
  reply(message: any, options: DeliveryOptions) : void;

  /**
   *  The same as {@code reply(R message, DeliveryOptions)} but you can specify handler for the reply - i.e.
   *  to receive the reply to the reply.
   * @param message  the reply message
   * @param options  the delivery options
   * @param replyHandler  the reply handler for the reply.
   * 
   */
  reply(message: any, options: DeliveryOptions, replyHandler: (result: AsyncResult<Message>) => void) : void;

  /**
   *  Signal to the sender that processing of this message failed.
   *  <p>
   *  If the message was sent specifying a result handler
   *  the handler will be called with a failure corresponding to the failure code and message specified here.
   * @param failureCode A failure code to pass back to the sender
   * @param message A message to pass back to the sender
   * 
   */
  fail(failureCode: number, message: string) : void;

}


export class MessageConsumer {
  exceptionHandler(handler: (result: Error) => void | null | undefined) : MessageConsumer;

  handler(handler: (result: Message) => void | null | undefined) : MessageConsumer;

  pause() : MessageConsumer;

  resume() : MessageConsumer;

  endHandler(endHandler: (result: void) => void | null | undefined) : MessageConsumer;

  /**
   * 
   * @return a read stream for the body of the message stream.
   * 
   */
  bodyStream() : ReadStream;

  /**
   * 
   * @return true if the current consumer is registered
   * 
   */
  isRegistered() : boolean;

  /**
   * 
   * @return The address the handler was registered with.
   * 
   */
  address() : string;

  /**
   *  Set the number of messages this registration will buffer when this stream is paused. The default
   *  value is <code>1000</code>. When a new value is set, buffered messages may be discarded to reach
   *  the new value.
   * @param maxBufferedMessages the maximum number of messages that can be buffered
   * @return this registration
   * 
   */
  setMaxBufferedMessages(maxBufferedMessages: number) : MessageConsumer;

  /**
   * 
   * @return the maximum number of messages that can be buffered when this stream is paused
   * 
   */
  getMaxBufferedMessages() : number;

  /**
   *  Optional method which can be called to indicate when the registration has been propagated across the cluster.
   * @param completionHandler the completion handler
   * 
   */
  completionHandler(completionHandler: (result: AsyncResult<void>) => void) : void;

  /**
   *  Unregisters the handler which created this registration
   * 
   */
  unregister() : void;

  /**
   *  Unregisters the handler which created this registration
   * @param completionHandler the handler called when the unregister is done. For example in a cluster when all nodes of the
   *  event bus have been unregistered.
   * 
   */
  unregister(completionHandler: (result: AsyncResult<void>) => void) : void;

}


export class MessageProducer {
  /**
   *  Same as {@link #end()} but writes some data to the stream before ending.
   * 
   */
  end(t: any) : void;

  /**
   *  This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  /**
   *  Synonym for {@link #write(Object)}.
   * @param message  the message to send
   * @return  reference to this for fluency
   * 
   */
  send(message: any) : MessageProducer;

  send(message: any, replyHandler: (result: AsyncResult<Message>) => void) : MessageProducer;

  exceptionHandler(handler: (result: Error) => void | null | undefined) : MessageProducer;

  write(data: any) : MessageProducer;

  setWriteQueueMaxSize(maxSize: number) : MessageProducer;

  drainHandler(handler: (result: void) => void | null | undefined) : MessageProducer;

  /**
   *  Update the delivery options of this producer.
   * @param options the new options
   * @return this producer object
   * 
   */
  deliveryOptions(options: DeliveryOptions) : MessageProducer;

  /**
   * 
   * @return The address to which the producer produces messages.
   * 
   */
  address() : string;

  /**
   *  Closes the producer, calls {@link #close()}
   * 
   */
  end() : void;

  /**
   *  Closes the producer, this method should be called when the message producer is not used anymore.
   * 
   */
  close() : void;

}


export class MultiMap {
  /**
   *  Create a multi-map implementation with case insensitive keys, for instance it can be used to hold some HTTP headers.
   * @return the multi-map
   * 
   */
  static caseInsensitiveMultiMap() : MultiMap;

  /**
   *  Returns the value of with the specified name.  If there are
   *  more than one values for the specified name, the first value is returned.
   * @param name The name of the header to search
   * @return The first header value or {@code null} if there is no such entry
   * 
   */
  get(name: string) : string | null;

  /**
   *  Returns the values with the specified name
   * @param name The name to search
   * @return A immutable {@link java.util.List} of values which will be empty if no values
   *          are found
   * 
   */
  getAll(name: string) : string[];

  /**
   *  Checks to see if there is a value with the specified name
   * @param name The name to search for
   * @return true if at least one entry is found
   * 
   */
  contains(name: string) : boolean;

  /**
   *  Check if there is a header with the specified {@code name} and {@code value}.
   * 
   *  If {@code caseInsensitive} is {@code true}, {@code value} is compared in a case-insensitive way.
   * @param name the name to search for
   * @param value the value to search for
   * @return {@code true} if at least one entry is found
   * 
   */
  contains(name: string, value: string, caseInsensitive: boolean) : boolean;

  /**
   *  Return true if empty
   * 
   */
  isEmpty() : boolean;

  /**
   *  Gets a immutable {@link java.util.Set} of all names
   * @return A {@link java.util.Set} of all names
   * 
   */
  names() : string[];

  /**
   *  Adds a new value with the specified name and value.
   * @param name The name
   * @param value The value being added
   * @return a reference to this, so the API can be used fluently
   * 
   */
  add(name: string, value: string) : MultiMap;

  /**
   *  Adds all the entries from another MultiMap to this one
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAll(map: MultiMap) : MultiMap;

  /**
   *  Sets a value under the specified name.
   *  <p>
   *  If there is an existing header with the same name, it is removed.
   * @param name The name
   * @param value The value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  set(name: string, value: string) : MultiMap;

  /**
   *  Cleans this instance.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setAll(map: MultiMap) : MultiMap;

  /**
   *  Removes the value with the given name
   * @param name The name  of the value to remove
   * @return a reference to this, so the API can be used fluently
   * 
   */
  remove(name: string) : MultiMap;

  /**
   *  Removes all
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clear() : MultiMap;

  /**
   *  Return the number of keys.
   * 
   */
  size() : number;

}


export class MxRecord {
  /**
   *  The priority of the MX record.
   * 
   */
  priority() : number;

  /**
   *  The name of the MX record
   * 
   */
  name() : string;

}


export class NetClient {
  /**
   *  Whether the metrics are enabled for this measured object
   * @return true if the metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

  /**
   *  Open a connection to a server at the specific {@code port} and {@code host}.
   *  <p>
   *  {@code host} can be a valid host name or IP address. The connect is done asynchronously and on success, a
   *  {@link NetSocket} instance is supplied via the {@code connectHandler} instance
   * @param port  the port
   * @param host  the host
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connect(port: number, host: string, connectHandler: (result: AsyncResult<NetSocket>) => void) : NetClient;

  /**
   *  Open a connection to a server at the specific {@code port} and {@code host}.
   *  <p>
   *  {@code host} can be a valid host name or IP address. The connect is done asynchronously and on success, a
   *  {@link NetSocket} instance is supplied via the {@code connectHandler} instance
   * @param port the port
   * @param host the host
   * @param serverName the SNI server name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connect(port: number, host: string, serverName: string, connectHandler: (result: AsyncResult<NetSocket>) => void) : NetClient;

  /**
   *  Open a connection to a server at the specific {@code remoteAddress}.
   *  <p>
   *  The connect is done asynchronously and on success, a {@link NetSocket} instance is supplied via the {@code connectHandler} instance
   * @param remoteAddress the remote address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connect(remoteAddress: SocketAddress, connectHandler: (result: AsyncResult<NetSocket>) => void) : NetClient;

  /**
   *  Open a connection to a server at the specific {@code remoteAddress}.
   *  <p>
   *  The connect is done asynchronously and on success, a {@link NetSocket} instance is supplied via the {@code connectHandler} instance
   * @param remoteAddress the remote address
   * @param serverName the SNI server name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connect(remoteAddress: SocketAddress, serverName: string, connectHandler: (result: AsyncResult<NetSocket>) => void) : NetClient;

  /**
   *  Close the client.
   *  <p>
   *  Any sockets which have not been closed manually will be closed here. The close is asynchronous and may not
   *  complete until some time after the method has returned.
   * 
   */
  close() : void;

}


export class NetServer {
  /**
   *  Whether the metrics are enabled for this measured object
   * @return true if the metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

  /**
   *  Return the connect stream for this server. The server can only have at most one handler at any one time.
   *  As the server accepts TCP or SSL connections it creates an instance of {@link NetSocket} and passes it to the
   *  connect stream {@link ReadStream#handler(io.vertx.core.Handler)}.
   * @return the connect stream
   * 
   */
  connectStream() : ReadStream;

  /**
   *  Supply a connect handler for this server. The server can only have at most one connect handler at any one time.
   *  As the server accepts TCP or SSL connections it creates an instance of {@link NetSocket} and passes it to the
   *  connect handler.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connectHandler(handler: (result: NetSocket) => void | null | undefined) : NetServer;

  /**
   *  Start listening on the port and host as configured in the {@link io.vertx.core.net.NetServerOptions} used when
   *  creating the server.
   *  <p>
   *  The server may not be listening until some time after the call to listen has returned.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen() : NetServer;

  /**
   *  Like {@link #listen} but providing a handler that will be notified when the server is listening, or fails.
   * @param listenHandler  handler that will be notified when listening or failed
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(listenHandler: (result: AsyncResult<NetServer>) => void) : NetServer;

  /**
   *  Start listening on the specified port and host, ignoring port and host configured in the {@link io.vertx.core.net.NetServerOptions} used when
   *  creating the server.
   *  <p>
   *  Port {@code 0} can be specified meaning "choose an random port".
   *  <p>
   *  Host {@code 0.0.0.0} can be specified meaning "listen on all available interfaces".
   *  <p>
   *  The server may not be listening until some time after the call to listen has returned.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(port: number, host: string) : NetServer;

  /**
   *  Like {@link #listen(int, String)} but providing a handler that will be notified when the server is listening, or fails.
   * @param port  the port to listen on
   * @param host  the host to listen on
   * @param listenHandler handler that will be notified when listening or failed
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(port: number, host: string, listenHandler: (result: AsyncResult<NetServer>) => void) : NetServer;

  /**
   *  Start listening on the specified port and host "0.0.0.0", ignoring port and host configured in the
   *  {@link io.vertx.core.net.NetServerOptions} used when creating the server.
   *  <p>
   *  Port {@code 0} can be specified meaning "choose an random port".
   *  <p>
   *  The server may not be listening until some time after the call to listen has returned.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(port: number) : NetServer;

  /**
   *  Like {@link #listen(int)} but providing a handler that will be notified when the server is listening, or fails.
   * @param port  the port to listen on
   * @param listenHandler handler that will be notified when listening or failed
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(port: number, listenHandler: (result: AsyncResult<NetServer>) => void) : NetServer;

  /**
   *  Start listening on the specified local address, ignoring port and host configured in the {@link io.vertx.core.net.NetServerOptions} used when
   *  creating the server.
   *  <p>
   *  The server may not be listening until some time after the call to listen has returned.
   * @param localAddress the local address to listen on
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(localAddress: SocketAddress) : NetServer;

  /**
   *  Like {@link #listen(SocketAddress)} but providing a handler that will be notified when the server is listening, or fails.
   * @param localAddress the local address to listen on
   * @param listenHandler handler that will be notified when listening or failed
   * @return a reference to this, so the API can be used fluently
   * 
   */
  listen(localAddress: SocketAddress, listenHandler: (result: AsyncResult<NetServer>) => void) : NetServer;

  /**
   *  Set an exception handler called for socket errors happening before the connection
   *  is passed to the {@link #connectHandler}, e.g during the TLS handshake.
   * @param handler the handler to set
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(handler: (result: Error) => void) : NetServer;

  /**
   *  Close the server. This will close any currently open connections. The close may not complete until after this
   *  method has returned.
   * 
   */
  close() : void;

  /**
   *  Like {@link #close} but supplying a handler that will be notified when close is complete.
   * @param completionHandler  the handler
   * 
   */
  close(completionHandler: (result: AsyncResult<void>) => void) : void;

  /**
   *  The actual port the server is listening on. This is useful if you bound the server specifying 0 as port number
   *  signifying an ephemeral port
   * @return the actual port the server is listening on.
   * 
   */
  actualPort() : number;

}


export class NetSocket {
  /**
   *  Same as {@link #end()} but writes some data to the stream before ending.
   * 
   */
  end(t: Buffer) : void;

  /**
   *  This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  exceptionHandler(handler: (result: Error) => void | null | undefined) : NetSocket;

  handler(handler: (result: Buffer) => void | null | undefined) : NetSocket;

  pause() : NetSocket;

  resume() : NetSocket;

  endHandler(endHandler: (result: void) => void | null | undefined) : NetSocket;

  write(data: Buffer) : NetSocket;

  setWriteQueueMaxSize(maxSize: number) : NetSocket;

  drainHandler(handler: (result: void) => void | null | undefined) : NetSocket;

  /**
   *  When a {@code NetSocket} is created it automatically registers an event handler with the event bus, the ID of that
   *  handler is given by {@code writeHandlerID}.
   *  <p>
   *  Given this ID, a different event loop can send a buffer to that event handler using the event bus and
   *  that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   *  allows you to write data to other connections which are owned by different event loops.
   * @return the write handler ID
   * 
   */
  writeHandlerID() : string;

  /**
   *  Write a {@link String} to the connection, encoded in UTF-8.
   * @param str  the string to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  write(str: string) : NetSocket;

  /**
   *  Write a {@link String} to the connection, encoded using the encoding {@code enc}.
   * @param str  the string to write
   * @param enc  the encoding to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  write(str: string, enc: string) : NetSocket;

  /**
   *  Tell the operating system to stream a file as specified by {@code filename} directly from disk to the outgoing connection,
   *  bypassing userspace altogether (where supported by the underlying operating system. This is a very efficient way to stream files.
   * @param filename  file name of the file to send
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string) : NetSocket;

  /**
   *  Tell the operating system to stream a file as specified by {@code filename} directly from disk to the outgoing connection,
   *  bypassing userspace altogether (where supported by the underlying operating system. This is a very efficient way to stream files.
   * @param filename  file name of the file to send
   * @param offset offset
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, offset: number) : NetSocket;

  /**
   *  Tell the operating system to stream a file as specified by {@code filename} directly from disk to the outgoing connection,
   *  bypassing userspace altogether (where supported by the underlying operating system. This is a very efficient way to stream files.
   * @param filename  file name of the file to send
   * @param offset offset
   * @param length length
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, offset: number, length: number) : NetSocket;

  /**
   *  Same as {@link #sendFile(String)} but also takes a handler that will be called when the send has completed or
   *  a failure has occurred
   * @param filename  file name of the file to send
   * @param resultHandler  handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, resultHandler: (result: AsyncResult<void>) => void) : NetSocket;

  /**
   *  Same as {@link #sendFile(String, long)} but also takes a handler that will be called when the send has completed or
   *  a failure has occurred
   * @param filename  file name of the file to send
   * @param offset offset
   * @param resultHandler  handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, offset: number, resultHandler: (result: AsyncResult<void>) => void) : NetSocket;

  /**
   *  Same as {@link #sendFile(String, long, long)} but also takes a handler that will be called when the send has completed or
   *  a failure has occurred
   * @param filename  file name of the file to send
   * @param offset offset
   * @param length length
   * @param resultHandler  handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendFile(filename: string, offset: number, length: number, resultHandler: (result: AsyncResult<void>) => void) : NetSocket;

  /**
   * 
   * @return the remote address for this socket
   * 
   */
  remoteAddress() : SocketAddress;

  /**
   * 
   * @return the local address for this socket
   * 
   */
  localAddress() : SocketAddress;

  /**
   *  Calls {@link #close()}
   * 
   */
  end() : void;

  /**
   *  Close the NetSocket
   * 
   */
  close() : void;

  /**
   *  Set a handler that will be called when the NetSocket is closed
   * @param handler  the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  closeHandler(handler: (result: void) => void | null | undefined) : NetSocket;

  /**
   *  Upgrade channel to use SSL/TLS. Be aware that for this to work SSL must be configured.
   * @param handler  the handler will be notified when it's upgraded
   * @return a reference to this, so the API can be used fluently
   * 
   */
  upgradeToSsl(handler: (result: void) => void) : NetSocket;

  /**
   *  Upgrade channel to use SSL/TLS. Be aware that for this to work SSL must be configured.
   * @param serverName the server name
   * @param handler  the handler will be notified when it's upgraded
   * @return a reference to this, so the API can be used fluently
   * 
   */
  upgradeToSsl(serverName: string, handler: (result: void) => void) : NetSocket;

  /**
   * 
   * @return true if this {@link io.vertx.core.net.NetSocket} is encrypted via SSL/TLS.
   * 
   */
  isSsl() : boolean;

  /**
   *  Returns the SNI server name presented during the SSL handshake by the client.
   * @return the indicated server name
   * 
   */
  indicatedServerName() : string;

}


export class Pump {
  /**
   *  Create a new {@code Pump} with the given {@code ReadStream} and {@code WriteStream}
   * @param rs  the read stream
   * @param ws  the write stream
   * @return the pump
   * 
   */
  static pump(rs: ReadStream, ws: WriteStream) : Pump;

  /**
   *  Create a new {@code Pump} with the given {@code ReadStream} and {@code WriteStream} and
   *  {@code writeQueueMaxSize}
   * @param rs  the read stream
   * @param ws  the write stream
   * @param writeQueueMaxSize  the max size of the write queue
   * @return the pump
   * 
   */
  static pump(rs: ReadStream, ws: WriteStream, writeQueueMaxSize: number) : Pump;

  /**
   *  Set the write queue max size to {@code maxSize}
   * @param maxSize  the max size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWriteQueueMaxSize(maxSize: number) : Pump;

  /**
   *  Start the Pump. The Pump can be started and stopped multiple times.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  start() : Pump;

  /**
   *  Stop the Pump. The Pump can be started and stopped multiple times.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  stop() : Pump;

  /**
   *  Return the total number of items pumped by this pump.
   * 
   */
  numberPumped() : number;

}


export interface ReadStream {
  /**
   *  Set an exception handler on the read stream.
   * @param handler  the exception handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(handler: (result: Error) => void | null | undefined) : ReadStream;

  /**
   *  Set a data handler. As data is read, the handler will be called with the data.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  handler(handler: (result: any) => void | null | undefined) : ReadStream;

  /**
   *  Pause the {@code ReadSupport}. While it's paused, no data will be sent to the {@code dataHandler}
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pause() : ReadStream;

  /**
   *  Resume reading. If the {@code ReadSupport} has been paused, reading will recommence on it.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  resume() : ReadStream;

  /**
   *  Set an end handler. Once the stream has ended, and there is no more data to be read, this handler will be called.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  endHandler(endHandler: (result: void) => void | null | undefined) : ReadStream;

}


export class RecordParser {
  setOutput(output: (result: Buffer) => void) : void;

  /**
   *  Like {@link #newDelimited(String)} but set the {@code output} that will receive whole records
   *  which have been parsed.
   * @param delim  the initial delimiter string
   * @param output  handler that will receive the output
   * 
   */
  static newDelimited(delim: string, output: (result: Buffer) => void) : RecordParser;

  /**
   *  Like {@link #newDelimited(String)} but wraps the {@code stream}. The {@code stream} handlers will be set/unset
   *  when the {@link #handler(Handler)} is set.
   *  <p/>
   *  The {@code pause()}/{@code resume()} operations are propagated to the {@code stream}.
   * @param delim  the initial delimiter string
   * @param stream  the wrapped stream
   * 
   */
  static newDelimited(delim: string, stream: ReadStream) : RecordParser;

  /**
   *  Create a new {@code RecordParser} instance, initially in delimited mode, and where the delimiter can be represented
   *  by the String {@code} delim endcoded in latin-1 . Don't use this if your String contains other than latin-1 characters.
   *  <p>
   *  {@code output} Will receive whole records which have been parsed.
   * @param delim  the initial delimiter string
   * 
   */
  static newDelimited(delim: string) : RecordParser;

  /**
   *  Create a new {@code RecordParser} instance, initially in delimited mode, and where the delimiter can be represented
   *  by the {@code Buffer} delim.
   *  <p>
   * @param delim  the initial delimiter buffer
   * 
   */
  static newDelimited(delim: Buffer) : RecordParser;

  /**
   *  Like {@link #newDelimited(Buffer)} but set the {@code output} that will receive whole records
   *  which have been parsed.
   * @param delim  the initial delimiter buffer
   * @param output  handler that will receive the output
   * 
   */
  static newDelimited(delim: Buffer, output: (result: Buffer) => void) : RecordParser;

  /**
   *  Like {@link #newDelimited(Buffer)} but wraps the {@code stream}. The {@code stream} handlers will be set/unset
   *  when the {@link #handler(Handler)} is set.
   *  <p/>
   *  The {@code pause()}/{@code resume()} operations are propagated to the {@code stream}.
   * @param delim  the initial delimiter buffer
   * @param stream  the wrapped stream
   * 
   */
  static newDelimited(delim: Buffer, stream: ReadStream) : RecordParser;

  /**
   *  Create a new {@code RecordParser} instance, initially in fixed size mode, and where the record size is specified
   *  by the {@code size} parameter.
   *  <p>
   *  {@code output} Will receive whole records which have been parsed.
   * @param size  the initial record size
   * 
   */
  static newFixed(size: number) : RecordParser;

  /**
   *  Like {@link #newFixed(int)} but set the {@code output} that will receive whole records
   *  which have been parsed.
   * @param size  the initial record size
   * @param output  handler that will receive the output
   * 
   */
  static newFixed(size: number, output: (result: Buffer) => void) : RecordParser;

  /**
   *  Like {@link #newFixed(int)} but wraps the {@code stream}. The {@code stream} handlers will be set/unset
   *  when the {@link #handler(Handler)} is set.
   *  <p/>
   *  The {@code pause()}/{@code resume()} operations are propagated to the {@code stream}.
   * @param size  the initial record size
   * @param stream  the wrapped stream
   * 
   */
  static newFixed(size: number, stream: ReadStream) : RecordParser;

  /**
   *  Flip the parser into delimited mode, and where the delimiter can be represented
   *  by the String {@code delim} encoded in latin-1 . Don't use this if your String contains other than latin-1 characters.
   *  <p>
   *  This method can be called multiple times with different values of delim while data is being parsed.
   * @param delim  the new delimeter
   * 
   */
  delimitedMode(delim: string) : void;

  /**
   *  Flip the parser into delimited mode, and where the delimiter can be represented
   *  by the delimiter {@code delim}.
   *  <p>
   *  This method can be called multiple times with different values of delim while data is being parsed.
   * @param delim  the new delimiter
   * 
   */
  delimitedMode(delim: Buffer) : void;

  /**
   *  Flip the parser into fixed size mode, where the record size is specified by {@code size} in bytes.
   *  <p>
   *  This method can be called multiple times with different values of size while data is being parsed.
   * @param size  the new record size
   * 
   */
  fixedSizeMode(size: number) : void;

  /**
   *  This method is called to provide the parser with data.
   * @param buffer  a chunk of data
   * 
   */
  handle(buffer: Buffer) : void;

  exceptionHandler(handler: (result: Error) => void | null | undefined) : RecordParser;

  handler(handler: (result: Buffer) => void | null | undefined) : RecordParser;

  pause() : RecordParser;

  resume() : RecordParser;

  endHandler(endHandler: (result: void) => void | null | undefined) : RecordParser;

}

import { PemKeyCertOptions } from './options';
import { PemTrustOptions } from './options';

export class SelfSignedCertificate {
  /**
   *  Provides the {@link KeyCertOptions} RSA private key file in PEM format corresponding to the {@link #privateKeyPath()}
   * @return a {@link PemKeyCertOptions} based on the generated certificate.
   * 
   */
  keyCertOptions() : PemKeyCertOptions;

  /**
   *  Provides the {@link TrustOptions} X.509 certificate file in PEM format corresponding to the {@link #certificatePath()}
   * @return a {@link PemTrustOptions} based on the generated certificate.
   * 
   */
  trustOptions() : PemTrustOptions;

  /**
   *  Filesystem path to the RSA private key file in PEM format
   * @return the absolute path to the private key.
   * 
   */
  privateKeyPath() : string;

  /**
   *  Filesystem path to the X.509 certificate file in PEM format .
   * @return the absolute path to the certificate.
   * 
   */
  certificatePath() : string;

  /**
   *  Delete the private key and certificate files.
   * 
   */
  delete() : void;

  /**
   *  Create a new {@code SelfSignedCertificate} instance.
   * @return a new instance.
   * 
   */
  static create() : SelfSignedCertificate;

  /**
   *  Create a new {@code SelfSignedCertificate} instance with a fully-qualified domain name,
   * @param fqdn a fully qualified domain name.
   * @return a new instance.
   * 
   */
  static create(fqdn: string) : SelfSignedCertificate;

}


export class SendContext {
  /**
   * 
   * @return  The message being sent
   * 
   */
  message() : Message;

  /**
   *  Call the next interceptor
   * 
   */
  next() : void;

  /**
   * 
   * @return true if the message is being sent (point to point) or False if the message is being published
   * 
   */
  send() : boolean;

  /**
   * 
   * @return the value sent or published (before being processed by the codec)
   * 
   */
  sentBody() : Object;

}


export class ServerWebSocket {
  /**
   *  Same as {@link #end()} but writes some data to the stream before ending.
   * 
   */
  end(t: Buffer) : void;

  /**
   *  This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  /**
   *  When a {@code Websocket} is created it automatically registers an event handler with the event bus - the ID of that
   *  handler is given by this method.
   *  <p>
   *  Given this ID, a different event loop can send a binary frame to that event handler using the event bus and
   *  that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   *  allows you to write data to other WebSockets which are owned by different event loops.
   * @return the binary handler id
   * 
   */
  binaryHandlerID() : string;

  /**
   *  When a {@code Websocket} is created it automatically registers an event handler with the eventbus, the ID of that
   *  handler is given by {@code textHandlerID}.
   *  <p>
   *  Given this ID, a different event loop can send a text frame to that event handler using the event bus and
   *  that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   *  allows you to write data to other WebSockets which are owned by different event loops.
   * 
   */
  textHandlerID() : string;

  /**
   *  Returns the websocket sub protocol selected by the websocket handshake.
   *  <p/>
   *  On the server, the value will be {@code null} when the handler receives the websocket callback as the
   *  handshake will not be completed yet.
   * 
   */
  subProtocol() : string;

  /**
   *  Writes a (potentially large) piece of text data to the connection. This data might be written as multiple frames
   *  if it exceeds the maximum WebSocket frame size.
   * @param text  the data to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeTextMessage(text: string) : WebSocketBase;

  /**
   *  Writes a ping to the connection. This will be written in a single frame. Ping frames may be at most 125 bytes (octets).
   *  <p>
   *  This method should not be used to write application data and should only be used for implementing a keep alive or
   *  to ensure the client is still responsive, see RFC 6455 Section 5.5.2.
   *  <p>
   *  There is no pingHandler because RFC 6455 section 5.5.2 clearly states that the only response to a ping is a pong
   *  with identical contents.
   * @param data the data to write, may be at most 125 bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writePing(data: Buffer) : WebSocketBase;

  /**
   *  Writes a pong to the connection. This will be written in a single frame. Pong frames may be at most 125 bytes (octets).
   *  <p>
   *  This method should not be used to write application data and should only be used for implementing a keep alive or
   *  to ensure the client is still responsive, see RFC 6455 Section 5.5.2.
   *  <p>
   *  There is no need to manually write a Pong, as the server and client both handle responding to a ping with a pong
   *  automatically and this is exposed to users.RFC 6455 Section 5.5.3 states that pongs may be sent unsolicited in order
   *  to implement a one way heartbeat.
   * @param data the data to write, may be at most 125 bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writePong(data: Buffer) : WebSocketBase;

  /**
   *  Set a text message handler on the connection. This handler will be called similar to the
   *  {@link #binaryMessageHandler(Handler)}, but the buffer will be converted to a String first
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  textMessageHandler(handler: (result: string) => void | null | undefined) : WebSocketBase;

  /**
   *  Set a binary message handler on the connection. This handler serves a similar purpose to {@link #handler(Handler)}
   *  except that if a message comes into the socket in multiple frames, the data from the frames will be aggregated
   *  into a single buffer before calling the handler (using {@link WebSocketFrame#isFinal()} to find the boundaries).
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  binaryMessageHandler(handler: (result: Buffer) => void | null | undefined) : WebSocketBase;

  /**
   *  Set a pong message handler on the connection.  This handler will be invoked every time a pong message is received
   *  on the server, and can be used by both clients and servers since the RFC 6455 Sections 5.5.2 and 5.5.3 do not
   *  specify whether the client or server sends a ping.
   *  <p>
   *  Pong frames may be at most 125 bytes (octets).
   *  <p>
   *  There is no ping handler since pings should immediately be responded to with a pong with identical content
   *  <p>
   *  Pong frames may be received unsolicited.
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pongHandler(handler: (result: Buffer) => void | null | undefined) : WebSocketBase;

  /**
   *  Calls {@link #close()}
   * 
   */
  end() : void;

  /**
   *  Close the WebSocket.
   * 
   */
  close() : void;

  close(statusCode: number) : void;

  close(statusCode: number, reason: string | null | undefined) : void;

  /**
   * 
   * @return the remote address for this socket
   * 
   */
  remoteAddress() : SocketAddress;

  /**
   * 
   * @return the local address for this socket
   * 
   */
  localAddress() : SocketAddress;

  /**
   * 
   * @return true if this {@link io.vertx.core.http.HttpConnection} is encrypted via SSL/TLS.
   * 
   */
  isSsl() : boolean;

  exceptionHandler(handler: (result: Error) => void | null | undefined) : ServerWebSocket;

  handler(handler: (result: Buffer) => void | null | undefined) : ServerWebSocket;

  pause() : ServerWebSocket;

  resume() : ServerWebSocket;

  endHandler(endHandler: (result: void) => void | null | undefined) : ServerWebSocket;

  write(data: Buffer) : ServerWebSocket;

  setWriteQueueMaxSize(maxSize: number) : ServerWebSocket;

  drainHandler(handler: (result: void) => void | null | undefined) : ServerWebSocket;

  writeFrame(frame: WebSocketFrame) : ServerWebSocket;

  writeFinalTextFrame(text: string) : ServerWebSocket;

  writeFinalBinaryFrame(data: Buffer) : ServerWebSocket;

  writeBinaryMessage(data: Buffer) : ServerWebSocket;

  closeHandler(handler: (result: void) => void | null | undefined) : ServerWebSocket;

  frameHandler(handler: (result: WebSocketFrame) => void | null | undefined) : ServerWebSocket;

  uri() : string;

  /**
   * 
   * @return the WebSocket handshake path.
   * 
   */
  path() : string;

  /**
   * 
   * @return the WebSocket handshake query string.
   * 
   */
  query() : string | null;

  /**
   * 
   * @return the headers in the WebSocket handshake
   * 
   */
  headers() : MultiMap;

  /**
   *  Accept the WebSocket and terminate the WebSocket handshake.
   *  <p/>
   *  This method should be called from the websocket handler to explicitely accept the websocker and
   *  terminate the WebSocket handshake.
   * 
   */
  accept() : void;

  /**
   *  Reject the WebSocket.
   *  <p>
   *  Calling this method from the websocket handler when it is first passed to you gives you the opportunity to reject
   *  the websocket, which will cause the websocket handshake to fail by returning
   *  a {@literal 502} response code.
   *  <p>
   *  You might use this method, if for example you only want to accept WebSockets with a particular path.
   * 
   */
  reject() : void;

  /**
   *  Like {@link #reject()} but with a {@code status}.
   * 
   */
  reject(status: number) : void;

}


export class SharedData {
  /**
   *  Get the cluster wide map with the specified name. The map is accessible to all nodes in the cluster and data
   *  put into the map from any node is visible to to any other node.
   * @param name  the name of the map
   * @param resultHandler  the map will be returned asynchronously in this handler
   * @throws IllegalStateException if the parent {@link io.vertx.core.Vertx} instance is not clustered
   * 
   */
  getClusterWideMap(name: string, resultHandler: (result: AsyncResult<AsyncMap>) => void) : void;

  /**
   *  Get the {@link AsyncMap} with the specified name. When clustered, the map is accessible to all nodes in the cluster
   *  and data put into the map from any node is visible to to any other node.
   *  <p>
   *    <strong>WARNING</strong>: In clustered mode, asynchronous shared maps rely on distributed data structures provided by the cluster manager.
   *    Beware that the latency relative to asynchronous shared maps operations can be much higher in clustered than in local mode.
   *  </p>
   * @param name the name of the map
   * @param resultHandler the map will be returned asynchronously in this handler
   * 
   */
  getAsyncMap(name: string, resultHandler: (result: AsyncResult<AsyncMap>) => void) : void;

  /**
   *  Get an asynchronous lock with the specified name. The lock will be passed to the handler when it is available.
   * @param name  the name of the lock
   * @param resultHandler  the handler
   * 
   */
  getLock(name: string, resultHandler: (result: AsyncResult<Lock>) => void) : void;

  /**
   *  Like {@link #getLock(String, Handler)} but specifying a timeout. If the lock is not obtained within the timeout
   *  a failure will be sent to the handler
   * @param name  the name of the lock
   * @param timeout  the timeout in ms
   * @param resultHandler  the handler
   * 
   */
  getLockWithTimeout(name: string, timeout: number, resultHandler: (result: AsyncResult<Lock>) => void) : void;

  /**
   *  Get an asynchronous counter. The counter will be passed to the handler.
   * @param name  the name of the counter.
   * @param resultHandler  the handler
   * 
   */
  getCounter(name: string, resultHandler: (result: AsyncResult<Counter>) => void) : void;

  /**
   *  Return a {@code LocalMap} with the specific {@code name}.
   * @param name  the name of the map
   * @return the msp
   * 
   */
  getLocalMap(name: string) : LocalMap;

}


export class SocketAddress {
  /**
   *  Create a inet socket address, {@code host} must be non {@code null} and {@code port} must be between {@code 0}
   *  and {@code 65536}.
   * @param port the address port
   * @param host the address host
   * @return the created socket address
   * 
   */
  static inetSocketAddress(port: number, host: string) : SocketAddress;

  /**
   *  Create a domain socket address.
   * @param path the address path
   * @return the created socket address
   * 
   */
  static domainSocketAddress(path: string) : SocketAddress;

  /**
   * 
   * @return the address host or {@code null} for a domain socket
   * 
   */
  host() : string;

  /**
   * 
   * @return the address port or {@code -1} for a domain socket
   * 
   */
  port() : number;

  /**
   * 
   * @return the address path or {@code null} for a inet socket
   * 
   */
  path() : string;

}


export class SrvRecord {
  /**
   *  Returns the priority for this service record.
   * 
   */
  priority() : number;

  /**
   *  Returns the weight of this service record.
   * 
   */
  weight() : number;

  /**
   *  Returns the port the service is running on.
   * 
   */
  port() : number;

  /**
   *  Returns the name for the server being queried.
   * 
   */
  name() : string;

  /**
   *  Returns the protocol for the service being queried (i.e. "_tcp").
   * 
   */
  protocol() : string;

  /**
   *  Returns the service's name (i.e. "_http").
   * 
   */
  service() : string;

  /**
   *  Returns the name of the host for the service.
   * 
   */
  target() : string | null;

}


export interface StreamBase {
  /**
   *  Set an exception handler.
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(handler: (result: Error) => void | null | undefined) : StreamBase;

}


export class TimeoutStream {
  exceptionHandler(handler: (result: Error) => void | null | undefined) : TimeoutStream;

  handler(handler: (result: number) => void | null | undefined) : TimeoutStream;

  pause() : TimeoutStream;

  resume() : TimeoutStream;

  endHandler(endHandler: (result: void) => void | null | undefined) : TimeoutStream;

  /**
   *  Cancels the timeout. Note this has the same effect as calling {@link #handler(Handler)} with a null
   *  argument.
   * 
   */
  cancel() : void;

}

import { NetServerOptions } from './options';
import { DeploymentOptions } from './options';
import { DnsClientOptions } from './options';
import { VertxOptions } from './options';
import { HttpServerOptions } from './options';
import { HttpClientOptions } from './options';
import { DatagramSocketOptions } from './options';
import { NetClientOptions } from './options';

export class Vertx {
  /**
   *  Whether the metrics are enabled for this measured object
   * @return true if the metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

  /**
   *  Creates a non clustered instance using default options.
   * @return the instance
   * 
   */
  static vertx() : Vertx;

  /**
   *  Creates a non clustered instance using the specified options
   * @param options  the options to use
   * @return the instance
   * 
   */
  static vertx(options: VertxOptions) : Vertx;

  /**
   *  Creates a clustered instance using the specified options.
   *  <p>
   *  The instance is created asynchronously and the resultHandler is called with the result when it is ready.
   * @param options  the options to use
   * @param resultHandler  the result handler that will receive the result
   * 
   */
  static clusteredVertx(options: VertxOptions, resultHandler: (result: AsyncResult<Vertx>) => void) : void;

  /**
   *  Gets the current context
   * @return The current context or null if no current context
   * 
   */
  static currentContext() : Context | null;

  /**
   *  Gets the current context, or creates one if there isn't one
   * @return The current context (created if didn't exist)
   * 
   */
  getOrCreateContext() : Context;

  /**
   *  Create a TCP/SSL server using the specified options
   * @param options  the options to use
   * @return the server
   * 
   */
  createNetServer(options: NetServerOptions) : NetServer;

  /**
   *  Create a TCP/SSL server using default options
   * @return the server
   * 
   */
  createNetServer() : NetServer;

  /**
   *  Create a TCP/SSL client using the specified options
   * @param options  the options to use
   * @return the client
   * 
   */
  createNetClient(options: NetClientOptions) : NetClient;

  /**
   *  Create a TCP/SSL client using default options
   * @return the client
   * 
   */
  createNetClient() : NetClient;

  /**
   *  Create an HTTP/HTTPS server using the specified options
   * @param options  the options to use
   * @return the server
   * 
   */
  createHttpServer(options: HttpServerOptions) : HttpServer;

  /**
   *  Create an HTTP/HTTPS server using default options
   * @return the server
   * 
   */
  createHttpServer() : HttpServer;

  /**
   *  Create a HTTP/HTTPS client using the specified options
   * @param options  the options to use
   * @return the client
   * 
   */
  createHttpClient(options: HttpClientOptions) : HttpClient;

  /**
   *  Create a HTTP/HTTPS client using default options
   * @return the client
   * 
   */
  createHttpClient() : HttpClient;

  /**
   *  Create a datagram socket using the specified options
   * @param options  the options to use
   * @return the socket
   * 
   */
  createDatagramSocket(options: DatagramSocketOptions) : DatagramSocket;

  /**
   *  Create a datagram socket using default options
   * @return the socket
   * 
   */
  createDatagramSocket() : DatagramSocket;

  /**
   *  Get the filesystem object. There is a single instance of FileSystem per Vertx instance.
   * @return the filesystem object
   * 
   */
  fileSystem() : FileSystem;

  /**
   *  Get the event bus object. There is a single instance of EventBus per Vertx instance.
   * @return the event bus object
   * 
   */
  eventBus() : EventBus;

  /**
   *  Create a DNS client to connect to a DNS server at the specified host and port, with the default query timeout (5 seconds)
   *  <p/>
   * @param port  the port
   * @param host  the host
   * @return the DNS client
   * 
   */
  createDnsClient(port: number, host: string) : DnsClient;

  /**
   *  Create a DNS client to connect to the DNS server configured by {@link VertxOptions#getAddressResolverOptions()}
   *  <p>
   *  DNS client takes the first configured resolver address provided by {@link DnsResolverProvider#nameServerAddresses()}}
   * @return the DNS client
   * 
   */
  createDnsClient() : DnsClient;

  /**
   *  Create a DNS client to connect to a DNS server
   * @param options the client options
   * @return the DNS client
   * 
   */
  createDnsClient(options: DnsClientOptions) : DnsClient;

  /**
   *  Get the shared data object. There is a single instance of SharedData per Vertx instance.
   * @return the shared data object
   * 
   */
  sharedData() : SharedData;

  /**
   *  Set a one-shot timer to fire after {@code delay} milliseconds, at which point {@code handler} will be called with
   *  the id of the timer.
   * @param delay  the delay in milliseconds, after which the timer will fire
   * @param handler  the handler that will be called with the timer ID when the timer fires
   * @return the unique ID of the timer
   * 
   */
  setTimer(delay: number, handler: (result: number) => void) : number;

  /**
   *  Returns a one-shot timer as a read stream. The timer will be fired after {@code delay} milliseconds after
   *  the {@link ReadStream#handler} has been called.
   * @param delay  the delay in milliseconds, after which the timer will fire
   * @return the timer stream
   * 
   */
  timerStream(delay: number) : TimeoutStream;

  /**
   *  Set a periodic timer to fire every {@code delay} milliseconds, at which point {@code handler} will be called with
   *  the id of the timer.
   * @param delay  the delay in milliseconds, after which the timer will fire
   * @param handler  the handler that will be called with the timer ID when the timer fires
   * @return the unique ID of the timer
   * 
   */
  setPeriodic(delay: number, handler: (result: number) => void) : number;

  /**
   *  Returns a periodic timer as a read stream. The timer will be fired every {@code delay} milliseconds after
   *  the {@link ReadStream#handler} has been called.
   * @param delay  the delay in milliseconds, after which the timer will fire
   * @return the periodic stream
   * 
   */
  periodicStream(delay: number) : TimeoutStream;

  /**
   *  Cancels the timer with the specified {@code id}.
   * @param id  The id of the timer to cancel
   * @return true if the timer was successfully cancelled, or false if the timer does not exist.
   * 
   */
  cancelTimer(id: number) : boolean;

  /**
   *  Puts the handler on the event queue for the current context so it will be run asynchronously ASAP after all
   *  preceeding events have been handled.
   * @param action - a handler representing the action to execute
   * 
   */
  runOnContext(action: (result: void) => void) : void;

  /**
   *  Stop the the Vertx instance and release any resources held by it.
   *  <p>
   *  The instance cannot be used after it has been closed.
   *  <p>
   *  The actual close is asynchronous and may not complete until after the call has returned.
   * 
   */
  close() : void;

  /**
   *  Like {@link #close} but the completionHandler will be called when the close is complete
   * @param completionHandler  The handler will be notified when the close is complete.
   * 
   */
  close(completionHandler: (result: AsyncResult<void>) => void) : void;

  /**
   *  Deploy a verticle instance given a name.
   *  <p>
   *  Given the name, Vert.x selects a {@link VerticleFactory} instance to use to instantiate the verticle.
   *  <p>
   *  For the rules on how factories are selected please consult the user manual.
   * @param name  the name.
   * 
   */
  deployVerticle(name: string) : void;

  /**
   *  Like {@link #deployVerticle(String)} but the completionHandler will be notified when the deployment is complete.
   *  <p>
   *  If the deployment is successful the result will contain a String representing the unique deployment ID of the
   *  deployment.
   *  <p>
   *  This deployment ID can subsequently be used to undeploy the verticle.
   * @param name  The identifier
   * @param completionHandler  a handler which will be notified when the deployment is complete
   * 
   */
  deployVerticle(name: string, completionHandler: (result: AsyncResult<string>) => void) : void;

  /**
   *  Like {@link #deployVerticle(Verticle)} but {@link io.vertx.core.DeploymentOptions} are provided to configure the
   *  deployment.
   * @param name  the name
   * @param options  the deployment options.
   * 
   */
  deployVerticle(name: string, options: DeploymentOptions) : void;

  /**
   *  Like {@link #deployVerticle(String, Handler)} but {@link io.vertx.core.DeploymentOptions} are provided to configure the
   *  deployment.
   * @param name  the name
   * @param options  the deployment options.
   * @param completionHandler  a handler which will be notified when the deployment is complete
   * 
   */
  deployVerticle(name: string, options: DeploymentOptions, completionHandler: (result: AsyncResult<string>) => void) : void;

  /**
   *  Undeploy a verticle deployment.
   *  <p>
   *  The actual undeployment happens asynchronously and may not complete until after the method has returned.
   * @param deploymentID  the deployment ID
   * 
   */
  undeploy(deploymentID: string) : void;

  /**
   *  Like {@link #undeploy(String) } but the completionHandler will be notified when the undeployment is complete.
   * @param deploymentID  the deployment ID
   * @param completionHandler  a handler which will be notified when the undeployment is complete
   * 
   */
  undeploy(deploymentID: string, completionHandler: (result: AsyncResult<void>) => void) : void;

  /**
   *  Return a Set of deployment IDs for the currently deployed deploymentIDs.
   * @return Set of deployment IDs
   * 
   */
  deploymentIDs() : string[];

  /**
   *  Is this Vert.x instance clustered?
   * @return true if clustered
   * 
   */
  isClustered() : boolean;

  /**
   *  Safely execute some blocking code.
   *  <p>
   *  Executes the blocking code in the handler {@code blockingCodeHandler} using a thread from the worker pool.
   *  <p>
   *  When the code is complete the handler {@code resultHandler} will be called with the result on the original context
   *  (e.g. on the original event loop of the caller).
   *  <p>
   *  A {@code Future} instance is passed into {@code blockingCodeHandler}. When the blocking code successfully completes,
   *  the handler should call the {@link Future#complete} or {@link Future#complete(Object)} method, or the {@link Future#fail}
   *  method if it failed.
   *  <p>
   *  In the {@code blockingCodeHandler} the current context remains the original context and therefore any task
   *  scheduled in the {@code blockingCodeHandler} will be executed on the this context and not on the worker thread.
   * @param blockingCodeHandler  handler representing the blocking code to run
   * @param resultHandler  handler that will be called when the blocking code is complete
   * @param ordered  if true then if executeBlocking is called several times on the same context, the executions
   *                  for that context will be executed serially, not in parallel. if false then they will be no ordering
   *                  guarantees
   * @param <T> the type of the result
   * 
   */
  executeBlocking(blockingCodeHandler: (result: Future) => void, ordered: boolean, resultHandler: (result: AsyncResult<any>) => void) : void;

  /**
   *  Like {@link #executeBlocking(Handler, boolean, Handler)} called with ordered = true.
   * 
   */
  executeBlocking(blockingCodeHandler: (result: Future) => void, resultHandler: (result: AsyncResult<any>) => void) : void;

  /**
   *  Like {@link #createSharedWorkerExecutor(String, int)} but with the {@link VertxOptions#setWorkerPoolSize} {@code poolSize}.
   * 
   */
  createSharedWorkerExecutor(name: string) : WorkerExecutor;

  /**
   *  Like {@link #createSharedWorkerExecutor(String, int, long)} but with the {@link VertxOptions#setMaxWorkerExecuteTime} {@code maxExecuteTime}.
   * 
   */
  createSharedWorkerExecutor(name: string, poolSize: number) : WorkerExecutor;

  /**
   *  Create a named worker executor, the executor should be closed when it's not needed anymore to release
   *  resources.<p/>
   * 
   *  This method can be called mutiple times with the same {@code name}. Executors with the same name will share
   *  the same worker pool. The worker pool size and max execute time are set when the worker pool is created and
   *  won't change after.<p>
   * 
   *  The worker pool is released when all the {@link WorkerExecutor} sharing the same name are closed.
   * @param name the name of the worker executor
   * @param poolSize the size of the pool
   * @param maxExecuteTime the value of max worker execute time, in ns
   * @return the named worker executor
   * 
   */
  createSharedWorkerExecutor(name: string, poolSize: number, maxExecuteTime: number) : WorkerExecutor;

  /**
   * 
   * @return wether the native transport is used
   * 
   */
  isNativeTransportEnabled() : boolean;

  /**
   *  Set a default exception handler for {@link Context}, set on {@link Context#exceptionHandler(Handler)} at creation.
   * @param handler the exception handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(handler: (result: Error) => void | null | undefined) : Vertx;

}


export class WebSocket {
  /**
   *  Same as {@link #end()} but writes some data to the stream before ending.
   * 
   */
  end(t: Buffer) : void;

  /**
   *  This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  /**
   *  When a {@code Websocket} is created it automatically registers an event handler with the event bus - the ID of that
   *  handler is given by this method.
   *  <p>
   *  Given this ID, a different event loop can send a binary frame to that event handler using the event bus and
   *  that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   *  allows you to write data to other WebSockets which are owned by different event loops.
   * @return the binary handler id
   * 
   */
  binaryHandlerID() : string;

  /**
   *  When a {@code Websocket} is created it automatically registers an event handler with the eventbus, the ID of that
   *  handler is given by {@code textHandlerID}.
   *  <p>
   *  Given this ID, a different event loop can send a text frame to that event handler using the event bus and
   *  that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   *  allows you to write data to other WebSockets which are owned by different event loops.
   * 
   */
  textHandlerID() : string;

  /**
   *  Returns the websocket sub protocol selected by the websocket handshake.
   *  <p/>
   *  On the server, the value will be {@code null} when the handler receives the websocket callback as the
   *  handshake will not be completed yet.
   * 
   */
  subProtocol() : string;

  /**
   *  Writes a ping to the connection. This will be written in a single frame. Ping frames may be at most 125 bytes (octets).
   *  <p>
   *  This method should not be used to write application data and should only be used for implementing a keep alive or
   *  to ensure the client is still responsive, see RFC 6455 Section 5.5.2.
   *  <p>
   *  There is no pingHandler because RFC 6455 section 5.5.2 clearly states that the only response to a ping is a pong
   *  with identical contents.
   * @param data the data to write, may be at most 125 bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writePing(data: Buffer) : WebSocketBase;

  /**
   *  Writes a pong to the connection. This will be written in a single frame. Pong frames may be at most 125 bytes (octets).
   *  <p>
   *  This method should not be used to write application data and should only be used for implementing a keep alive or
   *  to ensure the client is still responsive, see RFC 6455 Section 5.5.2.
   *  <p>
   *  There is no need to manually write a Pong, as the server and client both handle responding to a ping with a pong
   *  automatically and this is exposed to users.RFC 6455 Section 5.5.3 states that pongs may be sent unsolicited in order
   *  to implement a one way heartbeat.
   * @param data the data to write, may be at most 125 bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writePong(data: Buffer) : WebSocketBase;

  /**
   *  Set a text message handler on the connection. This handler will be called similar to the
   *  {@link #binaryMessageHandler(Handler)}, but the buffer will be converted to a String first
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  textMessageHandler(handler: (result: string) => void | null | undefined) : WebSocketBase;

  /**
   *  Set a binary message handler on the connection. This handler serves a similar purpose to {@link #handler(Handler)}
   *  except that if a message comes into the socket in multiple frames, the data from the frames will be aggregated
   *  into a single buffer before calling the handler (using {@link WebSocketFrame#isFinal()} to find the boundaries).
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  binaryMessageHandler(handler: (result: Buffer) => void | null | undefined) : WebSocketBase;

  /**
   *  Set a pong message handler on the connection.  This handler will be invoked every time a pong message is received
   *  on the server, and can be used by both clients and servers since the RFC 6455 Sections 5.5.2 and 5.5.3 do not
   *  specify whether the client or server sends a ping.
   *  <p>
   *  Pong frames may be at most 125 bytes (octets).
   *  <p>
   *  There is no ping handler since pings should immediately be responded to with a pong with identical content
   *  <p>
   *  Pong frames may be received unsolicited.
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pongHandler(handler: (result: Buffer) => void | null | undefined) : WebSocketBase;

  /**
   *  Calls {@link #close()}
   * 
   */
  end() : void;

  /**
   *  Close the WebSocket.
   * 
   */
  close() : void;

  close(statusCode: number) : void;

  close(statusCode: number, reason: string | null | undefined) : void;

  /**
   * 
   * @return the remote address for this socket
   * 
   */
  remoteAddress() : SocketAddress;

  /**
   * 
   * @return the local address for this socket
   * 
   */
  localAddress() : SocketAddress;

  /**
   * 
   * @return true if this {@link io.vertx.core.http.HttpConnection} is encrypted via SSL/TLS.
   * 
   */
  isSsl() : boolean;

  exceptionHandler(handler: (result: Error) => void | null | undefined) : WebSocket;

  handler(handler: (result: Buffer) => void | null | undefined) : WebSocket;

  pause() : WebSocket;

  resume() : WebSocket;

  endHandler(endHandler: (result: void) => void | null | undefined) : WebSocket;

  write(data: Buffer) : WebSocket;

  setWriteQueueMaxSize(maxSize: number) : WebSocket;

  drainHandler(handler: (result: void) => void | null | undefined) : WebSocket;

  writeFrame(frame: WebSocketFrame) : WebSocket;

  writeFinalTextFrame(text: string) : WebSocket;

  writeFinalBinaryFrame(data: Buffer) : WebSocket;

  writeBinaryMessage(data: Buffer) : WebSocket;

  writeTextMessage(text: string) : WebSocket;

  closeHandler(handler: (result: void) => void | null | undefined) : WebSocket;

  frameHandler(handler: (result: WebSocketFrame) => void | null | undefined) : WebSocket;

}


export interface WebSocketBase {
  /**
   *  Same as {@link #end()} but writes some data to the stream before ending.
   * 
   */
  end(t: Buffer) : void;

  /**
   *  This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  exceptionHandler(handler: (result: Error) => void | null | undefined) : WebSocketBase;

  handler(handler: (result: Buffer) => void | null | undefined) : WebSocketBase;

  pause() : WebSocketBase;

  resume() : WebSocketBase;

  endHandler(endHandler: (result: void) => void | null | undefined) : WebSocketBase;

  write(data: Buffer) : WebSocketBase;

  setWriteQueueMaxSize(maxSize: number) : WebSocketBase;

  drainHandler(handler: (result: void) => void | null | undefined) : WebSocketBase;

  /**
   *  When a {@code Websocket} is created it automatically registers an event handler with the event bus - the ID of that
   *  handler is given by this method.
   *  <p>
   *  Given this ID, a different event loop can send a binary frame to that event handler using the event bus and
   *  that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   *  allows you to write data to other WebSockets which are owned by different event loops.
   * @return the binary handler id
   * 
   */
  binaryHandlerID() : string;

  /**
   *  When a {@code Websocket} is created it automatically registers an event handler with the eventbus, the ID of that
   *  handler is given by {@code textHandlerID}.
   *  <p>
   *  Given this ID, a different event loop can send a text frame to that event handler using the event bus and
   *  that buffer will be received by this instance in its own event loop and written to the underlying connection. This
   *  allows you to write data to other WebSockets which are owned by different event loops.
   * 
   */
  textHandlerID() : string;

  /**
   *  Returns the websocket sub protocol selected by the websocket handshake.
   *  <p/>
   *  On the server, the value will be {@code null} when the handler receives the websocket callback as the
   *  handshake will not be completed yet.
   * 
   */
  subProtocol() : string;

  /**
   *  Write a WebSocket frame to the connection
   * @param frame  the frame to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeFrame(frame: WebSocketFrame) : WebSocketBase;

  /**
   *  Write a final WebSocket text frame to the connection
   * @param text  The text to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeFinalTextFrame(text: string) : WebSocketBase;

  /**
   *  Write a final WebSocket binary frame to the connection
   * @param data  The data to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeFinalBinaryFrame(data: Buffer) : WebSocketBase;

  /**
   *  Writes a (potentially large) piece of binary data to the connection. This data might be written as multiple frames
   *  if it exceeds the maximum WebSocket frame size.
   * @param data  the data to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeBinaryMessage(data: Buffer) : WebSocketBase;

  /**
   *  Writes a (potentially large) piece of text data to the connection. This data might be written as multiple frames
   *  if it exceeds the maximum WebSocket frame size.
   * @param text  the data to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writeTextMessage(text: string) : WebSocketBase;

  /**
   *  Writes a ping to the connection. This will be written in a single frame. Ping frames may be at most 125 bytes (octets).
   *  <p>
   *  This method should not be used to write application data and should only be used for implementing a keep alive or
   *  to ensure the client is still responsive, see RFC 6455 Section 5.5.2.
   *  <p>
   *  There is no pingHandler because RFC 6455 section 5.5.2 clearly states that the only response to a ping is a pong
   *  with identical contents.
   * @param data the data to write, may be at most 125 bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writePing(data: Buffer) : WebSocketBase;

  /**
   *  Writes a pong to the connection. This will be written in a single frame. Pong frames may be at most 125 bytes (octets).
   *  <p>
   *  This method should not be used to write application data and should only be used for implementing a keep alive or
   *  to ensure the client is still responsive, see RFC 6455 Section 5.5.2.
   *  <p>
   *  There is no need to manually write a Pong, as the server and client both handle responding to a ping with a pong
   *  automatically and this is exposed to users.RFC 6455 Section 5.5.3 states that pongs may be sent unsolicited in order
   *  to implement a one way heartbeat.
   * @param data the data to write, may be at most 125 bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  writePong(data: Buffer) : WebSocketBase;

  /**
   *  Set a close handler. This will be called when the WebSocket is closed.
   * @param handler  the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  closeHandler(handler: (result: void) => void | null | undefined) : WebSocketBase;

  /**
   *  Set a frame handler on the connection. This handler will be called when frames are read on the connection.
   * @param handler  the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  frameHandler(handler: (result: WebSocketFrame) => void | null | undefined) : WebSocketBase;

  /**
   *  Set a text message handler on the connection. This handler will be called similar to the
   *  {@link #binaryMessageHandler(Handler)}, but the buffer will be converted to a String first
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  textMessageHandler(handler: (result: string) => void | null | undefined) : WebSocketBase;

  /**
   *  Set a binary message handler on the connection. This handler serves a similar purpose to {@link #handler(Handler)}
   *  except that if a message comes into the socket in multiple frames, the data from the frames will be aggregated
   *  into a single buffer before calling the handler (using {@link WebSocketFrame#isFinal()} to find the boundaries).
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  binaryMessageHandler(handler: (result: Buffer) => void | null | undefined) : WebSocketBase;

  /**
   *  Set a pong message handler on the connection.  This handler will be invoked every time a pong message is received
   *  on the server, and can be used by both clients and servers since the RFC 6455 Sections 5.5.2 and 5.5.3 do not
   *  specify whether the client or server sends a ping.
   *  <p>
   *  Pong frames may be at most 125 bytes (octets).
   *  <p>
   *  There is no ping handler since pings should immediately be responded to with a pong with identical content
   *  <p>
   *  Pong frames may be received unsolicited.
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pongHandler(handler: (result: Buffer) => void | null | undefined) : WebSocketBase;

  /**
   *  Calls {@link #close()}
   * 
   */
  end() : void;

  /**
   *  Close the WebSocket.
   * 
   */
  close() : void;

  close(statusCode: number) : void;

  close(statusCode: number, reason: string | null | undefined) : void;

  /**
   * 
   * @return the remote address for this socket
   * 
   */
  remoteAddress() : SocketAddress;

  /**
   * 
   * @return the local address for this socket
   * 
   */
  localAddress() : SocketAddress;

  /**
   * 
   * @return true if this {@link io.vertx.core.http.HttpConnection} is encrypted via SSL/TLS.
   * 
   */
  isSsl() : boolean;

}


export class WebSocketFrame {
  /**
   *  Create a binary WebSocket frame.
   * @param data  the data for the frame
   * @param isFinal  true if it's the final frame in the WebSocket message
   * @return the frame
   * 
   */
  static binaryFrame(data: Buffer, isFinal: boolean) : WebSocketFrame;

  /**
   *  Create a text WebSocket frame.
   * @param str  the string for the frame
   * @param isFinal  true if it's the final frame in the WebSocket message
   * @return the frame
   * 
   */
  static textFrame(str: string, isFinal: boolean) : WebSocketFrame;

  /**
   *  Create a ping WebSocket frame.  Will be a final frame. There is no option for non final ping frames.
   * @param data the bytes for the frame, may be at most 125 bytes
   * @return the frame
   * 
   */
  static pingFrame(data: Buffer) : WebSocketFrame;

  /**
   *  Create a pong WebSocket frame.  Will be a final frame. There is no option for non final pong frames.
   * @param data the bytes for the frame, may be at most 125 bytes
   * @return the frame
   * 
   */
  static pongFrame(data: Buffer) : WebSocketFrame;

  /**
   *  Create a continuation frame
   * @param data  the data for the frame
   * @param isFinal true if it's the final frame in the WebSocket message
   * @return the frame
   * 
   */
  static continuationFrame(data: Buffer, isFinal: boolean) : WebSocketFrame;

  /**
   * 
   * @return true if it's a text frame
   * 
   */
  isText() : boolean;

  /**
   * 
   * @return true if it's a binary frame
   * 
   */
  isBinary() : boolean;

  /**
   * 
   * @return true if it's a continuation frame
   * 
   */
  isContinuation() : boolean;

  /**
   * 
   * @return true if it's close frame
   * 
   */
  isClose() : boolean;

  /**
   * 
   * @return the content of this frame as a UTF-8 string and returns the
   *  converted string. Only use this for text frames.
   * 
   */
  textData() : string;

  /**
   * 
   * @return the data of the frame
   * 
   */
  binaryData() : Buffer;

  /**
   * 
   * @return true if this is the final frame.
   * 
   */
  isFinal() : boolean;

  /**
   * 
   * @return status code of close frame. Only use this for close frames
   * 
   */
  closeStatusCode() : number;

  /**
   * 
   * @return string explaining close reason. Only use this for close frames
   * 
   */
  closeReason() : string;

}


export class WorkerExecutor {
  /**
   *  Whether the metrics are enabled for this measured object
   * @return true if the metrics are enabled
   * 
   */
  isMetricsEnabled() : boolean;

  /**
   *  Safely execute some blocking code.
   *  <p>
   *  Executes the blocking code in the handler {@code blockingCodeHandler} using a thread from the worker pool.
   *  <p>
   *  When the code is complete the handler {@code resultHandler} will be called with the result on the original context
   *  (i.e. on the original event loop of the caller).
   *  <p>
   *  A {@code Future} instance is passed into {@code blockingCodeHandler}. When the blocking code successfully completes,
   *  the handler should call the {@link Future#complete} or {@link Future#complete(Object)} method, or the {@link Future#fail}
   *  method if it failed.
   *  <p>
   *  In the {@code blockingCodeHandler} the current context remains the original context and therefore any task
   *  scheduled in the {@code blockingCodeHandler} will be executed on the this context and not on the worker thread.
   * @param blockingCodeHandler  handler representing the blocking code to run
   * @param resultHandler  handler that will be called when the blocking code is complete
   * @param ordered  if true then if executeBlocking is called several times on the same context, the executions
   *                  for that context will be executed serially, not in parallel. if false then they will be no ordering
   *                  guarantees
   * @param <T> the type of the result
   * 
   */
  executeBlocking(blockingCodeHandler: (result: Future) => void, ordered: boolean, resultHandler: (result: AsyncResult<any>) => void) : void;

  /**
   *  Like {@link #executeBlocking(Handler, boolean, Handler)} called with ordered = true.
   * 
   */
  executeBlocking(blockingCodeHandler: (result: Future) => void, resultHandler: (result: AsyncResult<any>) => void) : void;

  /**
   *  Close the executor.
   * 
   */
  close() : void;

}


export interface WriteStream {
  /**
   *  Set an exception handler on the write stream.
   * @param handler  the exception handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(handler: (result: Error) => void | null | undefined) : WriteStream;

  /**
   *  Write some data to the stream. The data is put on an internal write queue, and the write actually happens
   *  asynchronously. To avoid running out of memory by putting too much on the write queue,
   *  check the {@link #writeQueueFull} method before writing. This is done automatically if using a {@link Pump}.
   * @param data  the data to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  write(data: any) : WriteStream;

  /**
   *  Ends the stream.
   *  <p>
   *  Once the stream has ended, it cannot be used any more.
   * 
   */
  end() : void;

  /**
   *  Same as {@link #end()} but writes some data to the stream before ending.
   * 
   */
  end(t: any) : void;

  /**
   *  Set the maximum size of the write queue to {@code maxSize}. You will still be able to write to the stream even
   *  if there is more than {@code maxSize} items in the write queue. This is used as an indicator by classes such as
   *  {@code Pump} to provide flow control.
   *  <p/>
   *  The value is defined by the implementation of the stream, e.g in bytes for a
   *  {@link io.vertx.core.net.NetSocket}, the number of {@link io.vertx.core.eventbus.Message} for a
   *  {@link io.vertx.core.eventbus.MessageProducer}, etc...
   * @param maxSize  the max size of the write stream
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWriteQueueMaxSize(maxSize: number) : WriteStream;

  /**
   *  This will return {@code true} if there are more bytes in the write queue than the value set using {@link
   *  #setWriteQueueMaxSize}
   * @return true if write queue is full
   * 
   */
  writeQueueFull() : boolean;

  /**
   *  Set a drain handler on the stream. If the write queue is full, then the handler will be called when the write
   *  queue is ready to accept buffers again. See {@link Pump} for an example of this being used.
   *  <p/>
   *  The stream implementation defines when the drain handler, for example it could be when the queue size has been
   *  reduced to {@code maxSize / 2}.
   * @param handler the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  drainHandler(handler: (result: void) => void | null | undefined) : WriteStream;

}

