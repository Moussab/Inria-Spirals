import { AsyncResult } from '@vertx/core';


export class ContainerDeserializer {
  deserializeArray(serialized: string) : string[];

  deserializeObject(serialized: string) : { [key:string]: string; };

}

import { RoutingContext } from '@vertx/web';

export class CustomValidator {
  /**
   *  This function have to be <b>synchronous</b>. It doesn't return nothing if validation succedes, otherwise it
   *  throws ValidationException.
   *  <br/>
   *  <b>Don't call routingContext.next() or routingContext.fail() from this function</b>
   * @param routingContext the actual routing context
   * @throws ValidationException
   * 
   */
  validate(routingContext: RoutingContext) : void;

}


export interface HTTPOperationRequestValidationHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Function that parse the operation specification and generate validation rules
   * 
   */
  parseOperationSpec() : void;

}

import { ParameterType } from './enums';

export class HTTPRequestValidationHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Factory method to create an HTTPRequestValidationHandler
   * @return new HTTPRequestValidationHandler
   * 
   */
  static create() : HTTPRequestValidationHandler;

  /**
   *  Add a path parameter with included parameter types. All path params are <b>required</b>
   * @param parameterName expected name of parameter inside the path
   * @param type          expected type of parameter
   * @return this handler
   * 
   */
  addPathParam(parameterName: string, type: ParameterType) : HTTPRequestValidationHandler;

  /**
   *  Add a path parameter with a custom pattern. All path params are <b>required</b>
   * @param parameterName expected name of parameter inside the path
   * @param pattern       regular expression for validation
   * @return this handler
   * 
   */
  addPathParamWithPattern(parameterName: string, pattern: string) : HTTPRequestValidationHandler;

  /**
   *  Add a path parameter with a custom type validator. All path params are <b>required</b>. For more informations
   *  about how to construct built-in or custom type validator, check out {@link ParameterTypeValidator}
   * @param parameterName   expected name of parameter inside the path
   * @param validator       type validator
   * @param allowEmptyValue true if parameter allowEmptyValue. For more informations about allowEmptyValue behaviour:
   *  {@link ParameterValidationRule#allowEmptyValue()}
   * @return this handler
   * 
   */
  addPathParamWithCustomTypeValidator(parameterName: string, validator: ParameterTypeValidator, allowEmptyValue: boolean) : HTTPRequestValidationHandler;

  /**
   *  Add a query parameter with included parameter types
   * @param parameterName expected name of parameter inside the query
   * @param type          expected type of parameter
   * @param required      true if parameter is required
   * @return this handler
   * 
   */
  addQueryParam(parameterName: string, type: ParameterType, required: boolean) : HTTPRequestValidationHandler;

  /**
   *  Add a query parameter with a custom pattern
   * @param parameterName expected name of parameter inside the query
   * @param pattern       regular expression for validation
   * @param required      true if parameter is required
   * @return this handler
   * 
   */
  addQueryParamWithPattern(parameterName: string, pattern: string, required: boolean) : HTTPRequestValidationHandler;

  /**
   *  Add a query parameters array with included parameter types
   * @param arrayName expected name of array inside the query
   * @param type      expected type of parameter
   * @param required  true if parameter is required
   * @return this handler
   * 
   */
  addQueryParamsArray(arrayName: string, type: ParameterType, required: boolean) : HTTPRequestValidationHandler;

  /**
   *  Add a query parameters array with a custom pattern
   * @param arrayName expected name of array inside the query
   * @param pattern   regular expression for validation
   * @param required  true if parameter is required
   * @return this handler
   * 
   */
  addQueryParamsArrayWithPattern(arrayName: string, pattern: string, required: boolean) : HTTPRequestValidationHandler;

  /**
   *  Add a query parameter with a custom type validator. For more informations about how to construct built-in or
   *  custom type validator, check out {@link ParameterTypeValidator}
   * @param parameterName   expected name of parameter inside the query
   * @param validator       type validator
   * @param required        true if parameter is required
   * @param allowEmptyValue true if parameter allowEmptyValue. For more informations about allowEmptyValue behaviour:
   *  {@link ParameterValidationRule#allowEmptyValue()}
   * @return this handler
   * 
   */
  addQueryParamWithCustomTypeValidator(parameterName: string, validator: ParameterTypeValidator, required: boolean, allowEmptyValue: boolean) : HTTPRequestValidationHandler;

  /**
   *  Add a header parameter with included parameter types
   * @param headerName expected header name
   * @param type       expected type of parameter
   * @param required   true if parameter is required
   * @return this handler
   * 
   */
  addHeaderParam(headerName: string, type: ParameterType, required: boolean) : HTTPRequestValidationHandler;

  /**
   *  Add a header parameter with a custom pattern
   * @param headerName expected header name
   * @param pattern    regular expression for validation
   * @param required   true if parameter is required
   * @return this handler
   * 
   */
  addHeaderParamWithPattern(headerName: string, pattern: string, required: boolean) : HTTPRequestValidationHandler;

  /**
   *  Add a header parameter with a custom type validator. For more informations about how to construct built-in or
   *  custom type validator, check out {@link ParameterTypeValidator}
   * @param headerName      expected header namery
   * @param validator       type validator
   * @param required        true if parameter is required
   * @param allowEmptyValue true if parameter allowEmptyValue. For more informations about allowEmptyValue behaviour:
   *  {@link ParameterValidationRule#allowEmptyValue()}
   * @return this handler
   * 
   */
  addHeaderParamWithCustomTypeValidator(headerName: string, validator: ParameterTypeValidator, required: boolean, allowEmptyValue: boolean) : HTTPRequestValidationHandler;

  /**
   *  Add a single parameter inside a form with included parameter types
   * @param parameterName expected name of parameter inside the form
   * @param type          expected type of parameter
   * @param required      true if parameter is required
   * @return this handler
   * 
   */
  addFormParam(parameterName: string, type: ParameterType, required: boolean) : HTTPRequestValidationHandler;

  /**
   *  Add a single parameter inside a form with a custom pattern
   * @param parameterName expected name of parameter inside the form
   * @param pattern       regular expression for validation
   * @param required      true if parameter is required
   * @return this handler
   * 
   */
  addFormParamWithPattern(parameterName: string, pattern: string, required: boolean) : HTTPRequestValidationHandler;

  /**
   *  Add a form parameters array with included parameter types
   * @param parameterName expected name of array of parameters inside the form
   * @param type          expected type of array of parameters
   * @param required      true if parameter is required
   * @return this handler
   * 
   */
  addFormParamsArray(parameterName: string, type: ParameterType, required: boolean) : HTTPRequestValidationHandler;

  /**
   *  Add a form parameters array with a custom pattern
   * @param parameterName expected name of array of parameters inside the form
   * @param pattern       regular expression for validation
   * @param required      true if parameter is required
   * @return this handler
   * 
   */
  addFormParamsArrayWithPattern(parameterName: string, pattern: string, required: boolean) : HTTPRequestValidationHandler;

  /**
   *  Add a form parameter with a custom type validator. For more informations about how to construct built-in or
   *  custom type validator, check out {@link ParameterTypeValidator}
   * @param parameterName   expected name of parameter inside the form
   * @param validator       type validator
   * @param required        true if parameter is required
   * @param allowEmptyValue true if parameter allowEmptyValue. For more informations about allowEmptyValue behaviour:
   *  {@link ParameterValidationRule#allowEmptyValue()}
   * @return this handler
   * 
   */
  addFormParamWithCustomTypeValidator(parameterName: string, validator: ParameterTypeValidator, required: boolean, allowEmptyValue: boolean) : HTTPRequestValidationHandler;

  /**
   *  Add a custom validator. For more informations about custom validator, see {@link CustomValidator}
   * @param customValidator
   * @return this handler
   * 
   */
  addCustomValidatorFunction(customValidator: CustomValidator) : HTTPRequestValidationHandler;

  /**
   *  Add a json schema for body with Content-Type "application/json"
   * @param jsonSchema
   * @return this handler
   * 
   */
  addJsonBodySchema(jsonSchema: string) : HTTPRequestValidationHandler;

  /**
   *  Add a xml schema for body with Content-Type "application/xml"
   * @param xmlSchema
   * @return this handler
   * 
   */
  addXMLBodySchema(xmlSchema: string) : HTTPRequestValidationHandler;

  /**
   *  Add an expected filename inside <b>multipart request</b>.
   * @param filename    name of the file inside the form
   * @param contentType expected content type of file
   * @return this handler
   * 
   */
  addMultipartRequiredFile(filename: string, contentType: string) : HTTPRequestValidationHandler;

  /**
   *  Add an expected content type of request. It's not needed to add application/json, application/xml,
   *  multipart/form-data and application/x-www-form-urlencoded
   * @param contentType expected content type of file
   * @return this handler
   * 
   */
  addExpectedContentType(contentType: string) : HTTPRequestValidationHandler;

}


export class OpenAPI3RequestValidationHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Function that parse the operation specification and generate validation rules
   * 
   */
  parseOperationSpec() : void;

}

import { Vertx } from '@vertx/core';
import { Router } from '@vertx/web';
import { RouterFactoryOptions } from './options';
import { HttpMethod } from '@vertx/core/enums';

export class OpenAPI3RouterFactory {
  /**
   *  Mount to paths that have to follow a security schema a security handler
   * @param securitySchemaName
   * @param handler
   * @return 
   */
  addSecurityHandler(securitySchemaName: string, handler: (result: RoutingContext) => void) : RouterFactory;

  /**
   *  Add an handler to a path with a method. If combination path/method is not available in
   *  specification, it will throw a {@link RouterFactoryException}. Deprecated in favour of
   *  operation id
   * @param method
   * @param path
   * @param handler
   * @return 
   */
  addHandler(method: HttpMethod, path: string, handler: (result: RoutingContext) => void) : RouterFactory;

  /**
   *  Add a failure handler to a path with a method. If combination path/method is not available in
   *  specification, it will throw a {@link RouterFactoryException}. Deprecated in favour of
   *  operation id
   * @param method
   * @param path
   * @param failureHandler
   * @return 
   */
  addFailureHandler(method: HttpMethod, path: string, failureHandler: (result: RoutingContext) => void) : RouterFactory;

  /**
   *  Override options
   * @param options
   * @return 
   */
  setOptions(options: RouterFactoryOptions) : RouterFactory;

  /**
   *  Get options of router factory. For more info {@link RouterFactoryOptions}
   * @return 
   */
  getOptions() : RouterFactoryOptions;

  /**
   *  Deprecated. Instantiate {@link RouterFactoryOptions}
   *  and load it using {@link RouterFactory#setOptions(RouterFactoryOptions)}
   * @param handler
   * @return 
   */
  setValidationFailureHandler(handler: (result: RoutingContext) => void) : RouterFactory;

  /**
   *  Deprecated. Instantiate {@link RouterFactoryOptions}
   *  and load it using {@link RouterFactory#setOptions(RouterFactoryOptions)}
   * @param enable
   * @return 
   */
  enableValidationFailureHandler(enable: boolean) : RouterFactory;

  /**
   *  Deprecated. Instantiate {@link RouterFactoryOptions}
   *  and load it using {@link RouterFactory#setOptions(RouterFactoryOptions)}
   * @param enable
   * @return 
   */
  mountOperationsWithoutHandlers(enable: boolean) : RouterFactory;

  /**
   *  Construct a new router based on spec. It will fail if you are trying to mount a spec with security schemes
   *  without assigned handlers<br/>
   *  <b>Note:</b> Router is constructed in this function, so it will be respected the path definition ordering.
   * @return 
   */
  getRouter() : Router;

  /**
   *  Add a particular scope validator. The main security schema will not be called if a specific scope validator is
   *  configured
   * @param securitySchemaName
   * @param scopeName
   * @param handler
   * @return this factory
   * 
   */
  addSecuritySchemaScopeValidator(securitySchemaName: string, scopeName: string, handler: (result: RoutingContext) => void) : OpenAPI3RouterFactory;

  /**
   *  Add an handler by operation_id field in Operation object
   * @param operationId
   * @param handler
   * @return this factory
   * 
   */
  addHandlerByOperationId(operationId: string, handler: (result: RoutingContext) => void) : OpenAPI3RouterFactory;

  /**
   *  Add a failure handler by operation_id field in Operation object
   * @param operationId
   * @param failureHandler
   * @return this factory
   * 
   */
  addFailureHandlerByOperationId(operationId: string, failureHandler: (result: RoutingContext) => void) : OpenAPI3RouterFactory;

  /**
   *  Create a new OpenAPI3RouterFactory
   * @param vertx
   * @param url location of your spec. It can be an absolute path, a local path or remote url (with HTTP protocol)
   * @param handler  When specification is loaded, this handler will be called with AsyncResult<OpenAPI3RouterFactory>
   * 
   */
  static create(vertx: Vertx, url: string, handler: (result: AsyncResult<OpenAPI3RouterFactory>) => void) : void;

  /**
   * 
   * @deprecated use {@link OpenAPI3RouterFactory#create(Vertx, String, Handler)}
   * @param vertx
   * @param url
   * @param handler
   * 
   */
  static createRouterFactoryFromFile(vertx: Vertx, url: string, handler: (result: AsyncResult<OpenAPI3RouterFactory>) => void) : void;

  /**
   * 
   * @deprecated use {@link OpenAPI3RouterFactory#create(Vertx, String, Handler)}
   * @param vertx
   * @param url
   * @param handler
   * 
   */
  static createRouterFactoryFromURL(vertx: Vertx, url: string, handler: (result: AsyncResult<OpenAPI3RouterFactory>) => void) : void;

}


export class ParameterTypeValidator {
  /**
   *  Function that checks if parameter is valid. It returns a RequestParameter object that will be linked inside
   *  {@link RequestParameters}. For more info, check {@link RequestParameter}.
   * @param value value of parameter to test
   * @return request parameter value
   * 
   */
  isValid(value: string) : RequestParameter;

  /**
   *  Function that checks if array of values of a specific parameter. It returns a RequestParameter object that will
   *  be linked inside {@link RequestParameters}. For more info, check {@link RequestParameter}.
   * @param value list of values of parameter to test
   * @return request parameter value
   * 
   */
  isValidCollection(value: string[]) : RequestParameter;

  /**
   *  Returns default value of parameter
   * @return 
   */
  getDefault() : Object;

  /**
   *  Returns true if this type validator has default value
   * @return 
   */
  hasDefault() : boolean;

  /**
   *  Create a new type validator for integer values
   * @param defaultValue Default value that will be set if parameter is empty or not found. To apply default value
   *                      you have to set {@link ParameterValidationRule#allowEmptyValue()} true. It can be null
   * @return 
   */
  static createIntegerTypeValidator(defaultValue: number) : ParameterTypeValidator;

  /**
   *  Create a new type validator for integer values
   * @param maximum      Maximum value. It can be null
   * @param minimum      Minimum value. It can be null
   * @param multipleOf   Multiple of value. It can be null
   * @param defaultValue Default value that will be set if parameter is empty or not found. To apply default value
   *                      you have to set {@link ParameterValidationRule#allowEmptyValue()} true. It can be null
   * @return 
   */
  static createIntegerTypeValidator(maximum: number, minimum: number, multipleOf: number, defaultValue: number) : ParameterTypeValidator;

  /**
   *  Create a new type validator for integer values
   * @param exclusiveMaximum If true, value will be mark as valid if value < maximum. If false, value will be mark as
   *                         valid if value <= maximum. The default value is false. It can be null
   * @param maximum          Maximum value. It can be null
   * @param exclusiveMinimum If true, value will be mark as valid if value > minimum. If false, value will be mark as
   *                         valid if value >= minimum. The default value is false. It can be null
   * @param minimum          Minimum value. It can be null
   * @param multipleOf       Multiple of value. It can be null
   * @param defaultValue     Default value that will be set if parameter is empty or not found. To apply default
   *                          value you have to set {@link ParameterValidationRule#allowEmptyValue()} true. It can be
   *                          null
   * @return 
   */
  static createIntegerTypeValidator(exclusiveMaximum: boolean, maximum: number, exclusiveMinimum: boolean, minimum: number, multipleOf: number, defaultValue: any) : ParameterTypeValidator;

  /**
   *  Create a new type validator for long integer values
   * @param defaultValue Default value that will be set if parameter is empty or not found. To apply default value
   *                      you have to set {@link ParameterValidationRule#allowEmptyValue()} true. It can be null
   * @return 
   */
  static createLongTypeValidator(defaultValue: number) : ParameterTypeValidator;

  /**
   *  Create a new type validator for long integer values
   * @param maximum      Maximum value. It can be null
   * @param minimum      Minimum value. It can be null
   * @param multipleOf   Multiple of value. It can be null
   * @param defaultValue Default value that will be set if parameter is empty or not found. To apply default value
   *                      you have to set {@link ParameterValidationRule#allowEmptyValue()} true. It can be null
   * @return 
   */
  static createLongTypeValidator(maximum: number, minimum: number, multipleOf: number, defaultValue: number) : ParameterTypeValidator;

  /**
   *  Create a new type validator for long integer values
   * @param exclusiveMaximum If true, value will be mark as valid if value < maximum. If false, value will be mark as
   *                         valid if value <= maximum. The default value is false. It can be null
   * @param maximum          Maximum value. It can be null
   * @param exclusiveMinimum If true, value will be mark as valid if value > minimum. If false, value will be mark as
   *                         valid if value >= minimum. The default value is false. It can be null
   * @param minimum          Minimum value. It can be null
   * @param multipleOf       Multiple of value. It can be null
   * @param defaultValue     Default value that will be set if parameter is empty or not found. To apply default
   *                          value you have to set {@link ParameterValidationRule#allowEmptyValue()} true. It can be
   *                          null
   * @return 
   */
  static createLongTypeValidator(exclusiveMaximum: boolean, maximum: number, exclusiveMinimum: boolean, minimum: number, multipleOf: number, defaultValue: any) : ParameterTypeValidator;

  /**
   *  Create a new type validator for float values
   * @param defaultValue Default value that will be set if parameter is empty or not found. To apply default value
   *                      you have to set {@link ParameterValidationRule#allowEmptyValue()} true. It can be null
   * @return 
   */
  static createFloatTypeValidator(defaultValue: number) : ParameterTypeValidator;

  /**
   *  Create a new type validator for float values
   * @param maximum      Maximum value. It can be null
   * @param minimum      Minimum value. It can be null
   * @param multipleOf   Multiple of value. It can be null
   * @param defaultValue Default value that will be set if parameter is empty or not found. To apply default value
   *                      you have to set {@link ParameterValidationRule#allowEmptyValue()} true. It can be null
   * @return 
   */
  static createFloatTypeValidator(maximum: number, minimum: number, multipleOf: number, defaultValue: number) : ParameterTypeValidator;

  /**
   *  Create a new type validator for float values
   * @param exclusiveMaximum If true, value will be mark as valid if value < maximum. If false, value will be mark as
   *                         valid if value <= maximum. The default value is false. It can be null
   * @param maximum          Maximum value. It can be null
   * @param exclusiveMinimum If true, value will be mark as valid if value > minimum. If false, value will be mark as
   *                         valid if value >= minimum. The default value is false. It can be null
   * @param minimum          Minimum value. It can be null
   * @param multipleOf       Multiple of value. It can be null
   * @param defaultValue     Default value that will be set if parameter is empty or not found. To apply default
   *                          value you have to set {@link ParameterValidationRule#allowEmptyValue()} true. It can be
   *                          null
   * @return 
   */
  static createFloatTypeValidator(exclusiveMaximum: boolean, maximum: number, exclusiveMinimum: boolean, minimum: number, multipleOf: number, defaultValue: any) : ParameterTypeValidator;

  /**
   *  Create a new type validator for double values
   * @param defaultValue Default value that will be set if parameter is empty or not found. To apply default value
   *                      you have to set {@link ParameterValidationRule#allowEmptyValue()} true. It can be null
   * @return 
   */
  static createDoubleTypeValidator(defaultValue: number) : ParameterTypeValidator;

  /**
   *  Create a new type validator for double values
   * @param maximum      Maximum value. It can be null
   * @param minimum      Minimum value. It can be null
   * @param multipleOf   Multiple of value. It can be null
   * @param defaultValue Default value that will be set if parameter is empty or not found. To apply default value
   *                      you have to set {@link ParameterValidationRule#allowEmptyValue()} true. It can be null
   * @return 
   */
  static createDoubleTypeValidator(maximum: number, minimum: number, multipleOf: number, defaultValue: number) : ParameterTypeValidator;

  /**
   *  Create a new type validator for double values
   * @param exclusiveMaximum If true, value will be mark as valid if value < maximum. If false, value will be mark as
   *                         valid if value <= maximum. The default value is false. It can be null
   * @param maximum          Maximum value. It can be null
   * @param exclusiveMinimum If true, value will be mark as valid if value > minimum. If false, value will be mark as
   *                         valid if value >= minimum. The default value is false. It can be null
   * @param minimum          Minimum value. It can be null
   * @param multipleOf       Multiple of value. It can be null
   * @param defaultValue     Default value that will be set if parameter is empty or not found. To apply default
   *                          value you have to set {@link ParameterValidationRule#allowEmptyValue()} true. It can be
   *                          null
   * @return 
   */
  static createDoubleTypeValidator(exclusiveMaximum: boolean, maximum: number, exclusiveMinimum: boolean, minimum: number, multipleOf: number, defaultValue: any) : ParameterTypeValidator;

  /**
   *  Create a new string type validator
   * @param defaultValue Default value that will be set if parameter is empty or not found. To apply default value
   *                      you have to set {@link ParameterValidationRule#allowEmptyValue()} true. It can be null
   * @return 
   */
  static createStringTypeValidator(defaultValue: any) : ParameterTypeValidator;

  /**
   *  Create a new string type validator
   * @param pattern      pattern that string have to match. It can be null
   * @param defaultValue Default value that will be set if parameter is empty or not found. To apply default value
   *                      you have to set {@link ParameterValidationRule#allowEmptyValue()} true. It can be null
   * @return 
   */
  static createStringTypeValidator(pattern: string, defaultValue: any) : ParameterTypeValidator;

  /**
   *  Create a new string type validator
   * @param pattern      pattern that string have to match. It can be null
   * @param minLength    Minimum length of string. It can be null
   * @param maxLength    Maximum length of string. It can be null
   * @param defaultValue Default value that will be set if parameter is empty or not found. To apply default value
   *                      you have to set {@link ParameterValidationRule#allowEmptyValue()} true. It can be null
   * @return 
   */
  static createStringTypeValidator(pattern: string, minLength: number, maxLength: number, defaultValue: any) : ParameterTypeValidator;

  /**
   *  Create a boolean type validator
   * @param defaultValue Default value that will be set if parameter is empty or not found. To apply default value
   *                      you have to set {@link ParameterValidationRule#allowEmptyValue()} true. It can be null
   * @return 
   */
  static createBooleanTypeValidator(defaultValue: any) : ParameterTypeValidator;

  /**
   *  Create an enum type validator
   * @param allowedValues allowed values. It <b>can't be</b> null
   * @return 
   */
  static createStringEnumTypeValidator(allowedValues: string[]) : ParameterTypeValidator;

  /**
   *  Create an enum type validator
   * @param allowedValues  allowed values. It <b>can't be</b> null
   * @param innerValidator After check if value is one of the lists, you can pass the value to an inner validator. It
   *                       can be null
   * @return 
   */
  static createEnumTypeValidatorWithInnerValidator(allowedValues: string[], innerValidator: ParameterTypeValidator) : ParameterTypeValidator;

  /**
   *  Create an array type validator
   * @param arrayMembersValidator Type validator that describe array items. It <b>can't be</b> null
   * @return 
   */
  static createArrayTypeValidator(arrayMembersValidator: ParameterTypeValidator) : ParameterTypeValidator;

  /**
   *  Create an array type validator
   * @param arrayMembersValidator Type validator that describe array items. It <b>can't be</b> null
   * @param collectionFormat      String that represent a ContainerSerializationStyle. Check out
   *  {@link ContainerSerializationStyle} for more informations. The default value is "csv". It can be null
   * @param maxItems              Maximum items in array. It can be null
   * @param minItems              Minimum items in array. It can be null
   * @return 
   */
  static createArrayTypeValidator(arrayMembersValidator: ParameterTypeValidator, collectionFormat: string, maxItems: number, minItems: number) : ParameterTypeValidator;

}


export class ParameterValidationRule {
  /**
   *  This function return the name of the parameter expected into parameter lists
   * @return name of the parameter
   * 
   */
  getName() : string;

  /**
   *  This function will be called when there is only a string as parameter. It will throw a ValidationError in an
   *  error during validation occurs
   * @param value list of values that will be validated
   * @throws ValidationException
   * 
   */
  validateSingleParam(value: string) : RequestParameter;

  /**
   *  This function will be called when there is a List<String> that need to be validated. It must check if array is
   *  expected or not. It will throw a ValidationError in an error during validation occurs
   * @param value list of values that will be validated
   * @throws ValidationException
   * 
   */
  validateArrayParam(value: string[]) : RequestParameter;

  /**
   *  Return true if parameter is optional
   * @return true if is optional, false otherwise
   * 
   */
  isOptional() : boolean;

  /**
   *  Return ParameterTypeValidator instance used inside this parameter validation rule
   * @return 
   */
  parameterTypeValidator() : ParameterTypeValidator;

  /**
   *  allowEmptyValue is used in query, header, cookie and form parameters. This is its behaviour:
   *  <ol>
   *  <li>During validation, the ValidationHandler check if there's a parameter with combination of location and name
   *  as defined in this rule </li>
   *  <li>If it not exists, It will check allowEmptyValue and if there's a default value set inside
   *  ParameterTypeValidator:</li>
   *  <ul>
   *  <li>If this condition it's true, It marks as validated the parameter and returns the default value (inside
   *  RequestParameter)</li>
   *  <li>If this condition it's false, It throws ValidationException</li>
   *  </ul>
   *  <li>If the parameter exists, It checks if parameter is null or empty string:</li>
   *  <ul>
   *  <li>If allowEmptyValue it's true, It marks as validated the parameter and returns the default value if it exists
   *  (inside RequestParameter)</li>
   *  <li>If allowEmptyValue it's false, It throws ValidationException</li>
   *  </ul>
   *  </ol>
   * @return value of allowEmptyValue
   * 
   */
  allowEmptyValue() : boolean;

}


export class RequestParameter {
  /**
   *  Set parameter name
   * @param name
   * 
   */
  setName(name: string) : void;

  /**
   *  Set value
   * @param value
   * 
   */
  setValue(value: any) : void;

  /**
   *  Get parameter name
   * @return 
   */
  getName() : string | null;

  /**
   *  If value is a map of fields, it returns keys of map, otherwise it returns null
   * @return 
   */
  getObjectKeys() : string[] | null;

  /**
   *  If value is a map of fields, it returns value of field with key provided, otherwise it returns null
   * @param key
   * @return 
   */
  getObjectValue(key: string) : RequestParameter | null;

  /**
   *  Returns true if value of RequestParameter is a map of fields
   * @return 
   */
  isObject() : boolean;

  /**
   *  Returns null if value is not a list, otherwise it returns value
   * @return 
   */
  getArray() : RequestParameter[] | null;

  /**
   *  Returns true if value of RequestParameter is an array
   * @return 
   */
  isArray() : boolean;

  /**
   *  Returns null if value is not a String, otherwise it returns value
   * @return 
   */
  getString() : string | null;

  /**
   *  Returns true if value of RequestParameter is a String instance
   * @return 
   */
  isString() : boolean;

  /**
   *  Returns null if value is not an Integer, otherwise it returns value
   * @return 
   */
  getInteger() : number | null;

  /**
   *  Returns true if value of RequestParameter is an Integer instance
   * @return 
   */
  isInteger() : boolean;

  /**
   *  Returns null if value is not a Long, otherwise it returns value
   * @return 
   */
  getLong() : number | null;

  /**
   *  Returns true if value of RequestParameter is a Long instance
   * @return 
   */
  isLong() : boolean;

  /**
   *  Returns null if value is not a Float, otherwise it returns value
   * @return 
   */
  getFloat() : number | null;

  /**
   *  Returns true if value of RequestParameter is a Float instance
   * @return 
   */
  isFloat() : boolean;

  /**
   *  Returns null if value is not a Double, otherwise it returns value
   * @return 
   */
  getDouble() : number | null;

  /**
   *  Returns true if value of RequestParameter is a Double instance
   * @return 
   */
  isDouble() : boolean;

  /**
   *  Returns null if value is not a Boolean, otherwise it returns value
   * @return 
   */
  getBoolean() : boolean | null;

  /**
   *  Returns true if value of RequestParameter is a Boolean instance
   * @return 
   */
  isBoolean() : boolean;

  /**
   *  Returns null if value is not a JsonObject, otherwise it returns value
   * @return 
   */
  getJsonObject() : object | null;

  /**
   *  Returns true if value of RequestParameter is a JsonObject instance
   * @return 
   */
  isJsonObject() : boolean;

  /**
   *  Returns null if value is not a JsonArray, otherwise it returns value
   * @return 
   */
  getJsonArray() : any[] | null;

  /**
   *  Returns true if value of RequestParameter is a JsonArray instance
   * @return 
   */
  isJsonArray() : boolean;

  /**
   *  Returns true if value is null
   * @return 
   */
  isNull() : boolean;

  /**
   *  Alias of {@link RequestParameter#isNull()}
   * @return 
   */
  isEmpty() : boolean;

  /**
   *  Merge this request parameter with another one. Note: the parameter passed by argument has the priority
   * @param otherParameter
   * @return 
   */
  merge(otherParameter: RequestParameter) : RequestParameter;

  static create(name: string, value: any) : RequestParameter;

  static create(value: any) : RequestParameter;

}


export class RequestParameters {
  /**
   *  Get list of all parameter names inside path
   * @return 
   */
  pathParametersNames() : string[];

  /**
   *  Get path parameter by name
   * @param name Parameter name
   * @return 
   */
  pathParameter(name: string) : RequestParameter | null;

  /**
   *  Get list of all parameter names inside query
   * @return 
   */
  queryParametersNames() : string[];

  /**
   *  Get query parameter by name
   * @param name Parameter name
   * @return 
   */
  queryParameter(name: string) : RequestParameter | null;

  /**
   *  Get list of all parameter names inside header
   * @return 
   */
  headerParametersNames() : string[];

  /**
   *  Get header parameter by name
   * @param name Parameter name
   * @return 
   */
  headerParameter(name: string) : RequestParameter | null;

  /**
   *  Get list of all parameter names inside cookie
   * @return 
   */
  cookieParametersNames() : string[];

  /**
   *  Get cookie parameter by name
   * @param name Parameter name
   * @return 
   */
  cookieParameter(name: string) : RequestParameter | null;

  /**
   *  Get list of all parameter names inside body form
   * @return 
   */
  formParametersNames() : string[];

  /**
   *  Get form parameter by name
   * @param name Parameter name
   * @return 
   */
  formParameter(name: string) : RequestParameter | null;

  /**
   *  Return request body
   * @return 
   */
  body() : RequestParameter | null;

}


export interface RouterFactory {
  /**
   *  Mount to paths that have to follow a security schema a security handler
   * @param securitySchemaName
   * @param handler
   * @return 
   */
  addSecurityHandler(securitySchemaName: string, handler: (result: RoutingContext) => void) : RouterFactory;

  /**
   *  Add an handler to a path with a method. If combination path/method is not available in
   *  specification, it will throw a {@link RouterFactoryException}. Deprecated in favour of
   *  operation id
   * @param method
   * @param path
   * @param handler
   * @return 
   */
  addHandler(method: HttpMethod, path: string, handler: (result: RoutingContext) => void) : RouterFactory;

  /**
   *  Add a failure handler to a path with a method. If combination path/method is not available in
   *  specification, it will throw a {@link RouterFactoryException}. Deprecated in favour of
   *  operation id
   * @param method
   * @param path
   * @param failureHandler
   * @return 
   */
  addFailureHandler(method: HttpMethod, path: string, failureHandler: (result: RoutingContext) => void) : RouterFactory;

  /**
   *  Override options
   * @param options
   * @return 
   */
  setOptions(options: RouterFactoryOptions) : RouterFactory;

  /**
   *  Get options of router factory. For more info {@link RouterFactoryOptions}
   * @return 
   */
  getOptions() : RouterFactoryOptions;

  /**
   *  Deprecated. Instantiate {@link RouterFactoryOptions}
   *  and load it using {@link RouterFactory#setOptions(RouterFactoryOptions)}
   * @param handler
   * @return 
   */
  setValidationFailureHandler(handler: (result: RoutingContext) => void) : RouterFactory;

  /**
   *  Deprecated. Instantiate {@link RouterFactoryOptions}
   *  and load it using {@link RouterFactory#setOptions(RouterFactoryOptions)}
   * @param enable
   * @return 
   */
  enableValidationFailureHandler(enable: boolean) : RouterFactory;

  /**
   *  Deprecated. Instantiate {@link RouterFactoryOptions}
   *  and load it using {@link RouterFactory#setOptions(RouterFactoryOptions)}
   * @param enable
   * @return 
   */
  mountOperationsWithoutHandlers(enable: boolean) : RouterFactory;

  /**
   *  Construct a new router based on spec. It will fail if you are trying to mount a spec with security schemes
   *  without assigned handlers<br/>
   *  <b>Note:</b> Router is constructed in this function, so it will be respected the path definition ordering.
   * @return 
   */
  getRouter() : Router;

}


export interface ValidationHandler {
  handle(arg0: RoutingContext) : void;

}

