import { AsyncResult } from '@vertx/core';


export class AuthProvider {
  /**
   *  Authenticate a user.
   *  <p>
   *  The first argument is a JSON object containing information for authenticating the user. What this actually contains
   *  depends on the specific implementation. In the case of a simple username/password based
   *  authentication it is likely to contain a JSON object with the following structure:
   *  <pre>
   *    {
   *      "username": "tim",
   *      "password": "mypassword"
   *    }
   *  </pre>
   *  For other types of authentication it contain different information - for example a JWT token or OAuth bearer token.
   *  <p>
   *  If the user is successfully authenticated a {@link User} object is passed to the handler in an {@link io.vertx.core.AsyncResult}.
   *  The user object can then be used for authorisation.
   * @param authInfo  The auth information
   * @param resultHandler  The result handler
   * 
   */
  authenticate(authInfo: object, resultHandler: (result: AsyncResult<User>) => void) : void;

}


export class ChainAuth {
  /**
   *  Create a Chainable Auth Provider auth provider
   * @return the auth provider
   * 
   */
  static create() : ChainAuth;

  /**
   *  Appends a auth provider to the chain.
   * @param other auth provider
   * @return self
   * 
   */
  append(other: AuthProvider) : ChainAuth;

  /**
   *  Removes a provider from the chain.
   * @param other provider to remove
   * @return true if provider was removed, false if non existent in the chain.
   * 
   */
  remove(other: AuthProvider) : boolean;

  /**
   *  Clears the chain.
   * 
   */
  clear() : void;

}


export class User {
  /**
   *  Is the user authorised to
   * @param authority  the authority - what this really means is determined by the specific implementation. It might
   *                    represent a permission to access a resource e.g. `printers:printer34` or it might represent
   *                    authority to a role in a roles based model, e.g. `role:admin`.
   * @param resultHandler  handler that will be called with an {@link io.vertx.core.AsyncResult} containing the value
   *                        `true` if the they has the authority or `false` otherwise.
   * @return the User to enable fluent use
   * 
   */
  isAuthorized(authority: string, resultHandler: (result: AsyncResult<boolean>) => void) : User;

  /**
   * 
   * @deprecated See {@link #isAuthorized(String, Handler)}
   * 
   */
  isAuthorised(authority: string, resultHandler: (result: AsyncResult<boolean>) => void) : User;

  /**
   *  The User object will cache any authorities that it knows it has to avoid hitting the
   *  underlying auth provider each time.  Use this method if you want to clear this cache.
   * @return the User to enable fluent use
   * 
   */
  clearCache() : User;

  /**
   *  Get the underlying principal for the User. What this actually returns depends on the implementation.
   *  For a simple user/password based auth, it's likely to contain a JSON object with the following structure:
   *  <pre>
   *    {
   *      "username", "tim"
   *    }
   *  </pre>
   * @return JSON representation of the Principal
   * 
   */
  principal() : object;

  /**
   *  Set the auth provider for the User. This is typically used to reattach a detached User with an AuthProvider, e.g.
   *  after it has been deserialized.
   * @param authProvider  the AuthProvider - this must be the same type of AuthProvider that originally created the User
   * 
   */
  setAuthProvider(authProvider: AuthProvider) : void;

}

import { Vertx } from '@vertx/core';

export class VertxContextPRNG {
  /**
   *  Get or create a secure non blocking random number generator using the current vert.x context. If there is no
   *  current context (i.e.: not running on the eventloop) then a {@link java.lang.IllegalStateException} is thrown.
   * @return A secure non blocking random number generator.
   * @throws IllegalStateException when there is no context available.
   * 
   */
  static current() : VertxContextPRNG;

  /**
   *  Get or create a secure non blocking random number generator using the current vert.x instance. Since the context
   *  might be different this method will attempt to use the current context first if available and then fall back to
   *  create a new instance of the PRNG.
   * @param vertx a Vert.x instance.
   * @return A secure non blocking random number generator.
   * 
   */
  static current(vertx: Vertx) : VertxContextPRNG;

  /**
   *  Returns a Base64 mime encoded String of random data with the given length. The length parameter refers to the length
   *  of the String before the encoding step.
   * @param length the desired string length before Base64 encoding.
   * @return A base 64 encoded string.
   * 
   */
  nextString(length: number) : string;

  /**
   *  Returns a secure random int
   * @return random int.
   * 
   */
  nextInt() : number;

}

