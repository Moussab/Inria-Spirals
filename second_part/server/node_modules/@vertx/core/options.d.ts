import { Buffer } from './index';

export class AddressResolverOptions {

  /**
   * Set the cache maximum TTL value in seconds. After successful resolution IP addresses are cached with their DNS response TTL,
   *  use this to set a maximum value to all responses TTL.
   * @param cacheMaxTimeToLive the cache max TTL in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  cacheMaxTimeToLive: number;

  /**
   * Set the cache minimum TTL value in seconds. After resolution successful IP addresses are cached with their DNS response TTL,
   *  use this to set a minimum value to all responses TTL.
   * @param cacheMinTimeToLive the cache min TTL in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  cacheMinTimeToLive: number;

  /**
   * Set the negative cache TTL value in seconds. After a failed hostname resolution, DNS queries won't be retried
   *  for a period of time equals to the negative TTL. This allows to reduce the response time of negative replies
   *  and reduce the amount of messages to DNS servers.
   * @param cacheNegativeTimeToLive the cache negative TTL in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  cacheNegativeTimeToLive: number;

  /**
   * Set the path of an alternate hosts configuration file to use instead of the one provided by the os.
   *  <p/>
   *  The default value is null, so the operating system hosts config is used.
   * @param hostsPath the hosts path
   * @return a reference to this, so the API can be used fluently
   * 
   */
  hostsPath: string;

  /**
   * Set an alternate hosts configuration file to use instead of the one provided by the os.
   *  <p/>
   *  The value should contain the hosts content literaly, for instance <i>127.0.0.1 localhost</i>
   *  <p/>
   *  The default value is null, so the operating system hosts config is used.
   * @param hostsValue the hosts content
   * @return a reference to this, so the API can be used fluently
   * 
   */
  hostsValue: Buffer;

  /**
   * Set the maximum number of queries when an hostname is resolved.
   * @param maxQueries the max number of queries to be sent
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxQueries: number;

  /**
   * Set the ndots value used when resolving using search domains, the default value is {@code -1} which
   *  determines the value from the OS on Linux or uses the value {@code 1}.
   * @param ndots the new ndots value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  ndots: number;

  /**
   * Set to true to enable the automatic inclusion in DNS queries of an optional record that hints
   *  the remote DNS server about how much data the resolver can read per response.
   * @param optResourceEnabled true to enable, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  optResourceEnabled: boolean;

  /**
   * Set the query timeout in milliseconds, i.e the amount of time after a query is considered to be failed.
   * @param queryTimeout the query timeout in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  queryTimeout: number;

  /**
   * Set the DNS queries <i>Recursion Desired</i> flag value.
   * @param rdFlag the flag value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  rdFlag: boolean;

  /**
   * Set to {@code true} to enable round-robin selection of the dns server to use. It spreads the query load
   *  among the servers and avoids all lookup to hit the first server of the list.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  rotateServers: boolean;

  /**
   * Set the lists of DNS search domains.
   *  <p/>
   *  When the search domain list is null, the effective search domain list will be populated using
   *  the system DNS search domains.
   * @param searchDomains the search domains
   * 
   */
  searchDomains: string;

  /**
   * Set the list of DNS server addresses, an address is the IP  of the dns server, followed by an optional
   *  colon and a port, e.g {@code 8.8.8.8} or {code 192.168.0.1:40000}. When the list is empty, the resolver
   *  will use the list of the system DNS server addresses from the environment, if that list cannot be retrieved
   *  it will use Google's public DNS servers {@code "8.8.8.8"} and {@code "8.8.4.4"}.
   * @param servers the list of DNS servers
   * @return a reference to this, so the API can be used fluently
   * 
   */
  servers: string;
}


export class Argument {

  /**
   * Sets the argument name of this {@link Argument}.
   * @param argName the argument name, must not be {@code null}
   * @return the current {@link Argument} instance
   * 
   */
  argName: string;

  /**
   * Sets the default value of this {@link Argument}.
   * @param defaultValue the default value
   * @return the current {@link Argument} instance
   * 
   */
  defaultValue: string;

  /**
   * Sets the description of the {@link Argument}.
   * @param description the description
   * @return the current {@link Argument} instance
   * 
   */
  description: string;

  /**
   * Sets whether or not the current {@link Argument} is hidden.
   * @param hidden enables or disables the visibility of this {@link Argument}
   * @return the current {@link Argument} instance
   * 
   */
  hidden: boolean;

  /**
   * Sets the argument index.
   * @param index the index, must not be negative
   * @return the current {@link Argument} instance
   * 
   */
  index: number;

  /**
   * Sets whether or not the argument can receive several values. Only the last argument can receive several values.
   * @param multiValued {@code true} to mark this argument as multi-valued.
   * @return the current {@link Argument} instance
   * 
   */
  multiValued: boolean;

  /**
   * Sets whether or not the current {@link Argument} is required.
   * @param required {@code true} to make this argument mandatory, {@link false} otherwise
   * @return the current {@link Argument} instance
   * 
   */
  required: boolean;
}


export interface ClientOptionsBase {

  /**
   * Set the connect timeout
   * @param connectTimeout  connect timeout, in ms
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connectTimeout: number;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  crlPaths: string;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  crlValues: Buffer;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  enabledCipherSuites: string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  enabledSecureTransportProtocols: string;

  /**
   * Set the idle timeout, in seconds. zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  idleTimeout: number;

  jdkSslEngineOptions: JdkSSLEngineOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  keyStoreOptions: JksOptions;

  /**
   * Set the local interface to bind for network connections. When the local address is null,
   *  it will pick any local address, the default local address is null.
   * @param localAddress the local address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  localAddress: string;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  logActivity: boolean;

  /**
   * Set the metrics name identifying the reported metrics, useful for grouping metrics
   *  with the same name.
   * @param metricsName the metrics name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  metricsName: string;

  openSslEngineOptions: OpenSSLEngineOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pemKeyCertOptions: PemKeyCertOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pemTrustOptions: PemTrustOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pfxKeyCertOptions: PfxOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pfxTrustOptions: PfxOptions;

  /**
   * Set proxy options for connections via CONNECT proxy (e.g. Squid) or a SOCKS proxy.
   * @param proxyOptions proxy options object
   * @return a reference to this, so the API can be used fluently
   * 
   */
  proxyOptions: ProxyOptions;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  receiveBufferSize: number;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reuseAddress: boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reusePort: boolean;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendBufferSize: number;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  soLinger: number;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  ssl: boolean;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  tcpCork: boolean;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  tcpFastOpen: boolean;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  tcpKeepAlive: boolean;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  tcpNoDelay: boolean;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  tcpQuickAck: boolean;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trafficClass: number;

  /**
   * Set whether all server certificates should be trusted
   * @param trustAll true if all should be trusted
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trustAll: boolean;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trustStoreOptions: JksOptions;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  useAlpn: boolean;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  usePooledBuffers: boolean;
}


export class CopyOptions {

  /**
   * Whether move should be performed as an atomic filesystem operation. Defaults to {@code false}.
   * @param atomicMove true to perform as an atomic filesystem operation, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  atomicMove: boolean;

  /**
   * Whether the file attributes should be copied. Defaults to {@code false}.
   * @param copyAttributes true to copy attributes, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  copyAttributes: boolean;

  /**
   * Whether symbolic links should not be followed during copy or move operations. Defaults to {@code false}.
   * @param nofollowLinks true to not follow links, false otherwise. Defaults to {@code false}.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  nofollowLinks: boolean;

  /**
   * Whether an existing file, empty directory, or link should be replaced. Defaults to {@code false}.
   * @param replaceExisting true to replace, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  replaceExisting: boolean;
}


export class DatagramSocketOptions {

  /**
   * Set if the socket can send or receive broadcast packets
   * @param broadcast  true if the socket can send or receive broadcast packets
   * @return a reference to this, so the API can be used fluently
   * 
   */
  broadcast: boolean;

  /**
   * Set if IP v6 should be used
   * @param ipV6  true if IP v6 should be used
   * @return a reference to this, so the API can be used fluently
   * 
   */
  ipV6: boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  logActivity: boolean;

  /**
   * Set if loopback mode is disabled
   * @param loopbackModeDisabled  true if loopback mode is disabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  loopbackModeDisabled: boolean;

  /**
   * Set the multicast network interface address
   * @param multicastNetworkInterface  the address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  multicastNetworkInterface: string;

  /**
   * Set the multicast ttl value
   * @param multicastTimeToLive  the multicast ttl value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  multicastTimeToLive: number;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  receiveBufferSize: number;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reuseAddress: boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reusePort: boolean;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendBufferSize: number;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trafficClass: number;
}


export class DeliveryOptions {

  /**
   * Set the codec name.
   * @param codecName  the codec name
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  codecName: string;

  /**
   * Add a message header.
   *  <p>
   *  Message headers can be sent with any message and will be accessible with {@link io.vertx.core.eventbus.Message#headers}
   *  at the recipient.
   * @param key  the header key
   * @param value  the header value
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  headers: string;

  /**
   * Set the send timeout.
   * @param timeout  the timeout value, in ms.
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  sendTimeout: number;
}


export class DeploymentOptions {

  /**
   * Set the JSON configuration that will be passed to the verticle(s) when it's deployed
   * @param config  the JSON config
   * @return a reference to this, so the API can be used fluently
   * 
   */
  config: object;

  /**
   * Set any extra classpath to be used when deploying the verticle.
   *  <p>
   *  Ignored if no isolation group is set.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  extraClasspath: string;

  /**
   * Set whether the verticle(s) will be deployed as HA.
   * @param ha  true if to be deployed as HA, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  ha: boolean;

  /**
   * Set the number of instances that should be deployed.
   * @param instances  the number of instances
   * @return a reference to this, so the API can be used fluently
   * 
   */
  instances: number;

  /**
   * Set the isolated class names.
   * @param isolatedClasses the list of isolated class names
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isolatedClasses: string;

  /**
   * Set the isolation group that will be used when deploying the verticle(s)
   * @param isolationGroup - the isolation group
   * @return a reference to this, so the API can be used fluently
   * 
   */
  isolationGroup: string;

  /**
   * Sets the value of max worker execute time, in ns.
   * @param maxWorkerExecuteTime the value of max worker execute time, in ns.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxWorkerExecuteTime: number;

  /**
   * Set whether the verticle(s) should be deployed as a multi-threaded worker verticle
   * @param multiThreaded true for multi-threaded worker, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  multiThreaded: boolean;

  /**
   * Set whether the verticle(s) should be deployed as a worker verticle
   * @param worker true for worker, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  worker: boolean;

  /**
   * Set the worker pool name to use for this verticle. When no name is set, the Vert.x
   *  worker pool will be used, when a name is set, the verticle will use a named worker pool.
   * @param workerPoolName the worker pool name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  workerPoolName: string;

  /**
   * Set the maximum number of worker threads to be used by the Vert.x instance.
   * @param workerPoolSize the number of threads
   * @return a reference to this, so the API can be used fluently
   * 
   */
  workerPoolSize: number;
}


export class DnsClientOptions {

  /**
   * Set the host name to be used by this client in requests.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  host: string;

  /**
   * Set the port to be used by this client in requests.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  port: number;

  /**
   * Set the query timeout in milliseconds, i.e the amount of time after a query is considered to be failed.
   * @param queryTimeout the query timeout in milliseconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  queryTimeout: number;
}

import { ClientAuth } from './enums';

export class EventBusOptions {

  /**
   * Set the accept back log.
   * @param acceptBacklog accept backlog
   * @return a reference to this, so the API can be used fluently
   * @see NetServerOptions#setAcceptBacklog(int)
   * 
   */
  acceptBacklog: number;

  /**
   * Set whether client auth is required
   * @param clientAuth One of "NONE, REQUEST, REQUIRED". If it's set to "REQUIRED" then server will require the
   *                    SSL cert to be presented otherwise it won't accept the request. If it's set to "REQUEST" then
   *                    it won't mandate the certificate to be presented, basically make it optional.
   * @return a reference to this, so the API can be used fluently
   * @see NetServerOptions#setClientAuth(ClientAuth)
   * 
   */
  clientAuth: ClientAuth;

  /**
   * Set the value of cluster ping interval, in ms.
   * @param clusterPingInterval The value of cluster ping interval, in ms.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clusterPingInterval: number;

  /**
   * Set the value of cluster ping reply interval, in ms.
   * @param clusterPingReplyInterval The value of cluster ping reply interval, in ms.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clusterPingReplyInterval: number;

  /**
   * Set the public facing hostname to be used for clustering.
   *  Sometimes, e.g. when running on certain clouds, the local address the server listens on for clustering is
   *  not the same address that other nodes connect to it at, as the OS / cloud infrastructure does some kind of
   *  proxying. If this is the case you can specify a public hostname which is different from the hostname the
   *  server listens at.
   *  <p>
   *  The default value is null which means use the same as the cluster hostname.
   * @param clusterPublicHost the public host name to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clusterPublicHost: string;

  /**
   * See {@link #setClusterPublicHost(String)} for an explanation.
   * @param clusterPublicPort  the public port to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clusterPublicPort: number;

  /**
   * Sets whether or not the event bus is clustered.
   * @param clustered {@code true} to start the event bus as a clustered event bus.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clustered: boolean;

  /**
   * Sets the connect timeout
   * @param connectTimeout connect timeout, in ms
   * @return a reference to this, so the API can be used fluently
   * @see NetClientOptions#setConnectTimeout(int)
   * 
   */
  connectTimeout: number;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  crlPaths: string;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  crlValues: Buffer;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  enabledCipherSuites: string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  enabledSecureTransportProtocols: string;

  /**
   * Sets the host.
   * @param host the host
   * @return a reference to this, so the API can be used fluently
   * @see NetServerOptions#setHost(String)
   * 
   */
  host: string;

  /**
   * Set the idle timeout, in seconds. zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  idleTimeout: number;

  jdkSslEngineOptions: JdkSSLEngineOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  keyStoreOptions: JksOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  logActivity: boolean;

  openSslEngineOptions: OpenSSLEngineOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pemKeyCertOptions: PemKeyCertOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pemTrustOptions: PemTrustOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pfxKeyCertOptions: PfxOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pfxTrustOptions: PfxOptions;

  /**
   * Sets the port.
   * @param port the port
   * @return a reference to this, so the API can be used fluently
   * @see NetServerOptions#setPort(int)
   * 
   */
  port: number;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  receiveBufferSize: number;

  /**
   * Sets the value of reconnect attempts.
   * @param attempts the maximum number of reconnect attempts
   * @return a reference to this, so the API can be used fluently
   * @see NetClientOptions#setReconnectAttempts(int)
   * 
   */
  reconnectAttempts: number;

  /**
   * Set the reconnect interval.
   * @param interval the reconnect interval in ms
   * @return a reference to this, so the API can be used fluently
   * @see NetClientOptions#setReconnectInterval(long)
   * 
   */
  reconnectInterval: number;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reuseAddress: boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reusePort: boolean;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendBufferSize: number;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  soLinger: number;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  ssl: boolean;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  tcpCork: boolean;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  tcpFastOpen: boolean;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  tcpKeepAlive: boolean;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  tcpNoDelay: boolean;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  tcpQuickAck: boolean;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trafficClass: number;

  /**
   * Set whether all server certificates should be trusted.
   * @param trustAll true if all should be trusted
   * @return a reference to this, so the API can be used fluently
   * @see NetClientOptions#setTrustAll(boolean)
   * 
   */
  trustAll: boolean;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trustStoreOptions: JksOptions;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  useAlpn: boolean;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  usePooledBuffers: boolean;
}


export class GoAway {

  /**
   * Set the additional debug data
   * @param debugData the data
   * @return a reference to this, so the API can be used fluently
   * 
   */
  debugData: Buffer;

  /**
   *
   * @return the {@literal GOAWAY} error code
   * 
   */
  errorCode: number;

  /**
   * Set the last stream id.
   * @param lastStreamId the last stream id
   * @return a reference to this, so the API can be used fluently
   * 
   */
  lastStreamId: number;
}


export class Http2Settings {

  /**
   * Set {@literal SETTINGS_HEADER_TABLE_SIZE} HTTP/2 setting.
   * @param headerTableSize the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  headerTableSize: number;

  /**
   * Set the {@literal SETTINGS_INITIAL_WINDOW_SIZE} HTTP/2 setting
   * @param initialWindowSize the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  initialWindowSize: number;

  /**
   * Set the {@literal SETTINGS_MAX_CONCURRENT_STREAMS} HTTP/2 setting
   * @param maxConcurrentStreams the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxConcurrentStreams: number;

  /**
   * Set the {@literal SETTINGS_MAX_FRAME_SIZE} HTTP/2 setting
   * @param maxFrameSize the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxFrameSize: number;

  /**
   * Set the {@literal SETTINGS_MAX_HEADER_LIST_SIZE} HTTP/2 setting
   * @param maxHeaderListSize the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxHeaderListSize: number;

  /**
   * Set the {@literal SETTINGS_ENABLE_PUSH} HTTP/2 setting
   * @param pushEnabled the new value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pushEnabled: boolean;
}

import { HttpVersion } from './enums';

export class HttpClientOptions {

  /**
   * Set the list of protocol versions to provide to the server during the Application-Layer Protocol Negotiation.
   *  When the list is empty, the client provides a best effort list according to {@link #setProtocolVersion}:
   * 
   *  <ul>
   *    <li>{@link HttpVersion#HTTP_2}: [ "h2", "http/1.1" ]</li>
   *    <li>otherwise: [{@link #getProtocolVersion()}]</li>
   *  </ul>
   * @param alpnVersions the versions
   * @return a reference to this, so the API can be used fluently
   * 
   */
  alpnVersions: HttpVersion;

  /**
   * Set the connect timeout
   * @param connectTimeout  connect timeout, in ms
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connectTimeout: number;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  crlPaths: string;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  crlValues: Buffer;

  /**
   * set to {@code initialBufferSizeHttpDecoder} the initial buffer of the HttpDecoder.
   * @param decoderInitialBufferSize the initial buffer size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  decoderInitialBufferSize: number;

  /**
   * Set the default host name to be used by this client in requests if none is provided when making the request.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  defaultHost: string;

  /**
   * Set the default port to be used by this client in requests if none is provided when making the request.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  defaultPort: number;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  enabledCipherSuites: string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  enabledSecureTransportProtocols: string;

  /**
   * By default, the server name is only sent for Fully Qualified Domain Name (FQDN), setting
   *  this property to {@code true} forces the server name to be always sent.
   * @param forceSni true when the client should always use SNI on TLS/SSL connections
   * @return a reference to this, so the API can be used fluently
   * 
   */
  forceSni: boolean;

  /**
   * Set to {@code true} when an <i>h2c</i> connection is established using an HTTP/1.1 upgrade request, and {@code false}
   *  when an <i>h2c</i> connection is established directly (with prior knowledge).
   * @param value the upgrade value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  http2ClearTextUpgrade: boolean;

  /**
   * Set the default HTTP/2 connection window size. It overrides the initial window
   *  size set by {@link Http2Settings#getInitialWindowSize}, so the connection window size
   *  is greater than for its streams, in order the data throughput.
   *  <p/>
   *  A value of {@code -1} reuses the initial window size setting.
   * @param http2ConnectionWindowSize the window size applied to the connection
   * @return a reference to this, so the API can be used fluently
   * 
   */
  http2ConnectionWindowSize: number;

  /**
   * Set the keep alive timeout for HTTP/2 connections, in seconds.
   *  <p/>
   *  This value determines how long a connection remains unused in the pool before being evicted and closed.
   * @param keepAliveTimeout the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  http2KeepAliveTimeout: number;

  /**
   * Set the maximum pool size for HTTP/2 connections
   * @param max  the maximum pool size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  http2MaxPoolSize: number;

  /**
   * Set a client limit of the number concurrent streams for each HTTP/2 connection, this limits the number
   *  of streams the client can create for a connection. The effective number of streams for a
   *  connection is the min of this value and the server's initial settings.
   *  <p/>
   *  Setting the value to {@code -1} means to use the value sent by the server's initial settings.
   *  {@code -1} is the default value.
   * @param limit the maximum concurrent for an HTTP/2 connection
   * @return a reference to this, so the API can be used fluently
   * 
   */
  http2MultiplexingLimit: number;

  /**
   * Set the idle timeout, in seconds. zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  idleTimeout: number;

  /**
   * Set the HTTP/2 connection settings immediately sent by to the server when the client connects.
   * @param settings the settings value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  initialSettings: Http2Settings;

  jdkSslEngineOptions: JdkSSLEngineOptions;

  /**
   * Set whether keep alive is enabled on the client
   * @param keepAlive  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  keepAlive: boolean;

  /**
   * Set the keep alive timeout for HTTP/1.x, in seconds.
   *  <p/>
   *  This value determines how long a connection remains unused in the pool before being evicted and closed.
   * @param keepAliveTimeout the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  keepAliveTimeout: number;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  keyStoreOptions: JksOptions;

  /**
   * Set the local interface to bind for network connections. When the local address is null,
   *  it will pick any local address, the default local address is null.
   * @param localAddress the local address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  localAddress: string;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  logActivity: boolean;

  /**
   * Set the maximum HTTP chunk size
   * @param maxChunkSize the maximum chunk size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxChunkSize: number;

  /**
   * Set the maximum length of all headers for HTTP/1.x .
   * @param maxHeaderSize the new maximum length
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxHeaderSize: number;

  /**
   * Set the maximum length of the initial line for HTTP/1.x (e.g. {@code "HTTP/1.1 200 OK"})
   * @param maxInitialLineLength the new maximum initial length
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxInitialLineLength: number;

  /**
   * Set the maximum pool size for connections
   * @param maxPoolSize  the maximum pool size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxPoolSize: number;

  /**
   * Set to {@code maxRedirects} the maximum number of redirection a request can follow.
   * @param maxRedirects the maximum number of redirection
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxRedirects: number;

  /**
   * Set the maximum requests allowed in the wait queue, any requests beyond the max size will result in
   *  a ConnectionPoolTooBusyException.  If the value is set to a negative number then the queue will be unbounded.
   * @param maxWaitQueueSize the maximum number of waiting requests
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxWaitQueueSize: number;

  /**
   * Set the max websocket frame size
   * @param maxWebsocketFrameSize  the max frame size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxWebsocketFrameSize: number;

  /**
   * Set the max websocket message size
   * @param maxWebsocketMessageSize  the max message size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxWebsocketMessageSize: number;

  /**
   * Set the metrics name identifying the reported metrics, useful for grouping metrics
   *  with the same name.
   * @param metricsName the metrics name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  metricsName: string;

  openSslEngineOptions: OpenSSLEngineOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pemKeyCertOptions: PemKeyCertOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pemTrustOptions: PemTrustOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pfxKeyCertOptions: PfxOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pfxTrustOptions: PfxOptions;

  /**
   * Set whether pipe-lining is enabled on the client
   * @param pipelining  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pipelining: boolean;

  /**
   * Set the limit of pending requests a pipe-lined HTTP/1 connection can send.
   * @param limit the limit of pending requests
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pipeliningLimit: number;

  /**
   * Set the connection pool cleaner period in milli seconds, a non positive value disables expiration checks and connections
   *  will remain in the pool until they are closed.
   * @param poolCleanerPeriod the pool cleaner period
   * @return a reference to this, so the API can be used fluently
   * 
   */
  poolCleanerPeriod: number;

  /**
   * Set the protocol version.
   * @param protocolVersion the protocol version
   * @return a reference to this, so the API can be used fluently
   * 
   */
  protocolVersion: HttpVersion;

  /**
   * Set proxy options for connections via CONNECT proxy (e.g. Squid) or a SOCKS proxy.
   * @param proxyOptions proxy options object
   * @return a reference to this, so the API can be used fluently
   * 
   */
  proxyOptions: ProxyOptions;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  receiveBufferSize: number;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reuseAddress: boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reusePort: boolean;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendBufferSize: number;

  /**
   * Set true when the client wants to skip frame masking.
   *  You may want to set it true on server by server websocket communication: In this case you are by passing RFC6455 protocol.
   *  It's false as default.
   * @param sendUnmaskedFrames  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendUnmaskedFrames: boolean;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  soLinger: number;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  ssl: boolean;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  tcpCork: boolean;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  tcpFastOpen: boolean;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  tcpKeepAlive: boolean;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  tcpNoDelay: boolean;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  tcpQuickAck: boolean;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trafficClass: number;

  /**
   * Set whether all server certificates should be trusted
   * @param trustAll true if all should be trusted
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trustAll: boolean;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trustStoreOptions: JksOptions;

  /**
   * Set whether compression is enabled
   * @param tryUseCompression  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  tryUseCompression: boolean;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  useAlpn: boolean;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  usePooledBuffers: boolean;

  /**
   * Set whether hostname verification is enabled
   * @param verifyHost  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  verifyHost: boolean;
}


export class HttpServerOptions {

  /**
   * Set the accept back log
   * @param acceptBacklog accept backlog
   * @return a reference to this, so the API can be used fluently
   * 
   */
  acceptBacklog: number;

  /**
   * Set true when the server accepts unmasked frame.
   *  As default Server doesn't accept unmasked frame, you can bypass this behaviour (RFC 6455) setting true
   *  It's set to false as default.
   * @param acceptUnmaskedFrames  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  acceptUnmaskedFrames: boolean;

  /**
   * Set the list of protocol versions to provide to the server during the Application-Layer Protocol Negotiatiation.
   * @param alpnVersions the versions
   * @return a reference to this, so the API can be used fluently
   * 
   */
  alpnVersions: HttpVersion;

  /**
   * Set whether client auth is required
   * @param clientAuth One of "NONE, REQUEST, REQUIRED". If it's set to "REQUIRED" then server will require the
   *                    SSL cert to be presented otherwise it won't accept the request. If it's set to "REQUEST" then
   *                    it won't mandate the certificate to be presented, basically make it optional.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clientAuth: ClientAuth;

  /**
   * Set whether client auth is required
   * @param clientAuthRequired  true if client auth is required
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clientAuthRequired: boolean;

  /**
   * This method allows to set the compression level to be used in http1.x/2 response bodies
   *  when compression support is turned on (@see setCompressionSupported) and the client advertises
   *  to support {@code deflate/gzip} compression in the {@code Accept-Encoding} header
   * 
   *  default value is : 6 (Netty legacy)
   * 
   *  The compression level determines how much the data is compressed on a scale from 1 to 9,
   *  where '9' is trying to achieve the maximum compression ratio while '1' instead is giving
   *  priority to speed instead of compression ratio using some algorithm optimizations and skipping
   *  pedantic loops that usually gives just little improvements
   * 
   *  While one can think that best value is always the maximum compression ratio,
   *  there's a trade-off to consider: the most compressed level requires the most
   *  computational work to compress/decompress data, e.g. more dictionary lookups and loops.
   * 
   *  E.g. you have it set fairly high on a high-volume website, you may experience performance degradation
   *  and latency on resource serving due to CPU overload, and, however - as the computational work is required also client side
   *  while decompressing - setting an higher compression level can result in an overall higher page load time
   *  especially nowadays when many clients are handled mobile devices with a low CPU profile.
   * 
   *  see also: http://www.gzip.org/algorithm.txt
   * @param compressionLevel integer 1-9, 1 means use fastest algorithm, 9 slower algorithm but better compression ratio
   * @return a reference to this, so the API can be used fluently
   * 
   */
  compressionLevel: number;

  /**
   * Set whether the server should support gzip/deflate compression
   *  (serving compressed responses to clients advertising support for them with Accept-Encoding header)
   * @param compressionSupported true to enable compression support
   * @return a reference to this, so the API can be used fluently
   * 
   */
  compressionSupported: boolean;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  crlPaths: string;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  crlValues: Buffer;

  /**
   * Set the initial buffer size for the HTTP decoder
   * @param decoderInitialBufferSize the initial size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  decoderInitialBufferSize: number;

  /**
   * Set whether the server supports decompression
   * @param decompressionSupported true if decompression supported
   * @return a reference to this, so the API can be used fluently
   * 
   */
  decompressionSupported: boolean;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  enabledCipherSuites: string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  enabledSecureTransportProtocols: string;

  /**
   * Set whether 100 Continue should be handled automatically
   * @param handle100ContinueAutomatically true if it should be handled automatically
   * @return a reference to this, so the API can be used fluently
   * 
   */
  handle100ContinueAutomatically: boolean;

  /**
   * Set the host
   * @param host  the host
   * @return a reference to this, so the API can be used fluently
   * 
   */
  host: string;

  /**
   * Set the default HTTP/2 connection window size. It overrides the initial window
   *  size set by {@link Http2Settings#getInitialWindowSize}, so the connection window size
   *  is greater than for its streams, in order the data throughput.
   *  <p/>
   *  A value of {@code -1} reuses the initial window size setting.
   * @param http2ConnectionWindowSize the window size applied to the connection
   * @return a reference to this, so the API can be used fluently
   * 
   */
  http2ConnectionWindowSize: number;

  /**
   * Set the idle timeout, in seconds. zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  idleTimeout: number;

  /**
   * Set the HTTP/2 connection settings immediatly sent by the server when a client connects.
   * @param settings the settings value
   * @return a reference to this, so the API can be used fluently
   * 
   */
  initialSettings: Http2Settings;

  jdkSslEngineOptions: JdkSSLEngineOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  keyStoreOptions: JksOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  logActivity: boolean;

  /**
   * Set the maximum HTTP chunk size
   * @param maxChunkSize the maximum chunk size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxChunkSize: number;

  /**
   * Set the maximum length of all headers for HTTP/1.x .
   * @param maxHeaderSize the new maximum length
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxHeaderSize: number;

  /**
   * Set the maximum length of the initial line for HTTP/1.x (e.g. {@code "GET / HTTP/1.0"})
   * @param maxInitialLineLength the new maximum initial length
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxInitialLineLength: number;

  /**
   * Set the maximum websocket frames size
   * @param maxWebsocketFrameSize  the maximum frame size in bytes.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxWebsocketFrameSize: number;

  /**
   * Set the maximum websocket message size
   * @param maxWebsocketMessageSize  the maximum message size in bytes.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxWebsocketMessageSize: number;

  openSslEngineOptions: OpenSSLEngineOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pemKeyCertOptions: PemKeyCertOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pemTrustOptions: PemTrustOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pfxKeyCertOptions: PfxOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pfxTrustOptions: PfxOptions;

  /**
   * Set the port
   * @param port  the port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  port: number;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  receiveBufferSize: number;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reuseAddress: boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reusePort: boolean;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendBufferSize: number;

  /**
   * Set whether the server supports Server Name Indiciation
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sni: boolean;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  soLinger: number;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  ssl: boolean;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  tcpCork: boolean;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  tcpFastOpen: boolean;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  tcpKeepAlive: boolean;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  tcpNoDelay: boolean;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  tcpQuickAck: boolean;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trafficClass: number;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trustStoreOptions: JksOptions;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  useAlpn: boolean;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  usePooledBuffers: boolean;

  /**
   * Set the websocket subprotocols supported by the server.
   * @param subProtocols  comma separated list of subprotocols
   * @return a reference to this, so the API can be used fluently
   * 
   */
  websocketSubProtocols: string;
}


export class JdkSSLEngineOptions {
}


export class JksOptions {

  /**
   * Set the password for the key store
   * @param password  the password
   * @return a reference to this, so the API can be used fluently
   * 
   */
  password: string;

  /**
   * Set the path to the key store
   * @param path  the path
   * @return a reference to this, so the API can be used fluently
   * 
   */
  path: string;

  /**
   * Set the key store as a buffer
   * @param value  the key store as a buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  value: Buffer;
}


export class MetricsOptions {

  /**
   * Set whether metrics will be enabled on the Vert.x instance.
   * @param enable true if metrics enabled, or false if not.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  enabled: boolean;
}


export class NetClientOptions {

  /**
   * Set the connect timeout
   * @param connectTimeout  connect timeout, in ms
   * @return a reference to this, so the API can be used fluently
   * 
   */
  connectTimeout: number;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  crlPaths: string;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  crlValues: Buffer;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  enabledCipherSuites: string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  enabledSecureTransportProtocols: string;

  /**
   * Set the hostname verification algorithm interval
   *  To disable hostname verification, set hostnameVerificationAlgorithm to an empty String
   * @param hostnameVerificationAlgorithm should be HTTPS, LDAPS or an empty String
   * @return a reference to this, so the API can be used fluently
   * 
   */
  hostnameVerificationAlgorithm: string;

  /**
   * Set the idle timeout, in seconds. zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  idleTimeout: number;

  jdkSslEngineOptions: JdkSSLEngineOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  keyStoreOptions: JksOptions;

  /**
   * Set the local interface to bind for network connections. When the local address is null,
   *  it will pick any local address, the default local address is null.
   * @param localAddress the local address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  localAddress: string;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  logActivity: boolean;

  /**
   * Set the metrics name identifying the reported metrics, useful for grouping metrics
   *  with the same name.
   * @param metricsName the metrics name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  metricsName: string;

  openSslEngineOptions: OpenSSLEngineOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pemKeyCertOptions: PemKeyCertOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pemTrustOptions: PemTrustOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pfxKeyCertOptions: PfxOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pfxTrustOptions: PfxOptions;

  /**
   * Set proxy options for connections via CONNECT proxy (e.g. Squid) or a SOCKS proxy.
   * @param proxyOptions proxy options object
   * @return a reference to this, so the API can be used fluently
   * 
   */
  proxyOptions: ProxyOptions;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  receiveBufferSize: number;

  /**
   * Set the value of reconnect attempts
   * @param attempts  the maximum number of reconnect attempts
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reconnectAttempts: number;

  /**
   * Set the reconnect interval
   * @param interval  the reconnect interval in ms
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reconnectInterval: number;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reuseAddress: boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reusePort: boolean;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendBufferSize: number;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  soLinger: number;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  ssl: boolean;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  tcpCork: boolean;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  tcpFastOpen: boolean;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  tcpKeepAlive: boolean;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  tcpNoDelay: boolean;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  tcpQuickAck: boolean;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trafficClass: number;

  /**
   * Set whether all server certificates should be trusted
   * @param trustAll true if all should be trusted
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trustAll: boolean;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trustStoreOptions: JksOptions;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  useAlpn: boolean;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  usePooledBuffers: boolean;
}


export class NetServerOptions {

  /**
   * Set the accept back log
   * @param acceptBacklog accept backlog
   * @return a reference to this, so the API can be used fluently
   * 
   */
  acceptBacklog: number;

  /**
   * Set whether client auth is required
   * @param clientAuth One of "NONE, REQUEST, REQUIRED". If it's set to "REQUIRED" then server will require the
   *                    SSL cert to be presented otherwise it won't accept the request. If it's set to "REQUEST" then
   *                    it won't mandate the certificate to be presented, basically make it optional.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clientAuth: ClientAuth;

  /**
   * Set whether client auth is required
   * @param clientAuthRequired  true if client auth is required
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clientAuthRequired: boolean;

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  crlPaths: string;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  crlValues: Buffer;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  enabledCipherSuites: string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  enabledSecureTransportProtocols: string;

  /**
   * Set the host
   * @param host  the host
   * @return a reference to this, so the API can be used fluently
   * 
   */
  host: string;

  /**
   * Set the idle timeout, in seconds. zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  idleTimeout: number;

  jdkSslEngineOptions: JdkSSLEngineOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  keyStoreOptions: JksOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  logActivity: boolean;

  openSslEngineOptions: OpenSSLEngineOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pemKeyCertOptions: PemKeyCertOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pemTrustOptions: PemTrustOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pfxKeyCertOptions: PfxOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pfxTrustOptions: PfxOptions;

  /**
   * Set the port
   * @param port  the port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  port: number;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  receiveBufferSize: number;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reuseAddress: boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reusePort: boolean;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendBufferSize: number;

  /**
   * Set whether the server supports Server Name Indiciation
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sni: boolean;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  soLinger: number;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  ssl: boolean;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  tcpCork: boolean;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  tcpFastOpen: boolean;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  tcpKeepAlive: boolean;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  tcpNoDelay: boolean;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  tcpQuickAck: boolean;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trafficClass: number;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trustStoreOptions: JksOptions;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  useAlpn: boolean;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  usePooledBuffers: boolean;
}


export interface NetworkOptions {

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  logActivity: boolean;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  receiveBufferSize: number;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reuseAddress: boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reusePort: boolean;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendBufferSize: number;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trafficClass: number;
}


export class OpenOptions {

  /**
   * Whether the file should be opened in append mode. Defaults to {@code false}.
   * @param append true to open file in append mode, false otherwise
   * @return a reference to this, so the API can be used fluently
   * 
   */
  append: boolean;

  /**
   * Set whether the file should be created if it does not already exist.
   * @param create  true if the file should be created if it does not already exist
   * @return a reference to this, so the API can be used fluently
   * 
   */
  create: boolean;

  /**
   * Set whether the file should be created and fail if it does exist already.
   * @param createNew  true if the file should be created or fail if it exists already
   * @return a reference to this, so the API can be used fluently
   * 
   */
  createNew: boolean;

  /**
   * Set whether the file should be deleted when it's closed, or the JVM is shutdown.
   * @param deleteOnClose whether the file should be deleted when it's closed, or the JVM is shutdown.
   * @return  a reference to this, so the API can be used fluently
   * 
   */
  deleteOnClose: boolean;

  /**
   * Set whether every write to the file's content  ill be written synchronously to the underlying hardware.
   * @param dsync  true if sync
   * @return a reference to this, so the API can be used fluently
   * 
   */
  dsync: boolean;

  /**
   * Set the permissions string
   * @param perms  the permissions string
   * @return a reference to this, so the API can be used fluently
   * 
   */
  perms: string;

  /**
   * Set whether the file is to be opened for reading
   * @param read  true if the file is to be opened for reading
   * @return a reference to this, so the API can be used fluently
   * 
   */
  read: boolean;

  /**
   * Set whether a hint should be provided that the file to created is sparse
   * @param sparse true if a hint should be provided that the file to created is sparse
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sparse: boolean;

  /**
   * Set whether every write to the file's content and meta-data will be written synchronously to the underlying hardware.
   * @param sync  true if sync
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sync: boolean;

  /**
   * Set whether the file should be truncated to zero length on opening if it exists and is opened for write
   * @param truncateExisting  true if the file should be truncated to zero length on opening if it exists and is opened for write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  truncateExisting: boolean;

  /**
   * Set whether the file is to be opened for writing
   * @param write  true if the file is to be opened for writing
   * @return a reference to this, so the API can be used fluently
   * 
   */
  write: boolean;
}


export class OpenSSLEngineOptions {

  /**
   * Set whether session cache is enabled in open SSL session server context
   * @param sessionCacheEnabled true if session cache is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sessionCacheEnabled: boolean;
}


export class Option {

  /**
   * Sets te arg name for this option.
   * @param argName the arg name, must not be {@code null}
   * @return the current {@link Option} instance
   * 
   */
  argName: string;

  /**
   * Sets the list of values accepted by this option. If the value set by the user does not match once of these
   *  values, a {@link InvalidValueException} exception is thrown.
   * @param choices the choices
   * @return the current {@link Option}
   * 
   */
  choices: string;

  /**
   * Sets the default value of this option
   * @param defaultValue the default value
   * @return the current {@link Option} instance
   * 
   */
  defaultValue: string;

  /**
   * Sets te description of this option.
   * @param description the description
   * @return the current {@link Option} instance
   * 
   */
  description: string;

  /**
   * Configures the current {@link Option} to be a flag. It will be evaluated to {@code true} if it's found in
   *  the command line. If you need a flag that may receive a value, use, in this order:
   *  <code><pre>
   *    option.setFlag(true).setSingleValued(true)
   *  </pre></code>
   * @param flag whether or not the option is a flag.
   * @return the current {@link Option}
   * 
   */
  flag: boolean;

  /**
   * Sets whether or not this option is a "help" option
   * @param help {@code true} to set this option as a "Help" option
   * @return the current {@link Option}
   * 
   */
  help: boolean;

  /**
   * Sets whether or not this option should be hidden
   * @param hidden {@code true} to make this option hidden, {@link false} otherwise
   * @return the current {@link Option} instance
   * 
   */
  hidden: boolean;

  /**
   * Sets the long name of this option.
   * @param longName the long name
   * @return the current {@link Option} instance
   * 
   */
  longName: string;

  /**
   * Sets whether or not this option can receive several values.
   * @param multiValued whether or not this option is multi-valued.
   * @return the current {@link Option} instance
   * 
   */
  multiValued: boolean;

  /**
   * Sets whether or not this option is mandatory.
   * @param required {@code true} to make this option mandatory, {@link false} otherwise
   * @return the current {@link Option} instance
   * 
   */
  required: boolean;

  /**
   * Sets the short name of this option.
   * @param shortName the short name
   * @return the current {@link Option} instance
   * 
   */
  shortName: string;

  /**
   * Sets whether or not this option can receive a value.
   * @param singleValued whether or not this option is single-valued.
   * @return the current {@link Option} instance
   * 
   */
  singleValued: boolean;
}


export class PemKeyCertOptions {

  /**
   * Set the path of the first certificate, replacing the previous certificates paths
   * @param certPath  the path to the certificate
   * @return a reference to this, so the API can be used fluently
   * 
   */
  certPath: string;

  /**
   * Set all the paths to the certificates files
   * @param certPaths  the paths to the certificates files
   * @return a reference to this, so the API can be used fluently
   * 
   */
  certPaths: string;

  /**
   * Set the first certificate as a buffer, replacing the previous certificates buffers
   * @param certValue  the first certificate as a buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  certValue: Buffer;

  /**
   * Set all the certificates as a list of buffer
   * @param certValues  the certificates as a list of buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  certValues: Buffer;

  /**
   * Set the path of the first key file, replacing the keys paths
   * @param keyPath  the path to the first key file
   * @return a reference to this, so the API can be used fluently
   * 
   */
  keyPath: string;

  /**
   * Set all the paths to the keys files
   * @param keyPaths  the paths to the keys files
   * @return a reference to this, so the API can be used fluently
   * 
   */
  keyPaths: string;

  /**
   * Set the first key a a buffer, replacing the previous keys buffers
   * @param keyValue  key as a buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  keyValue: Buffer;

  /**
   * Set all the keys as a list of buffer
   * @param keyValues  the keys as a list of buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  keyValues: Buffer;
}


export class PemTrustOptions {

  /**
   * Add a certificate path
   * @param certPath  the path to add
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  certPaths: string;

  /**
   * Add a certificate value
   * @param certValue  the value to add
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  certValues: Buffer;
}


export class PfxOptions {

  /**
   * Set the password
   * @param password  the password
   * @return a reference to this, so the API can be used fluently
   * 
   */
  password: string;

  /**
   * Set the path
   * @param path  the path
   * @return a reference to this, so the API can be used fluently
   * 
   */
  path: string;

  /**
   * Set the store as a buffer
   * @param value  the store as a buffer
   * @return a reference to this, so the API can be used fluently
   * 
   */
  value: Buffer;
}

import { ProxyType } from './enums';

export class ProxyOptions {

  /**
   * Set proxy host.
   * @param host the proxy host to connect to
   * @return a reference to this, so the API can be used fluently
   * 
   */
  host: string;

  /**
   * Set proxy password.
   * @param password the proxy password
   * @return a reference to this, so the API can be used fluently
   * 
   */
  password: string;

  /**
   * Set proxy port.
   * @param port the proxy port to connect to
   * @return a reference to this, so the API can be used fluently
   * 
   */
  port: number;

  /**
   * Set proxy type.
   * 
   *  <p>ProxyType can be HTTP, SOCKS4 and SOCKS5
   * @param type the proxy type to connect to
   * @return a reference to this, so the API can be used fluently
   * 
   */
  type: ProxyType;

  /**
   * Set proxy username.
   * @param username the proxy username
   * @return a reference to this, so the API can be used fluently
   * 
   */
  username: string;
}


export class RequestOptions {

  /**
   * Set the host name to be used by the client request.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  host: string;

  /**
   * Set the port to be used by the client request.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  port: number;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  ssl: boolean;

  /**
   * Set the request relative URI
   * @param uri  the relative uri
   * @return a reference to this, so the API can be used fluently
   * 
   */
  uri: string;
}


export interface TCPSSLOptions {

  /**
   * Add a CRL path
   * @param crlPath  the path
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  crlPaths: string;

  /**
   * Add a CRL value
   * @param crlValue  the value
   * @return a reference to this, so the API can be used fluently
   * @throws NullPointerException
   * 
   */
  crlValues: Buffer;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   * @param suite  the suite
   * @return a reference to this, so the API can be used fluently
   * 
   */
  enabledCipherSuites: string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable
   * @return a reference to this, so the API can be used fluently
   * 
   */
  enabledSecureTransportProtocols: string;

  /**
   * Set the idle timeout, in seconds. zero means don't timeout.
   *  This determines if a connection will timeout and be closed if no data is received within the timeout.
   * @param idleTimeout  the timeout, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  idleTimeout: number;

  jdkSslEngineOptions: JdkSSLEngineOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   * @param options the key store in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  keyStoreOptions: JksOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   * @param logActivity true for logging the network activity
   * @return a reference to this, so the API can be used fluently
   * 
   */
  logActivity: boolean;

  openSslEngineOptions: OpenSSLEngineOptions;

  /**
   * Set the key/cert store options in pem format.
   * @param options the options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pemKeyCertOptions: PemKeyCertOptions;

  /**
   * Set the trust options in pem format
   * @param options the trust options in pem format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pemTrustOptions: PemTrustOptions;

  /**
   * Set the key/cert options in pfx format.
   * @param options the key cert options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pfxKeyCertOptions: PfxOptions;

  /**
   * Set the trust options in pfx format
   * @param options the trust options in pfx format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pfxTrustOptions: PfxOptions;

  /**
   * Set the TCP receive buffer size
   * @param receiveBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  receiveBufferSize: number;

  /**
   * Set the value of reuse address
   * @param reuseAddress  the value of reuse address
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reuseAddress: boolean;

  /**
   * Set the value of reuse port.
   *  <p/>
   *  This is only supported by native transports.
   * @param reusePort  the value of reuse port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  reusePort: boolean;

  /**
   * Set the TCP send buffer size
   * @param sendBufferSize  the buffers size, in bytes
   * @return a reference to this, so the API can be used fluently
   * 
   */
  sendBufferSize: number;

  /**
   * Set whether SO_linger keep alive is enabled
   * @param soLinger true if SO_linger is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  soLinger: number;

  /**
   * Set whether SSL/TLS is enabled
   * @param ssl  true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  ssl: boolean;

  /**
   * Enable the {@code TCP_CORK} option - only with linux native transport.
   * @param tcpCork the cork value
   * 
   */
  tcpCork: boolean;

  /**
   * Enable the {@code TCP_FASTOPEN} option - only with linux native transport.
   * @param tcpFastOpen the fast open value
   * 
   */
  tcpFastOpen: boolean;

  /**
   * Set whether TCP keep alive is enabled
   * @param tcpKeepAlive true if TCP keep alive is enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  tcpKeepAlive: boolean;

  /**
   * Set whether TCP no delay is enabled
   * @param tcpNoDelay true if TCP no delay is enabled (Nagle disabled)
   * @return a reference to this, so the API can be used fluently
   * 
   */
  tcpNoDelay: boolean;

  /**
   * Enable the {@code TCP_QUICKACK} option - only with linux native transport.
   * @param tcpQuickAck the quick ack value
   * 
   */
  tcpQuickAck: boolean;

  /**
   * Set the value of traffic class
   * @param trafficClass  the value of traffic class
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trafficClass: number;

  /**
   * Set the trust options in jks format, aka Java truststore
   * @param options the trust options in jks format
   * @return a reference to this, so the API can be used fluently
   * 
   */
  trustStoreOptions: JksOptions;

  /**
   * Set the ALPN usage.
   * @param useAlpn true when Application-Layer Protocol Negotiation should be used
   * 
   */
  useAlpn: boolean;

  /**
   * Set whether Netty pooled buffers are enabled
   * @param usePooledBuffers true if pooled buffers enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  usePooledBuffers: boolean;
}


export class VertxOptions {

  /**
   * Sets the address resolver configuration to configure resolving DNS servers, cache TTL, etc...
   * @param addressResolverOptions the address resolver options
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addressResolverOptions: AddressResolverOptions;

  /**
   * Sets the value of blocked thread check period, in ms.
   * @param blockedThreadCheckInterval the value of blocked thread check period, in ms.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  blockedThreadCheckInterval: number;

  /**
   * Set the hostname to be used for clustering.
   * @param clusterHost the host name to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clusterHost: string;

  /**
   * Set the value of cluster ping interval, in ms.
   * @param clusterPingInterval The value of cluster ping interval, in ms.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clusterPingInterval: number;

  /**
   * Set the value of cluster ping reply interval, in ms.
   * @param clusterPingReplyInterval The value of cluster ping reply interval, in ms.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clusterPingReplyInterval: number;

  /**
   * Set the port to be used for clustering.
   * @param clusterPort the port
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clusterPort: number;

  /**
   * Set the public facing hostname to be used for clustering.
   *  Sometimes, e.g. when running on certain clouds, the local address the server listens on for clustering is not the same
   *  address that other nodes connect to it at, as the OS / cloud infrastructure does some kind of proxying.
   *  If this is the case you can specify a public hostname which is different from the hostname the server listens at.
   *  The default value is null which means use the same as the cluster hostname.
   * @param clusterPublicHost the public host name to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clusterPublicHost: string;

  /**
   * See {@link #setClusterPublicHost(String)} for an explanation.
   * @param clusterPublicPort the public port to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clusterPublicPort: number;

  /**
   * Set whether or not the Vert.x instance will be clustered.
   * @param clustered if true, the Vert.x instance will be clustered, otherwise not
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clustered: boolean;

  /**
   * Sets the event bus configuration to configure the host, port, ssl...
   * @param options the event bus options
   * @return a reference to this, so the API can be used fluently
   * 
   */
  eventBusOptions: EventBusOptions;

  /**
   * Set the number of event loop threads to be used by the Vert.x instance.
   * @param eventLoopPoolSize the number of threads
   * @return a reference to this, so the API can be used fluently
   * 
   */
  eventLoopPoolSize: number;

  /**
   * Set wether the Vert.x file resolver uses caching for classpath resources.
   * @param fileResolverCachingEnabled true when the file resolver caches resources
   * @return a reference to this, so the API can be used fluently
   * 
   */
  fileResolverCachingEnabled: boolean;

  /**
   * Set whether HA will be enabled on the Vert.x instance.
   * @param haEnabled true if enabled, false if not.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  haEnabled: boolean;

  /**
   * Set the HA group to be used when HA is enabled.
   * @param haGroup the HA group to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  haGroup: string;

  /**
   * Set the value of internal blocking pool size
   * @param internalBlockingPoolSize the maximumn number of threads in the internal blocking pool
   * @return a reference to this, so the API can be used fluently
   * 
   */
  internalBlockingPoolSize: number;

  /**
   * Sets the value of max event loop execute time, in ns.
   * @param maxEventLoopExecuteTime the value of max event loop execute time, in ns.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxEventLoopExecuteTime: number;

  /**
   * Sets the value of max worker execute time, in ns.
   * @param maxWorkerExecuteTime the value of max worker execute time, in ns.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxWorkerExecuteTime: number;

  /**
   * Set the metrics options
   * @param metrics the options
   * @return a reference to this, so the API can be used fluently
   * 
   */
  metricsOptions: MetricsOptions;

  /**
   * Set wether to prefer the native transport to the JDK transport.
   * @param preferNativeTransport {@code true} to prefer the native transport
   * @return a reference to this, so the API can be used fluently
   * 
   */
  preferNativeTransport: boolean;

  /**
   * Set the quorum size to be used when HA is enabled.
   * @param quorumSize the quorum size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  quorumSize: number;

  /**
   * Set the threshold value above this, the blocked warning contains a stack trace.
   * @param warningExceptionTime
   * @return a reference to this, so the API can be used fluently
   * 
   */
  warningExceptionTime: number;

  /**
   * Set the maximum number of worker threads to be used by the Vert.x instance.
   * @param workerPoolSize the number of threads
   * @return a reference to this, so the API can be used fluently
   * 
   */
  workerPoolSize: number;
}

