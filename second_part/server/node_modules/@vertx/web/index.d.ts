import { AsyncResult } from '@vertx/core';

import { User } from '@vertx/auth-common';

export interface AuthHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Add a required authority for this auth handler
   * @param authority  the authority
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAuthority(authority: string) : AuthHandler;

  /**
   *  Add a set of required authorities for this auth handler
   * @param authorities  the set of authorities
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAuthorities(authorities: string[]) : AuthHandler;

  /**
   *  Parses the credentials from the request into a JsonObject. The implementation should
   *  be able to extract the required info for the auth provider in the format the provider
   *  expects.
   * @param context the routing context
   * @param handler the handler to be called once the information is available.
   * 
   */
  parseCredentials(context: RoutingContext, handler: (result: AsyncResult<object>) => void) : void;

  /**
   *  Authorizes the given user against all added authorities.
   * @param user a user.
   * @param handler the handler for the result.
   * 
   */
  authorize(user: User, handler: (result: AsyncResult<void>) => void) : void;

}

import { AuthProvider } from '@vertx/auth-common';

export class BasicAuthHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Add a required authority for this auth handler
   * @param authority  the authority
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAuthority(authority: string) : AuthHandler;

  /**
   *  Add a set of required authorities for this auth handler
   * @param authorities  the set of authorities
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAuthorities(authorities: string[]) : AuthHandler;

  /**
   *  Parses the credentials from the request into a JsonObject. The implementation should
   *  be able to extract the required info for the auth provider in the format the provider
   *  expects.
   * @param context the routing context
   * @param handler the handler to be called once the information is available.
   * 
   */
  parseCredentials(context: RoutingContext, handler: (result: AsyncResult<object>) => void) : void;

  /**
   *  Authorizes the given user against all added authorities.
   * @param user a user.
   * @param handler the handler for the result.
   * 
   */
  authorize(user: User, handler: (result: AsyncResult<void>) => void) : void;

  /**
   *  Create a basic auth handler
   * @param authProvider  the auth provider to use
   * @return the auth handler
   * 
   */
  static create(authProvider: AuthProvider) : AuthHandler;

  /**
   *  Create a basic auth handler, specifying realm
   * @param authProvider  the auth service to use
   * @param realm  the realm to use
   * @return the auth handler
   * 
   */
  static create(authProvider: AuthProvider, realm: string) : AuthHandler;

}


export class BodyHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Create a body handler with defaults
   * @return the body handler
   * 
   */
  static create() : BodyHandler;

  /**
   *  Create a body handler and use the given upload directory.
   * @param uploadDirectory  the uploads directory
   * @return the body handler
   * 
   */
  static create(uploadDirectory: string) : BodyHandler;

  /**
   *  Set the maximum body size -1 means unlimited
   * @param bodyLimit  the max size
   * @return reference to this for fluency
   * 
   */
  setBodyLimit(bodyLimit: number) : BodyHandler;

  /**
   *  Set the uploads directory to use
   * @param uploadsDirectory  the uploads directory
   * @return reference to this for fluency
   * 
   */
  setUploadsDirectory(uploadsDirectory: string) : BodyHandler;

  /**
   *  Set whether form attributes will be added to the request parameters
   * @param mergeFormAttributes  true if they should be merged
   * @return reference to this for fluency
   * 
   */
  setMergeFormAttributes(mergeFormAttributes: boolean) : BodyHandler;

  /**
   *  Set whether uploaded files should be removed after handling the request
   * @param deleteUploadedFilesOnEnd  true if uploaded files should be removed after handling the request
   * @return reference to this for fluency
   * 
   */
  setDeleteUploadedFilesOnEnd(deleteUploadedFilesOnEnd: boolean) : BodyHandler;

}

import { BaseBridgeEvent } from '@vertx/bridge-common';
import { Future } from '@vertx/core';
import { BridgeEventType } from '@vertx/bridge-common/enums';

export class BridgeEvent {
  setHandler(arg0: (result: AsyncResult<boolean>) => void) : Future;

  complete(arg0: boolean) : void;

  tryComplete(arg0: boolean) : boolean;

  result() : boolean;

  compose(handler: (result: boolean) => void, next: Future) : Future;

  compose(mapper: (t: boolean) => Future) : Future;

  map(mapper: (t: boolean) => any) : Future;

  completer() : (result: AsyncResult) => void;

  recover(mapper: (t: Error) => Future) : Future;

  otherwise(mapper: (t: Error) => boolean) : Future;

  otherwise(value: boolean) : Future;

  otherwiseEmpty() : Future;

  /**
   *  Get the raw JSON message for the event. This will be null for SOCKET_CREATED or SOCKET_CLOSED events as there is
   *  no message involved.
   * @param message the raw message
   * @return this reference, so it can be used fluently
   * 
   */
  setRawMessage(message: object) : BridgeEvent;

  /**
   *  Get the SockJSSocket instance corresponding to the event
   * @return  the SockJSSocket instance
   * 
   */
  socket() : SockJSSocket;

}


export class CSRFHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Instantiate a new CSRFHandlerImpl with a secret
   *  <p>
   *  <pre>
   *  CSRFHandler.create("s3cr37")
   *  </pre>
   * @param secret server secret to sign the token.
   * 
   */
  static create(secret: string) : CSRFHandler;

  /**
   *  Set the cookie name. By default XSRF-TOKEN is used as it is the expected name by AngularJS however other frameworks
   *  might use other names.
   * @param name a new name for the cookie.
   * @return fluent
   * 
   */
  setCookieName(name: string) : CSRFHandler;

  /**
   *  Set the cookie path. By default / is used.
   * @param path a new path for the cookie.
   * @return fluent
   * 
   */
  setCookiePath(path: string) : CSRFHandler;

  /**
   *  Set the header name. By default X-XSRF-TOKEN is used as it is the expected name by AngularJS however other
   *  frameworks might use other names.
   * @param name a new name for the header.
   * @return fluent
   * 
   */
  setHeaderName(name: string) : CSRFHandler;

  /**
   *  Should the handler give warning messages if this handler is used in other than https protocols?
   * @param nag true to nag
   * @return fluent
   * 
   */
  setNagHttps(nag: boolean) : CSRFHandler;

  /**
   *  Set the body returned by the handler when the XSRF token is missing or invalid.
   * @param responseBody the body of the response. If null, no response body will be returned.
   * @return fluent
   * 
   */
  setResponseBody(responseBody: string) : CSRFHandler;

  /**
   *  Set the timeout for tokens generated by the handler, by default it uses the default from the session handler.
   * @param timeout token timeout
   * @return fluent
   * 
   */
  setTimeout(timeout: number) : CSRFHandler;

}


export class ChainAuthHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Add a required authority for this auth handler
   * @param authority  the authority
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAuthority(authority: string) : AuthHandler;

  /**
   *  Add a set of required authorities for this auth handler
   * @param authorities  the set of authorities
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAuthorities(authorities: string[]) : AuthHandler;

  /**
   *  Parses the credentials from the request into a JsonObject. The implementation should
   *  be able to extract the required info for the auth provider in the format the provider
   *  expects.
   * @param context the routing context
   * @param handler the handler to be called once the information is available.
   * 
   */
  parseCredentials(context: RoutingContext, handler: (result: AsyncResult<object>) => void) : void;

  /**
   *  Authorizes the given user against all added authorities.
   * @param user a user.
   * @param handler the handler for the result.
   * 
   */
  authorize(user: User, handler: (result: AsyncResult<void>) => void) : void;

  static create() : ChainAuthHandler;

  /**
   *  Appends a auth provider to the chain.
   * @param authHandler auth handler
   * @return self
   * 
   * 
   */
  append(authHandler: AuthHandler) : ChainAuthHandler;

  /**
   *  Removes a provider from the chain.
   * @param authHandler provider to remove
   * @return true if provider was removed, false if non existent in the chain.
   * 
   */
  remove(authHandler: AuthHandler) : boolean;

  /**
   *  Clears the chain.
   * 
   */
  clear() : void;

}

import { Vertx } from '@vertx/core';

export class ClusteredSessionStore {
  /**
   *  Create a session store
   * @param vertx  the Vert.x instance
   * @param sessionMapName  the session map name
   * @return the session store
   * 
   */
  static create(vertx: Vertx, sessionMapName: string) : ClusteredSessionStore;

  /**
   *  Create a session store.<p/>
   * 
   *  The retry timeout value, configures how long the session handler will retry to get a session from the store
   *  when it is not found.
   * @param vertx  the Vert.x instance
   * @param sessionMapName  the session map name
   * @param retryTimeout the store retry timeout, in ms
   * @return the session store
   * 
   */
  static create(vertx: Vertx, sessionMapName: string, retryTimeout: number) : ClusteredSessionStore;

  /**
   *  Create a session store
   * @param vertx  the Vert.x instance
   * @return the session store
   * 
   */
  static create(vertx: Vertx) : ClusteredSessionStore;

  /**
   *  Create a session store.<p/>
   * 
   *  The retry timeout value, configures how long the session handler will retry to get a session from the store
   *  when it is not found.
   * @param vertx  the Vert.x instance
   * @param retryTimeout the store retry timeout, in ms
   * @return the session store
   * 
   */
  static create(vertx: Vertx, retryTimeout: number) : ClusteredSessionStore;

}


export class Cookie {
  /**
   *  Create a new cookie
   * @param name  the name of the cookie
   * @param value  the cookie value
   * @return the cookie
   * 
   */
  static cookie(name: string, value: string) : Cookie;

  /**
   * 
   * @return the name of this cookie
   * 
   */
  getName() : string;

  /**
   * 
   * @return the value of this cookie
   * 
   */
  getValue() : string;

  /**
   *  Sets the value of this cookie
   * @param value The value to set
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setValue(value: string) : Cookie;

  /**
   *  Sets the domain of this cookie
   * @param domain The domain to use
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setDomain(domain: string | null | undefined) : Cookie;

  /**
   * 
   * @return  the domain for the cookie
   * 
   */
  getDomain() : string | null;

  /**
   *  Sets the path of this cookie.
   * @param path The path to use for this cookie
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setPath(path: string | null | undefined) : Cookie;

  /**
   * 
   * @return the path for this cookie
   * 
   */
  getPath() : string | null;

  /**
   *  Sets the maximum age of this cookie in seconds.
   *  If an age of {@code 0} is specified, this cookie will be
   *  automatically removed by browser because it will expire immediately.
   *  If {@link Long#MIN_VALUE} is specified, this cookie will be removed when the
   *  browser is closed.
   *  If you don't set this the cookie will be a session cookie and be removed when the browser is closed.
   * @param maxAge The maximum age of this cookie in seconds
   * 
   */
  setMaxAge(maxAge: number) : Cookie;

  /**
   *  Sets the security getStatus of this cookie
   * @param secure True if this cookie is to be secure, otherwise false
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSecure(secure: boolean) : Cookie;

  /**
   *  Determines if this cookie is HTTP only.
   *  If set to true, this cookie cannot be accessed by a client
   *  side script. However, this works only if the browser supports it.
   *  For for information, please look
   *  <a href="http://www.owasp.org/index.php/HTTPOnly">here</a>.
   * @param httpOnly True if the cookie is HTTP only, otherwise false.
   * 
   */
  setHttpOnly(httpOnly: boolean) : Cookie;

  /**
   *  Encode the cookie to a string. This is what is used in the Set-Cookie header
   * @return  the encoded cookie
   * 
   */
  encode() : string;

  /**
   *  Has the cookie been changed? Changed cookies will be saved out in the response and sent to the browser.
   * @return true  if changed
   * 
   */
  isChanged() : boolean;

  /**
   *  Set the cookie as being changed. Changed will be true for a cookie just created, false by default if just
   *  read from the request
   * @param changed  true if changed
   * 
   */
  setChanged(changed: boolean) : void;

  /**
   *  Has this Cookie been sent from the User Agent (the browser)? or was created during the executing on the request.
   * @return true if the cookie comes from the User Agent.
   * 
   */
  isFromUserAgent() : boolean;

}


export class CookieHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Create a cookie handler
   * @return the cookie handler
   * 
   */
  static create() : CookieHandler;

}

import { HttpMethod } from '@vertx/core/enums';

export class CorsHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Create a CORS handler
   * @param allowedOriginPattern  the allowed origin pattern
   * @return  the handler
   * 
   */
  static create(allowedOriginPattern: string) : CorsHandler;

  /**
   *  Add an allowed method
   * @param method  the method to add
   * @return a reference to this, so the API can be used fluently
   * 
   */
  allowedMethod(method: HttpMethod) : CorsHandler;

  /**
   *  Add an allowed header
   * @param headerName  the allowed header name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  allowedHeader(headerName: string) : CorsHandler;

  /**
   *  Add a set of allowed headers
   * @param headerNames  the allowed header names
   * @return a reference to this, so the API can be used fluently
   * 
   */
  allowedHeaders(headerNames: string[]) : CorsHandler;

  /**
   *  Add an exposed header
   * @param headerName  the exposed header name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exposedHeader(headerName: string) : CorsHandler;

  /**
   *  Add a set of exposed headers
   * @param headerNames  the exposed header names
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exposedHeaders(headerNames: string[]) : CorsHandler;

  /**
   *  Set whether credentials are allowed. Note that user agents will block
   *  requests that use a wildcard as origin and include credentials.
   * 
   *  From the MDN documentation you can read:
   * 
   *  <blockquote>
   *  Important note: when responding to a credentialed request,
   *  server must specify a domain, and cannot use wild carding.
   *  </blockquote>
   * @param allow true if allowed
   * @return a reference to this, so the API can be used fluently
   * 
   */
  allowCredentials(allow: boolean) : CorsHandler;

  /**
   *  Set how long the browser should cache the information
   * @param maxAgeSeconds  max age in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  maxAgeSeconds(maxAgeSeconds: number) : CorsHandler;

}

import { HtdigestAuth } from '@vertx/auth-htdigest';

export class DigestAuthHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Add a required authority for this auth handler
   * @param authority  the authority
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAuthority(authority: string) : AuthHandler;

  /**
   *  Add a set of required authorities for this auth handler
   * @param authorities  the set of authorities
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAuthorities(authorities: string[]) : AuthHandler;

  /**
   *  Parses the credentials from the request into a JsonObject. The implementation should
   *  be able to extract the required info for the auth provider in the format the provider
   *  expects.
   * @param context the routing context
   * @param handler the handler to be called once the information is available.
   * 
   */
  parseCredentials(context: RoutingContext, handler: (result: AsyncResult<object>) => void) : void;

  /**
   *  Authorizes the given user against all added authorities.
   * @param user a user.
   * @param handler the handler for the result.
   * 
   */
  authorize(user: User, handler: (result: AsyncResult<void>) => void) : void;

  /**
   *  Create a digest auth handler
   * @param authProvider the auth provider to use
   * @return the auth handler
   * 
   */
  static create(authProvider: HtdigestAuth) : DigestAuthHandler;

  /**
   *  Create a digest auth handler, specifying the expire timeout for nonces.
   * @param authProvider       the auth service to use
   * @param nonceExpireTimeout the nonce expire timeout in milliseconds.
   * @return the auth handler
   * 
   */
  static create(authProvider: HtdigestAuth, nonceExpireTimeout: number) : DigestAuthHandler;

}


export class ErrorHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Create an error handler using defaults
   * @return the handler
   * 
   */
  static create() : ErrorHandler;

  /**
   *  Create an error handler
   * @param errorTemplateName  the error template name - will be looked up from the classpath
   * @param displayExceptionDetails  true if exception details should be displayed
   * @return the handler
   * 
   */
  static create(errorTemplateName: string, displayExceptionDetails: boolean) : ErrorHandler;

  /**
   *  Create an error handler
   * @param displayExceptionDetails  true if exception details should be displayed
   * @return the handler
   * 
   */
  static create(displayExceptionDetails: boolean) : ErrorHandler;

  /**
   *  Create an error handler
   * @param errorTemplateName  the error template name - will be looked up from the classpath
   * @return the handler
   * 
   */
  static create(errorTemplateName: string) : ErrorHandler;

}


export class FaviconHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Create a handler with defaults
   * @return the handler
   * 
   */
  static create() : FaviconHandler;

  /**
   *  Create a handler attempting to load favicon file from the specified path
   * @param path  the path
   * @return the handler
   * 
   */
  static create(path: string) : FaviconHandler;

  /**
   *  Create a handler attempting to load favicon file from the specified path, and with the specified max cache time
   * @param path  the path
   * @param maxAgeSeconds max how long the file will be cached by browser, in seconds
   * @return the handler
   * 
   */
  static create(path: string, maxAgeSeconds: number) : FaviconHandler;

  /**
   *  Create a handler with the specified max cache time
   * @param maxAgeSeconds max how long the file will be cached by browser, in seconds
   * @return the handler
   * 
   */
  static create(maxAgeSeconds: number) : FaviconHandler;

}


export class FileUpload {
  /**
   * 
   * @return the name of the upload as provided in the form submission
   * 
   */
  name() : string;

  /**
   * 
   * @return the actual temporary file name on the server where the file was uploaded to.
   * 
   */
  uploadedFileName() : string;

  /**
   * 
   * @return the file name of the upload as provided in the form submission
   * 
   */
  fileName() : string;

  /**
   * 
   * @return the size of the upload, in bytes
   * 
   */
  size() : number;

  /**
   * 
   * @return the content type (MIME type) of the upload
   * 
   */
  contentType() : string;

  /**
   * 
   * @return the content transfer encoding of the upload - this describes how the upload was encoded in the form submission.
   * 
   */
  contentTransferEncoding() : string;

  /**
   * 
   * @return the charset of the upload
   * 
   */
  charSet() : string;

}


export class FormLoginHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Create a handler
   * @param authProvider  the auth service to use
   * @return the handler
   * 
   */
  static create(authProvider: AuthProvider) : FormLoginHandler;

  /**
   *  Create a handler
   * @param authProvider  the auth service to use
   * @param usernameParam   the value of the form attribute which will contain the username
   * @param passwordParam   the value of the form attribute which will contain the password
   * @param returnURLParam   the value of the session attribute which will contain the return url
   * @param directLoggedInOKURL a url to redirect to if the user logs in directly at the url of the form login handler
   *                             without being redirected here first
   * @return the handler
   * 
   */
  static create(authProvider: AuthProvider, usernameParam: string, passwordParam: string, returnURLParam: string, directLoggedInOKURL: string) : FormLoginHandler;

  /**
   *  Set the name of the form param used to submit the username
   * @param usernameParam  the name of the param
   * @return a reference to this for a fluent API
   * 
   */
  setUsernameParam(usernameParam: string) : FormLoginHandler;

  /**
   *  Set the name of the form param used to submit the password
   * @param passwordParam  the name of the param
   * @return a reference to this for a fluent API
   * 
   */
  setPasswordParam(passwordParam: string) : FormLoginHandler;

  /**
   *  Set the name of the session attrioute used to specify the return url
   * @param returnURLParam  the name of the param
   * @return a reference to this for a fluent API
   * 
   */
  setReturnURLParam(returnURLParam: string) : FormLoginHandler;

  /**
   *  Set the url to redirect to if the user logs in directly at the url of the form login handler
   *  without being redirected here first
   * @param directLoggedInOKURL  the URL to redirect to
   * @return a reference to this for a fluent API
   * 
   */
  setDirectLoggedInOKURL(directLoggedInOKURL: string) : FormLoginHandler;

}

import { JWTAuth } from '@vertx/auth-jwt';

export class JWTAuthHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Add a required authority for this auth handler
   * @param authority  the authority
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAuthority(authority: string) : AuthHandler;

  /**
   *  Add a set of required authorities for this auth handler
   * @param authorities  the set of authorities
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAuthorities(authorities: string[]) : AuthHandler;

  /**
   *  Parses the credentials from the request into a JsonObject. The implementation should
   *  be able to extract the required info for the auth provider in the format the provider
   *  expects.
   * @param context the routing context
   * @param handler the handler to be called once the information is available.
   * 
   */
  parseCredentials(context: RoutingContext, handler: (result: AsyncResult<object>) => void) : void;

  /**
   *  Authorizes the given user against all added authorities.
   * @param user a user.
   * @param handler the handler for the result.
   * 
   */
  authorize(user: User, handler: (result: AsyncResult<void>) => void) : void;

  /**
   *  Create a JWT auth handler
   * @param authProvider  the auth provider to use
   * @return the auth handler
   * 
   */
  static create(authProvider: JWTAuth) : JWTAuthHandler;

  /**
   *  Create a JWT auth handler
   * @param authProvider  the auth provider to use.
   * @return the auth handler
   * 
   */
  static create(authProvider: JWTAuth, skip: string) : JWTAuthHandler;

  /**
   *  Set the audience list
   * @param audience  the audience list
   * @return a reference to this for fluency
   * 
   */
  setAudience(audience: string[]) : JWTAuthHandler;

  /**
   *  Set the issuer
   * @param issuer  the issuer
   * @return a reference to this for fluency
   * 
   */
  setIssuer(issuer: string) : JWTAuthHandler;

  /**
   *  Set whether expiration is ignored
   * @param ignoreExpiration  whether expiration is ignored
   * @return a reference to this for fluency
   * 
   */
  setIgnoreExpiration(ignoreExpiration: boolean) : JWTAuthHandler;

}


export class LanguageHeader {
  /**
   *  Contains the raw value that was received from the user agent
   * 
   */
  rawValue() : string;

  /**
   *  Holds the unparsed value of the header.<br>
   *  For the most part, this is the content before the semi-colon (";")
   * 
   */
  value() : string;

  /**
   *  Holds the weight specified in the "q" parameter of the header.<br>
   *  If the parameter is not specified, 1.0 is assumed according to
   *  <a href="https://tools.ietf.org/html/rfc7231#section-5.3.1">rfc7231</a>
   * @return 
   */
  weight() : number;

  /**
   *  The value of the parameter specified by this key. Each is one of 3 things:
   *  <ol>
   *  <li>null &lt;- That key was not specified</li>
   *  <li>ParsedHeaderValue.EMPTY (tested using ==) &lt;- The value was not specified</li>
   *  <li>[Other] <- The value of the parameter</li>
   *  </ol>
   *  <b>Note:</b> The <code>q</code> parameter is never present.
   * @return 
   */
  parameter(key: string) : string | null;

  /**
   *  The parameters specified in this header value.
   *  <b>Note:</b> The <code>q</code> parameter is never present.
   * @see {@link #parameter(String)}
   * @return Unmodifiable Map of parameters of this header value
   * 
   */
  parameters() : { [key:string]: string; };

  /**
   *  Is this an allowed operation as specified by the corresponding header?
   * @return 
   */
  isPermitted() : boolean;

  /**
   *  Test if this header is matched by matchTry header
   * @param matchTry The header to be matched from
   * @return true if this header represents a subset of matchTry, otherwise, false
   * 
   */
  isMatchedBy(matchTry: ParsedHeaderValue) : boolean;

  /**
   *  An integer that represents the absolute order position of this header
   * 
   */
  weightedOrder() : number;

  /**
   *  The tag of the language as specified by
   *  <a href="https://tools.ietf.org/html/rfc7231#section-3.1.3.1">rfc7231#section-3.1.3.1</a>.<br>
   *  Equivalent to {@link #subtag(int) subtag(0)}
   * @return The language tag
   * 
   */
  tag() : string;

  /**
   *  The subtag of the language as specified by
   *  <a href="https://tools.ietf.org/html/rfc7231#section-3.1.3.1">rfc7231#section-3.1.3.1</a>.<br>
   *  Equivalent to {@link #subtag(int) subtag(1)}
   * @return The language subtag
   * 
   */
  subtag() : string | null;

  /**
   *  A subtag of this language header.<br>
   *  + info: <a href="https://tools.ietf.org/html/rfc7231#section-3.1.3.1">rfc7231#section-3.1.3.1</a>
   * @return The language subtag at specified position
   * 
   */
  subtag(level: number) : string | null;

  /**
   * 
   * @return the number of subtags this value has
   * 
   */
  subtagCount() : number;

}


export class LocalSessionStore {
  /**
   *  Create a session store
   * @param vertx  the Vert.x instance
   * @return the session store
   * 
   */
  static create(vertx: Vertx) : LocalSessionStore;

  /**
   *  Create a session store
   * @param vertx  the Vert.x instance
   * @param sessionMapName  name for map used to store sessions
   * @return the session store
   * 
   */
  static create(vertx: Vertx, sessionMapName: string) : LocalSessionStore;

  /**
   *  Create a session store
   * @param vertx  the Vert.x instance
   * @param sessionMapName  name for map used to store sessions
   * @param reaperInterval  how often, in ms, to check for expired sessions
   * @return the session store
   * 
   */
  static create(vertx: Vertx, sessionMapName: string, reaperInterval: number) : LocalSessionStore;

}


export class Locale {
  static create() : Locale;

  static create(language: string) : Locale;

  static create(language: string, country: string) : Locale;

  static create(language: string, country: string, variant: string) : Locale;

  /**
   *  Returns the language as reported by the HTTP client.
   * @deprecated Use {@link LanguageHeader#tag()} instead
   * @return language
   * 
   */
  language() : string;

  /**
   *  Returns the country as reported by the HTTP client.
   * @deprecated Use {@link LanguageHeader#subtag()} instead
   * @return variant
   * 
   */
  country() : string;

  /**
   *  Returns the variant as reported by the HTTP client.
   * @deprecated Use {@link LanguageHeader#subtag(int)} with value 2 instead
   * @return variant
   * 
   */
  variant() : string;

}

import { LoggerFormat } from './enums';

export class LoggerHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Create a handler with default format
   * @return the handler
   * 
   */
  static create() : LoggerHandler;

  /**
   *  Create a handler with he specified format
   * @param format  the format
   * @return the handler
   * 
   */
  static create(format: LoggerFormat) : LoggerHandler;

  /**
   *  Create a handler with he specified format
   * @param immediate  true if logging should occur as soon as request arrives
   * @param format  the format
   * @return the handler
   * 
   */
  static create(immediate: boolean, format: LoggerFormat) : LoggerHandler;

}


export class MIMEHeader {
  /**
   *  Contains the raw value that was received from the user agent
   * 
   */
  rawValue() : string;

  /**
   *  Holds the unparsed value of the header.<br>
   *  For the most part, this is the content before the semi-colon (";")
   * 
   */
  value() : string;

  /**
   *  Holds the weight specified in the "q" parameter of the header.<br>
   *  If the parameter is not specified, 1.0 is assumed according to
   *  <a href="https://tools.ietf.org/html/rfc7231#section-5.3.1">rfc7231</a>
   * @return 
   */
  weight() : number;

  /**
   *  The value of the parameter specified by this key. Each is one of 3 things:
   *  <ol>
   *  <li>null &lt;- That key was not specified</li>
   *  <li>ParsedHeaderValue.EMPTY (tested using ==) &lt;- The value was not specified</li>
   *  <li>[Other] <- The value of the parameter</li>
   *  </ol>
   *  <b>Note:</b> The <code>q</code> parameter is never present.
   * @return 
   */
  parameter(key: string) : string | null;

  /**
   *  The parameters specified in this header value.
   *  <b>Note:</b> The <code>q</code> parameter is never present.
   * @see {@link #parameter(String)}
   * @return Unmodifiable Map of parameters of this header value
   * 
   */
  parameters() : { [key:string]: string; };

  /**
   *  Is this an allowed operation as specified by the corresponding header?
   * @return 
   */
  isPermitted() : boolean;

  /**
   *  Test if this header is matched by matchTry header
   * @param matchTry The header to be matched from
   * @return true if this header represents a subset of matchTry, otherwise, false
   * 
   */
  isMatchedBy(matchTry: ParsedHeaderValue) : boolean;

  /**
   *  An integer that represents the absolute order position of this header
   * 
   */
  weightedOrder() : number;

  /**
   *  Gets the parsed component part of the MIME. This is the string between the beginning and the first {@code '/'}
   *  of the MIME
   * @return The component of the MIME this represents
   * 
   */
  component() : string;

  /**
   *  Gets the parsed subcomponent part of the MIME. This is the string between the first {@code '/'} and the
   *  {@code ';'} or the end of the MIME
   * @return The subcomponent of the MIME this represents
   * 
   */
  subComponent() : string;

}

import { OAuth2Auth } from '@vertx/auth-oauth2';

export class OAuth2AuthHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Add a required authority for this auth handler
   * @param authority  the authority
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAuthority(authority: string) : AuthHandler;

  /**
   *  Add a set of required authorities for this auth handler
   * @param authorities  the set of authorities
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAuthorities(authorities: string[]) : AuthHandler;

  /**
   *  Parses the credentials from the request into a JsonObject. The implementation should
   *  be able to extract the required info for the auth provider in the format the provider
   *  expects.
   * @param context the routing context
   * @param handler the handler to be called once the information is available.
   * 
   */
  parseCredentials(context: RoutingContext, handler: (result: AsyncResult<object>) => void) : void;

  /**
   *  Authorizes the given user against all added authorities.
   * @param user a user.
   * @param handler the handler for the result.
   * 
   */
  authorize(user: User, handler: (result: AsyncResult<void>) => void) : void;

  /**
   *  Create a OAuth2 auth handler with host pinning
   * @param authProvider  the auth provider to use
   * @param callbackURL the callback URL you entered in your provider admin console, usually it should be something like: `https://myserver:8888/callback`
   * @return the auth handler
   * 
   */
  static create(authProvider: OAuth2Auth, callbackURL: string) : OAuth2AuthHandler;

  /**
   *  Create a OAuth2 auth handler without host pinning.
   *  Most providers will not look to the redirect url but always redirect to
   *  the preconfigured callback. So this factory does not provide a callback url.
   * @param authProvider  the auth provider to use
   * @return the auth handler
   * 
   */
  static create(authProvider: OAuth2Auth) : OAuth2AuthHandler;

  /**
   *  Extra parameters needed to be passed while requesting a token.
   * @param extraParams extra optional parameters.
   * @return self
   * 
   */
  extraParams(extraParams: object) : OAuth2AuthHandler;

  /**
   *  add the callback handler to a given route.
   * @param route a given route e.g.: `/callback`
   * @return self
   * 
   */
  setupCallback(route: Route) : OAuth2AuthHandler;

}


export interface ParsedHeaderValue {
  /**
   *  Contains the raw value that was received from the user agent
   * 
   */
  rawValue() : string;

  /**
   *  Holds the unparsed value of the header.<br>
   *  For the most part, this is the content before the semi-colon (";")
   * 
   */
  value() : string;

  /**
   *  Holds the weight specified in the "q" parameter of the header.<br>
   *  If the parameter is not specified, 1.0 is assumed according to
   *  <a href="https://tools.ietf.org/html/rfc7231#section-5.3.1">rfc7231</a>
   * @return 
   */
  weight() : number;

  /**
   *  The value of the parameter specified by this key. Each is one of 3 things:
   *  <ol>
   *  <li>null &lt;- That key was not specified</li>
   *  <li>ParsedHeaderValue.EMPTY (tested using ==) &lt;- The value was not specified</li>
   *  <li>[Other] <- The value of the parameter</li>
   *  </ol>
   *  <b>Note:</b> The <code>q</code> parameter is never present.
   * @return 
   */
  parameter(key: string) : string | null;

  /**
   *  The parameters specified in this header value.
   *  <b>Note:</b> The <code>q</code> parameter is never present.
   * @see {@link #parameter(String)}
   * @return Unmodifiable Map of parameters of this header value
   * 
   */
  parameters() : { [key:string]: string; };

  /**
   *  Is this an allowed operation as specified by the corresponding header?
   * @return 
   */
  isPermitted() : boolean;

  /**
   *  Test if this header is matched by matchTry header
   * @param matchTry The header to be matched from
   * @return true if this header represents a subset of matchTry, otherwise, false
   * 
   */
  isMatchedBy(matchTry: ParsedHeaderValue) : boolean;

  /**
   *  An integer that represents the absolute order position of this header
   * 
   */
  weightedOrder() : number;

}


export class ParsedHeaderValues {
  /**
   * 
   * @return List of MIME values in the {@code Accept} header
   * 
   */
  accept() : MIMEHeader[];

  /**
   * 
   * @return List of charset values in the {@code Accept-Charset} header
   * 
   */
  acceptCharset() : ParsedHeaderValue[];

  /**
   * 
   * @return List of encofing values in the {@code Accept-Encoding} header
   * 
   */
  acceptEncoding() : ParsedHeaderValue[];

  /**
   * 
   * @return List of languages in the {@code Accept-Language} header
   * 
   */
  acceptLanguage() : LanguageHeader[];

  /**
   * 
   * @return MIME value in the {@code Content-Type} header
   * 
   */
  contentType() : MIMEHeader;

}


export class RedirectAuthHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Add a required authority for this auth handler
   * @param authority  the authority
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAuthority(authority: string) : AuthHandler;

  /**
   *  Add a set of required authorities for this auth handler
   * @param authorities  the set of authorities
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addAuthorities(authorities: string[]) : AuthHandler;

  /**
   *  Parses the credentials from the request into a JsonObject. The implementation should
   *  be able to extract the required info for the auth provider in the format the provider
   *  expects.
   * @param context the routing context
   * @param handler the handler to be called once the information is available.
   * 
   */
  parseCredentials(context: RoutingContext, handler: (result: AsyncResult<object>) => void) : void;

  /**
   *  Authorizes the given user against all added authorities.
   * @param user a user.
   * @param handler the handler for the result.
   * 
   */
  authorize(user: User, handler: (result: AsyncResult<void>) => void) : void;

  /**
   *  Create a handler
   * @param authProvider  the auth service to use
   * @return the handler
   * 
   */
  static create(authProvider: AuthProvider) : AuthHandler;

  /**
   *  Create a handler
   * @param authProvider  the auth service to use
   * @param loginRedirectURL  the url to redirect the user to
   * @return the handler
   * 
   */
  static create(authProvider: AuthProvider, loginRedirectURL: string) : AuthHandler;

  /**
   *  Create a handler
   * @param authProvider  the auth service to use
   * @param loginRedirectURL  the url to redirect the user to
   * @param returnURLParam  the name of param used to store return url information in session
   * @return the handler
   * 
   */
  static create(authProvider: AuthProvider, loginRedirectURL: string, returnURLParam: string) : AuthHandler;

}


export class ResponseContentTypeHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Create a response content type handler.
   * @return the response content type handler
   * 
   */
  static create() : ResponseContentTypeHandler;

  /**
   *  Create a response content type handler with a custom disable flag.
   * @return the response content type handler
   * 
   */
  static create(disableFlag: string) : ResponseContentTypeHandler;

}


export class ResponseTimeHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Create a handler
   * @return the handler
   * 
   */
  static create() : ResponseTimeHandler;

}


export class Route {
  /**
   *  Add an HTTP method for this route. By default a route will match all HTTP methods. If any are specified then the route
   *  will only match any of the specified methods
   * @param method  the HTTP method to add
   * @return a reference to this, so the API can be used fluently
   * 
   */
  method(method: HttpMethod) : Route;

  /**
   *  Set the path prefix for this route. If set then this route will only match request URI paths which start with this
   *  path prefix. Only a single path or path regex can be set for a route.
   * @param path  the path prefix
   * @return a reference to this, so the API can be used fluently
   * 
   */
  path(path: string) : Route;

  /**
   *  Set the path prefix as a regular expression. If set then this route will only match request URI paths, the beginning
   *  of which match the regex. Only a single path or path regex can be set for a route.
   * @param path  the path regex
   * @return a reference to this, so the API can be used fluently
   * 
   */
  pathRegex(path: string) : Route;

  /**
   *  Add a content type produced by this route. Used for content based routing.
   * @param contentType  the content type
   * @return a reference to this, so the API can be used fluently
   * 
   */
  produces(contentType: string) : Route;

  /**
   *  Add a content type consumed by this route. Used for content based routing.
   * @param contentType  the content type
   * @return a reference to this, so the API can be used fluently
   * 
   */
  consumes(contentType: string) : Route;

  /**
   *  Specify the order for this route. The router tests routes in that order.
   * @param order  the order
   * @return a reference to this, so the API can be used fluently
   * 
   */
  order(order: number) : Route;

  /**
   *  Specify this is the last route for the router.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  last() : Route;

  /**
   *  Specify a request handler for the route. The router routes requests to handlers depending on whether the various
   *  criteria such as method, path, etc match. There can be only one request handler for a route. If you set this more
   *  than once it will overwrite the previous handler.
   * @param requestHandler  the request handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  handler(requestHandler: (result: RoutingContext) => void) : Route;

  /**
   *  Like {@link io.vertx.ext.web.Route#blockingHandler(Handler, boolean)} called with ordered = true
   * 
   */
  blockingHandler(requestHandler: (result: RoutingContext) => void) : Route;

  /**
   *  Specify a blocking request handler for the route.
   *  This method works just like {@link #handler(Handler)} excepted that it will run the blocking handler on a worker thread
   *  so that it won't block the event loop. Note that it's safe to call context.next() from the
   *  blocking handler as it will be executed on the event loop context (and not on the worker thread.
   * 
   *  If the blocking handler is ordered it means that any blocking handlers for the same context are never executed
   *  concurrently but always in the order they were called. The default value of ordered is true. If you do not want this
   *  behaviour and don't mind if your blocking handlers are executed in parallel you can set ordered to false.
   * @param requestHandler  the blocking request handler
   * @param ordered if true handlers are executed in sequence, otherwise are run in parallel
   * @return a reference to this, so the API can be used fluently
   * 
   */
  blockingHandler(requestHandler: (result: RoutingContext) => void, ordered: boolean) : Route;

  /**
   *  Specify a failure handler for the route. The router routes failures to failurehandlers depending on whether the various
   *  criteria such as method, path, etc match. There can be only one failure handler for a route. If you set this more
   *  than once it will overwrite the previous handler.
   * @param failureHandler  the request handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  failureHandler(failureHandler: (result: RoutingContext) => void) : Route;

  /**
   *  Remove this route from the router
   * @return a reference to this, so the API can be used fluently
   * 
   */
  remove() : Route;

  /**
   *  Disable this route. While disabled the router will not route any requests or failures to it.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  disable() : Route;

  /**
   *  Enable this route.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  enable() : Route;

  /**
   *  If true then the normalised request path will be used when routing (e.g. removing duplicate /)
   *  Default is true
   * @param useNormalisedPath  use normalised path for routing?
   * @return a reference to this, so the API can be used fluently
   * 
   */
  useNormalisedPath(useNormalisedPath: boolean) : Route;

  /**
   * 
   * @return the path prefix (if any) for this route
   * 
   */
  getPath() : string | null;

  /**
   *  When you add a new route with a regular expression, you can add named capture groups for parameters. <br/>
   *  However, if you need more complex parameters names (like "param_name"), you can add parameters names with
   *  this function. You have to name capture groups in regex with names: "p0", "p1", "p2", ... <br/>
   *  <br/>
   *  For example: If you declare route with regex \/(?<p0>[a-z]*)\/(?<p1>[a-z]*) and group names ["param_a", "param-b"]
   *  for uri /hello/world you receive inside pathParams() the parameter param_a = "hello"
   * @param groups group names
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setRegexGroupsNames(groups: string[]) : Route;

}

import { HttpServerRequest } from '@vertx/core';

export class Router {
  /**
   *  Create a router
   * @param vertx  the Vert.x instance
   * @return the router
   * 
   */
  static router(vertx: Vertx) : Router;

  /**
   *  This method is used to provide a request to the router. Usually you take request from the
   *  {@link io.vertx.core.http.HttpServer#requestHandler(Handler)} and pass it to this method. The
   *  router then routes it to matching routes.
   * @param request  the request
   * 
   */
  accept(request: HttpServerRequest) : void;

  /**
   *  Add a route with no matching criteria, i.e. it matches all requests or failures.
   * @return  the route
   * 
   */
  route() : Route;

  /**
   *  Add a route that matches the specified HTTP method and path
   * @param method  the HTTP method to match
   * @param path  URI paths that begin with this path will match
   * @return the route
   * 
   */
  route(method: HttpMethod, path: string) : Route;

  /**
   *  Add a route that matches the specified path
   * @param path  URI paths that begin with this path will match
   * @return the route
   * 
   */
  route(path: string) : Route;

  /**
   *  Add a route that matches the specified HTTP method and path regex
   * @param method  the HTTP method to match
   * @param regex  URI paths that begin with a match for this regex will match
   * @return the route
   * 
   */
  routeWithRegex(method: HttpMethod, regex: string) : Route;

  /**
   *  Add a route that matches the specified path regex
   * @param regex  URI paths that begin with a match for this regex will match
   * @return the route
   * 
   */
  routeWithRegex(regex: string) : Route;

  /**
   *  Add a route that matches any HTTP GET request
   * @return the route
   * 
   */
  get() : Route;

  /**
   *  Add a route that matches a HTTP GET request and the specified path
   * @param path  URI paths that begin with this path will match
   * @return the route
   * 
   */
  get(path: string) : Route;

  /**
   *  Add a route that matches a HTTP GET request and the specified path regex
   * @param regex  URI paths that begin with a match for this regex will match
   * @return the route
   * 
   */
  getWithRegex(regex: string) : Route;

  /**
   *  Add a route that matches any HTTP HEAD request
   * @return the route
   * 
   */
  head() : Route;

  /**
   *  Add a route that matches a HTTP HEAD request and the specified path
   * @param path  URI paths that begin with this path will match
   * @return the route
   * 
   */
  head(path: string) : Route;

  /**
   *  Add a route that matches a HTTP HEAD request and the specified path regex
   * @param regex  URI paths that begin with a match for this regex will match
   * @return the route
   * 
   */
  headWithRegex(regex: string) : Route;

  /**
   *  Add a route that matches any HTTP OPTIONS request
   * @return the route
   * 
   */
  options() : Route;

  /**
   *  Add a route that matches a HTTP OPTIONS request and the specified path
   * @param path  URI paths that begin with this path will match
   * @return the route
   * 
   */
  options(path: string) : Route;

  /**
   *  Add a route that matches a HTTP OPTIONS request and the specified path regex
   * @param regex  URI paths that begin with a match for this regex will match
   * @return the route
   * 
   */
  optionsWithRegex(regex: string) : Route;

  /**
   *  Add a route that matches any HTTP PUT request
   * @return the route
   * 
   */
  put() : Route;

  /**
   *  Add a route that matches a HTTP PUT request and the specified path
   * @param path  URI paths that begin with this path will match
   * @return the route
   * 
   */
  put(path: string) : Route;

  /**
   *  Add a route that matches a HTTP PUT request and the specified path regex
   * @param regex  URI paths that begin with a match for this regex will match
   * @return the route
   * 
   */
  putWithRegex(regex: string) : Route;

  /**
   *  Add a route that matches any HTTP POST request
   * @return the route
   * 
   */
  post() : Route;

  /**
   *  Add a route that matches a HTTP POST request and the specified path
   * @param path  URI paths that begin with this path will match
   * @return the route
   * 
   */
  post(path: string) : Route;

  /**
   *  Add a route that matches a HTTP POST request and the specified path regex
   * @param regex  URI paths that begin with a match for this regex will match
   * @return the route
   * 
   */
  postWithRegex(regex: string) : Route;

  /**
   *  Add a route that matches any HTTP DELETE request
   * @return the route
   * 
   */
  delete() : Route;

  /**
   *  Add a route that matches a HTTP DELETE request and the specified path
   * @param path  URI paths that begin with this path will match
   * @return the route
   * 
   */
  delete(path: string) : Route;

  /**
   *  Add a route that matches a HTTP DELETE request and the specified path regex
   * @param regex  URI paths that begin with a match for this regex will match
   * @return the route
   * 
   */
  deleteWithRegex(regex: string) : Route;

  /**
   *  Add a route that matches any HTTP TRACE request
   * @return the route
   * 
   */
  trace() : Route;

  /**
   *  Add a route that matches a HTTP TRACE request and the specified path
   * @param path  URI paths that begin with this path will match
   * @return the route
   * 
   */
  trace(path: string) : Route;

  /**
   *  Add a route that matches a HTTP TRACE request and the specified path regex
   * @param regex  URI paths that begin with a match for this regex will match
   * @return the route
   * 
   */
  traceWithRegex(regex: string) : Route;

  /**
   *  Add a route that matches any HTTP CONNECT request
   * @return the route
   * 
   */
  connect() : Route;

  /**
   *  Add a route that matches a HTTP CONNECT request and the specified path
   * @param path  URI paths that begin with this path will match
   * @return the route
   * 
   */
  connect(path: string) : Route;

  /**
   *  Add a route that matches a HTTP CONNECT request and the specified path regex
   * @param regex  URI paths that begin with a match for this regex will match
   * @return the route
   * 
   */
  connectWithRegex(regex: string) : Route;

  /**
   *  Add a route that matches any HTTP PATCH request
   * @return the route
   * 
   */
  patch() : Route;

  /**
   *  Add a route that matches a HTTP PATCH request and the specified path
   * @param path  URI paths that begin with this path will match
   * @return the route
   * 
   */
  patch(path: string) : Route;

  /**
   *  Add a route that matches a HTTP PATCH request and the specified path regex
   * @param regex  URI paths that begin with a match for this regex will match
   * @return the route
   * 
   */
  patchWithRegex(regex: string) : Route;

  /**
   * 
   * @return a list of all the routes on this router
   * 
   */
  getRoutes() : Route[];

  /**
   *  Remove all the routes from this router
   * @return a reference to this, so the API can be used fluently
   * 
   */
  clear() : Router;

  /**
   *  Mount a sub router on this router
   * @param mountPoint  the mount point (path prefix) to mount it on
   * @param subRouter  the router to mount as a sub router
   * @return a reference to this, so the API can be used fluently
   * 
   */
  mountSubRouter(mountPoint: string, subRouter: Router) : Router;

  /**
   *  Specify a handler for any unhandled exceptions on this router. The handler will be called for exceptions thrown
   *  from handlers. This does not affect the normal failure routing logic.
   * @param exceptionHandler  the exception handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  exceptionHandler(exceptionHandler: (result: Error) => void | null | undefined) : Router;

  /**
   *  Used to route a context to the router. Used for sub-routers. You wouldn't normally call this method directly.
   * @param context  the routing context
   * 
   */
  handleContext(context: RoutingContext) : void;

  /**
   *  Used to route a failure to the router. Used for sub-routers. You wouldn't normally call this method directly.
   * @param context  the routing context
   * 
   */
  handleFailure(context: RoutingContext) : void;

}

import { MultiMap } from '@vertx/core';
import { Buffer } from '@vertx/core';
import { HttpServerResponse } from '@vertx/core';

export class RoutingContext {
  /**
   * 
   * @return the HTTP request object
   * 
   */
  request() : HttpServerRequest;

  /**
   * 
   * @return the HTTP response object
   * 
   */
  response() : HttpServerResponse;

  /**
   *  Tell the router to route this context to the next matching route (if any).
   *  This method, if called, does not need to be called during the execution of the handler, it can be called
   *  some arbitrary time later, if required.
   *  <p>
   *  If next is not called for a handler then the handler should make sure it ends the response or no response
   *  will be sent.
   * 
   */
  next() : void;

  /**
   *  Fail the context with the specified status code.
   *  <p>
   *  This will cause the router to route the context to any matching failure handlers for the request. If no failure handlers
   *  match a default failure response will be sent.
   * @param statusCode  the HTTP status code
   * 
   */
  fail(statusCode: number) : void;

  /**
   *  Fail the context with the specified throwable.
   *  <p>
   *  This will cause the router to route the context to any matching failure handlers for the request. If no failure handlers
   *  match a default failure response with status code 500 will be sent.
   * @param throwable  a throwable representing the failure
   * 
   */
  fail(throwable: Error) : void;

  /**
   *  Put some arbitrary data in the context. This will be available in any handlers that receive the context.
   * @param key  the key for the data
   * @param obj  the data
   * @return a reference to this, so the API can be used fluently
   * 
   */
  put(key: string, obj: any) : RoutingContext;

  /**
   *  Get some data from the context. The data is available in any handlers that receive the context.
   * @param key  the key for the data
   * @param <T>  the type of the data
   * @return  the data
   * @throws ClassCastException if the data is not of the expected type
   * 
   */
  get(key: string) : Object;

  /**
   *  Remove some data from the context. The data is available in any handlers that receive the context.
   * @param key  the key for the data
   * @param <T>  the type of the data
   * @return  the previous data associated with the key
   * @throws ClassCastException if the data is not of the expected type
   * 
   */
  remove(key: string) : Object;

  /**
   * 
   * @return the Vert.x instance associated to the initiating {@link Router} for this context
   * 
   */
  vertx() : Vertx;

  /**
   * 
   * @return the mount point for this router. It will be null for a top level router. For a sub-router it will be the path
   *  at which the subrouter was mounted.
   * 
   */
  mountPoint() : string | null;

  /**
   * 
   * @return the current route this context is being routed through.
   * 
   */
  currentRoute() : Route;

  /**
   *  Return the normalised path for the request.
   *  <p>
   *  The normalised path is where the URI path has been decoded, i.e. any unicode or other illegal URL characters that
   *  were encoded in the original URL with `%` will be returned to their original form. E.g. `%20` will revert to a space.
   *  Also `+` reverts to a space in a query.
   *  <p>
   *  The normalised path will also not contain any `..` character sequences to prevent resources being accessed outside
   *  of the permitted area.
   *  <p>
   *  It's recommended to always use the normalised path as opposed to {@link HttpServerRequest#path()}
   *  if accessing server resources requested by a client.
   * @return the normalised path
   * 
   */
  normalisedPath() : string;

  /**
   *  Get the cookie with the specified name. The context must have first been routed to a {@link io.vertx.ext.web.handler.CookieHandler}
   *  for this to work.
   * @param name  the cookie name
   * @return the cookie
   * 
   */
  getCookie(name: string) : Cookie | null;

  /**
   *  Add a cookie. This will be sent back to the client in the response. The context must have first been routed
   *  to a {@link io.vertx.ext.web.handler.CookieHandler} for this to work.
   * @param cookie  the cookie
   * @return a reference to this, so the API can be used fluently
   * 
   */
  addCookie(cookie: Cookie) : RoutingContext;

  /**
   *  Expire a cookie, notifying a User Agent to remove it from its cookie jar. The context must have first been routed
   *  to a {@link io.vertx.ext.web.handler.CookieHandler} for this to work.
   * @param name  the name of the cookie
   * @return the cookie, if it existed, or null
   * 
   */
  removeCookie(name: string) : Cookie | null;

  /**
   *  Remove a cookie from the cookie set. If invalidate is true then it will expire a cookie, notifying a User Agent to
   *  remove it from its cookie jar. The context must have first been routed to a
   *  {@link io.vertx.ext.web.handler.CookieHandler} for this to work.
   * @param name  the name of the cookie
   * @return the cookie, if it existed, or null
   * 
   */
  removeCookie(name: string, invalidate: boolean) : Cookie | null;

  /**
   * 
   * @return the number of cookies. The context must have first been routed to a {@link io.vertx.ext.web.handler.CookieHandler}
   *  for this to work.
   * 
   */
  cookieCount() : number;

  /**
   * 
   * @return a set of all the cookies. The context must have first been routed to a {@link io.vertx.ext.web.handler.CookieHandler}
   *  for this to be populated.
   * 
   */
  cookies() : Cookie[];

  /**
   * 
   * @return  the entire HTTP request body as a string, assuming UTF-8 encoding. The context must have first been routed to a
   *  {@link io.vertx.ext.web.handler.BodyHandler} for this to be populated.
   * 
   */
  getBodyAsString() : string | null;

  /**
   *  Get the entire HTTP request body as a string, assuming the specified encoding. The context must have first been routed to a
   *  {@link io.vertx.ext.web.handler.BodyHandler} for this to be populated.
   * @param encoding  the encoding, e.g. "UTF-16"
   * @return the body
   * 
   */
  getBodyAsString(encoding: string) : string | null;

  /**
   * 
   * @return Get the entire HTTP request body as a {@link JsonObject}. The context must have first been routed to a
   *  {@link io.vertx.ext.web.handler.BodyHandler} for this to be populated.
   * 
   */
  getBodyAsJson() : object | null;

  /**
   * 
   * @return Get the entire HTTP request body as a {@link JsonArray}. The context must have first been routed to a
   *  {@link io.vertx.ext.web.handler.BodyHandler} for this to be populated.
   * 
   */
  getBodyAsJsonArray() : any[] | null;

  /**
   * 
   * @return Get the entire HTTP request body as a {@link Buffer}. The context must have first been routed to a
   *  {@link io.vertx.ext.web.handler.BodyHandler} for this to be populated.
   * 
   */
  getBody() : Buffer | null;

  /**
   * 
   * @return a set of fileuploads (if any) for the request. The context must have first been routed to a
   *  {@link io.vertx.ext.web.handler.BodyHandler} for this to work.
   * 
   */
  fileUploads() : FileUpload[];

  /**
   *  Get the session. The context must have first been routed to a {@link io.vertx.ext.web.handler.SessionHandler}
   *  for this to be populated.
   *  Sessions live for a browser session, and are maintained by session cookies.
   * @return  the session.
   * 
   */
  session() : Session | null;

  /**
   *  Get the authenticated user (if any). This will usually be injected by an auth handler if authentication if successful.
   * @return  the user, or null if the current user is not authenticated.
   * 
   */
  user() : User | null;

  /**
   *  If the context is being routed to failure handlers after a failure has been triggered by calling
   *  {@link #fail(Throwable)} then this will return that throwable. It can be used by failure handlers to render a response,
   *  e.g. create a failure response page.
   * @return  the throwable used when signalling failure
   * 
   */
  failure() : Error | null;

  /**
   *  If the context is being routed to failure handlers after a failure has been triggered by calling
   *  {@link #fail(int)}  then this will return that status code.  It can be used by failure handlers to render a response,
   *  e.g. create a failure response page.
   * 
   *  When the status code has not been set yet (it is undefined) its value will be -1.
   * @return  the status code used when signalling failure
   * 
   */
  statusCode() : number;

  /**
   *  If the route specifies produces matches, e.g. produces `text/html` and `text/plain`, and the `accept` header
   *  matches one or more of these then this returns the most acceptable match.
   * @return  the most acceptable content type.
   * 
   */
  getAcceptableContentType() : string | null;

  /**
   *  The headers:
   *  <ol>
   *  <li>Accept</li>
   *  <li>Accept-Charset</li>
   *  <li>Accept-Encoding</li>
   *  <li>Accept-Language</li>
   *  <li>Content-Type</li>
   *  </ol>
   *  Parsed into {@link ParsedHeaderValue}
   * @return A container with the parsed headers.
   * 
   */
  parsedHeaders() : ParsedHeaderValues;

  /**
   *  Add a handler that will be called just before headers are written to the response. This gives you a hook where
   *  you can write any extra headers before the response has been written when it will be too late.
   * @param handler  the handler
   * @return  the id of the handler. This can be used if you later want to remove the handler.
   * 
   */
  addHeadersEndHandler(handler: (result: void) => void) : number;

  /**
   *  Remove a headers end handler
   * @param handlerID  the id as returned from {@link io.vertx.ext.web.RoutingContext#addHeadersEndHandler(Handler)}.
   * @return true if the handler existed and was removed, false otherwise
   * 
   */
  removeHeadersEndHandler(handlerID: number) : boolean;

  /**
   *  Provides a handler that will be called after the last part of the body is written to the wire.
   *  The handler is called asynchronously of when the response has been received by the client.
   *  This provides a hook allowing you to do more operations once the request has been sent over the wire.
   *  Do not use this for resource cleanup as this handler might never get called (e.g. if the connection is reset).
   * @param handler  the handler
   * @return  the id of the handler. This can be used if you later want to remove the handler.
   * 
   */
  addBodyEndHandler(handler: (result: void) => void) : number;

  /**
   *  Remove a body end handler
   * @param handlerID  the id as returned from {@link io.vertx.ext.web.RoutingContext#addBodyEndHandler(Handler)}.
   * @return true if the handler existed and was removed, false otherwise
   * 
   */
  removeBodyEndHandler(handlerID: number) : boolean;

  /**
   * 
   * @return true if the context is being routed to failure handlers.
   * 
   */
  failed() : boolean;

  /**
   *  Set the body. Used by the {@link io.vertx.ext.web.handler.BodyHandler}. You will not normally call this method.
   * @param body  the body
   * 
   */
  setBody(body: Buffer) : void;

  /**
   *  Set the session. Used by the {@link io.vertx.ext.web.handler.SessionHandler}. You will not normally call this method.
   * @param session  the session
   * 
   */
  setSession(session: Session) : void;

  /**
   *  Set the user. Usually used by auth handlers to inject a User. You will not normally call this method.
   * @param user  the user
   * 
   */
  setUser(user: User) : void;

  /**
   *  Clear the current user object in the context. This usually is used for implementing a log out feature, since the
   *  current user is unbounded from the routing context.
   * 
   */
  clearUser() : void;

  /**
   *  Set the acceptable content type. Used by
   * @param contentType  the content type
   * 
   */
  setAcceptableContentType(contentType: string | null | undefined) : void;

  /**
   *  Restarts the current router with a new path and reusing the original method. All path parameters are then parsed
   *  and available on the params list.
   * @param path the new http path.
   * 
   */
  reroute(path: string) : void;

  /**
   *  Restarts the current router with a new method and path. All path parameters are then parsed and available on the
   *  params list.
   * @param method the new http request
   * @param path the new http path.
   * 
   */
  reroute(method: HttpMethod, path: string) : void;

  /**
   *  Returns the locales for the current request. The locales are determined from the `accept-languages` header and
   *  sorted on quality.
   * 
   *  When 2 or more entries have the same quality then the order used to return the best match is based on the lowest
   *  index on the original list. For example if a user has en-US and en-GB with same quality and this order the best
   *  match will be en-US because it was declared as first entry by the client.
   * @deprecated Use {@link #acceptableLanguages()} or {@link #parsedHeaders()}.{@link ParsedHeaderValues#acceptLanguage()}
   * @return the best matched locale for the request
   * 
   */
  acceptableLocales() : Locale[];

  /**
   *  Returns the languages for the current request. The languages are determined from the <code>Accept-Language</code>
   *  header and sorted on quality.
   * 
   *  When 2 or more entries have the same quality then the order used to return the best match is based on the lowest
   *  index on the original list. For example if a user has en-US and en-GB with same quality and this order the best
   *  match will be en-US because it was declared as first entry by the client.
   * @return The best matched language for the request
   * 
   */
  acceptableLanguages() : LanguageHeader[];

  /**
   *  Helper to return the user preferred locale. It is the same action as returning the first element of the acceptable
   *  locales.
   * @deprecated Use {@link #preferredLanguage()} instead
   * @return the users preferred locale.
   * 
   */
  preferredLocale() : Locale;

  /**
   *  Helper to return the user preferred language.
   *  It is the same action as returning the first element of the acceptable languages.
   * @return the users preferred locale.
   * 
   */
  preferredLanguage() : LanguageHeader;

  /**
   *  Returns a map of named parameters as defined in path declaration with their actual values
   * @return the map of named parameters
   * 
   */
  pathParams() : { [key:string]: string; };

  /**
   *  Gets the value of a single path parameter
   * @param name the name of parameter as defined in path declaration
   * @return the actual value of the parameter or null if it doesn't exist
   * 
   */
  pathParam(name: string) : string | null;

  /**
   *  Returns a map of all query parameters inside the <a href="https://en.wikipedia.org/wiki/Query_string">query string</a>
   * @return the multimap of query parameters
   * 
   */
  queryParams() : MultiMap;

  /**
   *  Gets the value of a single query parameter
   * @param query The name of query parameter
   * @return The list of all elements inside query parameter
   * 
   */
  queryParam(query: string) : string[] | null;

}


export class Session {
  /**
   * 
   * @return The new unique ID of the session.
   * 
   */
  regenerateId() : Session;

  /**
   * 
   * @return The unique ID of the session. This is generated using a random secure UUID.
   * 
   */
  id() : string;

  /**
   *  Put some data in a session
   * @param key  the key for the data
   * @param obj  the data
   * @return a reference to this, so the API can be used fluently
   * 
   */
  put(key: string, obj: any) : Session;

  /**
   *  Get some data from the session
   * @param key  the key of the data
   * @return  the data
   * 
   */
  get(key: string) : Object;

  /**
   *  Remove some data from the session
   * @param key  the key of the data
   * @return  the data that was there or null if none there
   * 
   */
  remove(key: string) : Object;

  /**
   * 
   * @return the time the session was last accessed
   * 
   */
  lastAccessed() : number;

  /**
   *  Destroy the session
   * 
   */
  destroy() : void;

  /**
   * 
   * @return has the session been destroyed?
   * 
   */
  isDestroyed() : boolean;

  /**
   * 
   * @return has the session been renewed?
   * 
   */
  isRegenerated() : boolean;

  /**
   * 
   * @return old ID if renewed
   * 
   */
  oldId() : string;

  /**
   * 
   * @return the amount of time in ms, after which the session will expire, if not accessed.
   * 
   */
  timeout() : number;

  /**
   *  Mark the session as being accessed.
   * 
   */
  setAccessed() : void;

}


export class SessionHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Create a session handler
   * @param sessionStore  the session store
   * @return the handler
   * 
   */
  static create(sessionStore: SessionStore) : SessionHandler;

  /**
   *  Set the session timeout
   * @param timeout  the timeout, in ms.
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSessionTimeout(timeout: number) : SessionHandler;

  /**
   *  Set whether a nagging log warning should be written if the session handler is accessed over HTTP, not
   *  HTTPS
   * @param nag  true to nag
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setNagHttps(nag: boolean) : SessionHandler;

  /**
   *  Sets whether the 'secure' flag should be set for the session cookie. When set this flag instructs browsers to only
   *  send the cookie over HTTPS. Note that this will probably stop your sessions working if used without HTTPS (e.g. in development).
   * @param secure true to set the secure flag on the cookie
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setCookieSecureFlag(secure: boolean) : SessionHandler;

  /**
   *  Sets whether the 'HttpOnly' flag should be set for the session cookie. When set this flag instructs browsers to
   *  prevent Javascript access to the the cookie. Used as a line of defence against the most common XSS attacks.
   * @param httpOnly true to set the HttpOnly flag on the cookie
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setCookieHttpOnlyFlag(httpOnly: boolean) : SessionHandler;

  /**
   *  Set the session cookie name
   * @param sessionCookieName  the session cookie name
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSessionCookieName(sessionCookieName: string) : SessionHandler;

  /**
   *  Set expected session id minimum length.
   * @param minLength  the session id minimal length
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMinLength(minLength: number) : SessionHandler;

}


export class SessionStore {
  /**
   *  The retry timeout value in milli seconds used by the session handler when it retrieves a value from the store.<p/>
   * 
   *  A non positive value means there is no retry at all.
   * @return the timeout value, in ms
   * 
   */
  retryTimeout() : number;

  /**
   *  Create a new session using the default min length.
   * @param timeout - the session timeout, in ms
   * @return the session
   * 
   */
  createSession(timeout: number) : Session;

  /**
   *  Create a new session
   * @param timeout - the session timeout, in ms
   * @param length - the required length for the session id
   * @return the session
   * 
   */
  createSession(timeout: number, length: number) : Session;

  /**
   *  Get the session with the specified ID
   * @param id  the unique ID of the session
   * @param resultHandler  will be called with a result holding the session, or a failure
   * 
   */
  get(id: string, resultHandler: (result: AsyncResult<Session>) => void) : void;

  /**
   *  Delete the session with the specified ID
   * @param id  the unique ID of the session
   * @param resultHandler  will be called with a success or a failure
   * 
   */
  delete(id: string, resultHandler: (result: AsyncResult<void>) => void) : void;

  /**
   *  Add a session with the specified ID
   * @param session  the session
   * @param resultHandler  will be called with a success or a failure
   * 
   */
  put(session: Session, resultHandler: (result: AsyncResult<void>) => void) : void;

  /**
   *  Remove all sessions from the store
   * @param resultHandler  will be called with a success or a failure
   * 
   */
  clear(resultHandler: (result: AsyncResult<void>) => void) : void;

  /**
   *  Get the number of sessions in the store
   * @param resultHandler  will be called with the number, or a failure
   * 
   */
  size(resultHandler: (result: AsyncResult<number>) => void) : void;

  /**
   *  Close the store
   * 
   */
  close() : void;

}

import { SockJSHandlerOptions } from './options';
import { BridgeOptions } from './options';

export class SockJSHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Create a SockJS handler
   * @param vertx  the Vert.x instance
   * @return the handler
   * 
   */
  static create(vertx: Vertx) : SockJSHandler;

  /**
   *  Create a SockJS handler
   * @param vertx  the Vert.x instance
   * @param options  options to configure the handler
   * @return the handler
   * 
   */
  static create(vertx: Vertx, options: SockJSHandlerOptions) : SockJSHandler;

  /**
   *  Install SockJS test applications on a router - used when running the SockJS test suite
   * @param router  the router to install on
   * @param vertx  the Vert.x instance
   * 
   */
  static installTestApplications(router: Router, vertx: Vertx) : void;

  /**
   *  Set a SockJS socket handler. This handler will be called with a SockJS socket whenever a SockJS connection
   *  is made from a client
   * @param handler  the handler
   * @return a reference to this, so the API can be used fluently
   * 
   */
  socketHandler(handler: (result: SockJSSocket) => void) : SockJSHandler;

  /**
   *  Bridge the SockJS handler to the Vert.x event bus. This basically installs a built-in SockJS socket handler
   *  which takes SockJS traffic and bridges it to the event bus, thus allowing you to extend the server-side
   *  Vert.x event bus to browsers
   * @param bridgeOptions  options to configure the bridge with
   * @return a reference to this, so the API can be used fluently
   * 
   */
  bridge(bridgeOptions: BridgeOptions) : SockJSHandler;

  /**
   *  Like {@link io.vertx.ext.web.handler.sockjs.SockJSHandler#bridge(BridgeOptions)} but specifying a handler
   *  that will receive bridge events.
   * @param bridgeOptions  options to configure the bridge with
   * @param bridgeEventHandler  handler to receive bridge events
   * @return a reference to this, so the API can be used fluently
   * 
   */
  bridge(bridgeOptions: BridgeOptions, bridgeEventHandler: (result: BridgeEvent) => void) : SockJSHandler;

}

import { WriteStream } from '@vertx/core';
import { ReadStream } from '@vertx/core';
import { SocketAddress } from '@vertx/core';

export class SockJSSocket {
  end(t: Buffer) : void;

  writeQueueFull() : boolean;

  exceptionHandler(handler: (result: Error) => void | null | undefined) : SockJSSocket;

  handler(handler: (result: Buffer) => void | null | undefined) : SockJSSocket;

  pause() : SockJSSocket;

  resume() : SockJSSocket;

  endHandler(endHandler: (result: void) => void | null | undefined) : SockJSSocket;

  write(data: Buffer) : SockJSSocket;

  /**
   *  Write a {@link String} to the socket, encoded in UTF-8.
   * @param data  the string to write
   * @return a reference to this, so the API can be used fluently
   * 
   */
  write(data: string) : SockJSSocket;

  setWriteQueueMaxSize(maxSize: number) : SockJSSocket;

  drainHandler(handler: (result: void) => void | null | undefined) : SockJSSocket;

  /**
   *  When a {@code SockJSSocket} is created it automatically registers an event handler with the event bus, the ID of that
   *  handler is given by {@code writeHandlerID}.
   *  <p>
   *  Given this ID, a different event loop can send a buffer to that event handler using the event bus and
   *  that buffer will be received by this instance in its own event loop and written to the underlying socket. This
   *  allows you to write data to other sockets which are owned by different event loops.
   * 
   */
  writeHandlerID() : string;

  /**
   *  Call {@link #end()}.
   * 
   */
  end() : void;

  /**
   *  Close it
   * 
   */
  close() : void;

  /**
   *  Return the remote address for this socket
   * 
   */
  remoteAddress() : SocketAddress;

  /**
   *  Return the local address for this socket
   * 
   */
  localAddress() : SocketAddress;

  /**
   *  Return the headers corresponding to the last request for this socket or the websocket handshake
   *  Any cookie headers will be removed for security reasons
   * 
   */
  headers() : MultiMap;

  /**
   *  Return the URI corresponding to the last request for this socket or the websocket handshake
   * 
   */
  uri() : string;

  /**
   * 
   * @return the Vert.x-Web session corresponding to this socket
   * 
   */
  webSession() : Session | null;

  /**
   * 
   * @return the Vert.x-Web user corresponding to this socket
   * 
   */
  webUser() : User | null;

}

import { Http2PushMapping } from './options';

export class StaticHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Create a handler using defaults
   * @return the handler
   * 
   */
  static create() : StaticHandler;

  /**
   *  Create a handler, specifying web-root
   * @param root the web-root
   * @return the handler
   * 
   */
  static create(root: string) : StaticHandler;

  /**
   *  Enable/Disable access to the root of the filesystem
   * @param allowRootFileSystemAccess whether root access is allowed
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setAllowRootFileSystemAccess(allowRootFileSystemAccess: boolean) : StaticHandler;

  /**
   *  Set the web root
   * @param webRoot the web root
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setWebRoot(webRoot: string) : StaticHandler;

  /**
   *  Set whether files are read-only and will never change
   * @param readOnly whether files are read-only
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setFilesReadOnly(readOnly: boolean) : StaticHandler;

  /**
   *  Set value for max age in caching headers
   * @param maxAgeSeconds maximum time for browser to cache, in seconds
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxAgeSeconds(maxAgeSeconds: number) : StaticHandler;

  /**
   *  Set whether cache header handling is enabled
   * @param enabled true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setCachingEnabled(enabled: boolean) : StaticHandler;

  /**
   *  Set whether directory listing is enabled
   * @param directoryListing true if enabled
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setDirectoryListing(directoryListing: boolean) : StaticHandler;

  /**
   *  Set whether hidden files should be served
   * @param includeHidden true if hidden files should be served
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIncludeHidden(includeHidden: boolean) : StaticHandler;

  /**
   *  Set the server cache entry timeout when caching is enabled
   * @param timeout the timeout, in ms
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setCacheEntryTimeout(timeout: number) : StaticHandler;

  /**
   *  Set the index page
   * @param indexPage the index page
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIndexPage(indexPage: string) : StaticHandler;

  /**
   *  Set the max cache size, when caching is enabled
   * @param maxCacheSize the max cache size
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxCacheSize(maxCacheSize: number) : StaticHandler;

  /**
   *  Set the file mapping for http2push and link preload
   * @param http2PushMappings the mapping for http2 push
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setHttp2PushMapping(http2PushMappings: Http2PushMapping[]) : StaticHandler;

  /**
   *  Set whether async filesystem access should always be used
   * @param alwaysAsyncFS true for always async FS access
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setAlwaysAsyncFS(alwaysAsyncFS: boolean) : StaticHandler;

  /**
   *  Set whether async/sync filesystem tuning should enabled
   * @param enableFSTuning true to enabled FS tuning
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setEnableFSTuning(enableFSTuning: boolean) : StaticHandler;

  /**
   *  Set the max serve time in ns, above which serves are considered slow
   * @param maxAvgServeTimeNanoSeconds max serve time, in ns
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setMaxAvgServeTimeNs(maxAvgServeTimeNanoSeconds: number) : StaticHandler;

  /**
   *  Set the directory template to be used when directory listing
   * @param directoryTemplate the directory template
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setDirectoryTemplate(directoryTemplate: string) : StaticHandler;

  /**
   *  Set whether range requests (resumable downloads; media streaming) should be enabled.
   * @param enableRangeSupport true to enable range support
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setEnableRangeSupport(enableRangeSupport: boolean) : StaticHandler;

  /**
   *  Set whether vary header should be sent with response.
   * @param varyHeader true to sent vary header
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setSendVaryHeader(varyHeader: boolean) : StaticHandler;

  /**
   *  Set the default content encoding for text related files. This allows overriding the system settings default value.
   * @param contentEncoding the desired content encoding e.g.: "UTF-8"
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setDefaultContentEncoding(contentEncoding: string) : StaticHandler;

}


export class TemplateEngine {
  /**
   *  Render the template
   * @param context  the routing context
   * @param templateFileName  the template file name to use
   * @param handler  the handler that will be called with a result containing the buffer or a failure.
   * @deprecated  use {@link #render(RoutingContext, String, String, Handler)}
   * 
   */
  render(context: RoutingContext, templateFileName: string, handler: (result: AsyncResult<Buffer>) => void) : void;

  /**
   *  Render the template
   *  <p>
   *  <b>NOTE</b> if you call method directly (i.e. not using {@link io.vertx.ext.web.handler.TemplateHandler}) make sure
   *  that <i>templateFileName</i> is sanitized via {@link io.vertx.ext.web.impl.Utils#normalizePath(String)}
   * @param context  the routing context
   * @param templateDirectory  the template directory to use
   * @param templateFileName  the relative template file name to use
   * @param handler  the handler that will be called with a result containing the buffer or a failure.
   * 
   */
  render(context: RoutingContext, templateDirectory: string, templateFileName: string, handler: (result: AsyncResult<Buffer>) => void) : void;

  /**
   *  Returns true if the template engine caches template files. If false, then template files are freshly loaded each
   *  time they are used.
   * @return True if template files are cached; otherwise, false.
   * 
   */
  isCachingEnabled() : boolean;

}


export class TemplateHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Set the index template
   * @param indexTemplate the index template
   * @return a reference to this, so the API can be used fluently
   * 
   */
  setIndexTemplate(indexTemplate: string) : TemplateHandler;

  /**
   *  Create a handler
   * @param engine  the template engine
   * @return the handler
   * 
   */
  static create(engine: TemplateEngine) : TemplateHandler;

  /**
   *  Create a handler
   * @param engine  the template engine
   * @param templateDirectory  the template directory where templates will be looked for
   * @param contentType  the content type header to be used in the response
   * @return the handler
   * 
   */
  static create(engine: TemplateEngine, templateDirectory: string, contentType: string) : TemplateHandler;

}


export class TimeoutHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Create a handler
   * @return the handler
   * 
   */
  static create() : TimeoutHandler;

  /**
   *  Create a handler
   * @param timeout  the timeout, in ms
   * @return the handler
   * 
   */
  static create(timeout: number) : TimeoutHandler;

  /**
   *  Create a handler
   * @param timeout  the timeout, in ms
   * @return the handler
   * 
   */
  static create(timeout: number, errorCode: number) : TimeoutHandler;

}


export class UserSessionHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Create a new handler
   * @param authProvider  The auth provider to use
   * @return  the handler
   * 
   */
  static create(authProvider: AuthProvider) : UserSessionHandler;

}


export class VirtualHostHandler {
  handle(arg0: RoutingContext) : void;

  /**
   *  Create a handler
   * @return the handler
   * 
   */
  static create(hostname: string, handler: (result: RoutingContext) => void) : VirtualHostHandler;

}

